{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-configspaces-documentation","title":"Welcome to ConfigSpace's documentation!","text":"<p>ConfigSpace is a simple python package to manage configuration spaces for algorithm configuration and hyperparameter optimization tasks. It includes various modules to translate between different text formats for configuration space descriptions.</p> <p>ConfigSpace is often used in AutoML tools such as SMAC3, BOHB, auto-sklearn. To read more about our group and projects, visit our homepage AutoML.org.</p> <p>This documentation explains how to use ConfigSpace and demonstrates its features. In the quickstart, you will see how to set up a <code>ConfiguratonSpace</code> and add hyperparameters of different types to it. Besides containing hyperparameters, <code>ConfigurationSpace</code> can contain constraints such as conditions and forbidden clauses. Those are introduced in the user guide</p> <p>New in 1.1!</p> <p>In ConfigSpace 1.1, we have removed the dependancy on <code>Cython</code> while even improving the performance!</p> <ul> <li>Should now install anywhere.</li> <li>You can now use your editor to jump to definition and see the source code.</li> <li>Contribute more easily!</li> </ul> <p>There is no also better support in Categorical, Ordinal and Constant hyperparameters, for arbitrary values, for example:</p> <pre><code>from dataclasses import dataclass\nfrom ConfigSpace import ConfigurationSpace, Constant\n\n@dataclass\nclass A:\n    a: int\n\ndef f() -&gt; None:\n    return None\n\ncs = ConfigurationSpace({\n    \"cat\": [True, False, None],\n    \"othercat\": [A(1), f],\n    \"constant\": Constant(\"constant\": (24, 25)),\n})\n</code></pre> <p>With this, we have also deprecated many of the previous functions, simplifying the API where possible or improving it's clarity. We have tried hard to keep everything backwards compatible, and also recommend the new functionality to use!</p> <p>We've also made some strides towards extensibilty of ConfigSpace, making it simpler to define you own hyperparamter types. Please see the hyperparameter reference page for more.</p> <p>Warning</p> <p>One notable hard removal is the use of the <code>\"q\"</code> parameter to numerical parameters. We recommend using an <code>Ordinal</code> distribution where possible. Please let us know if this effects you and we can help migrate where possible.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Create a simple <code>ConfigurationSpace</code> and then sample a <code>Configuration</code> from it.</p> <pre><code>from ConfigSpace import ConfigurationSpace\n\ncs = ConfigurationSpace({\n    \"myfloat\": (0.1, 1.5),                # Uniform Float\n    \"myint\": (2, 10),                     # Uniform Integer\n    \"species\": [\"mouse\", \"cat\", \"dog\"],   # Categorical\n})\nconfigs = cs.sample_configuration(2)\nprint(configs)\n</code></pre> <pre><code>[Configuration(values={\n  'myfloat': 0.4688318940061,\n  'myint': 2,\n  'species': np.str_('dog'),\n}), Configuration(values={\n  'myfloat': 1.4200381738294,\n  'myint': 10,\n  'species': np.str_('dog'),\n})]\n</code></pre> <p>Use <code>Float</code>, <code>Integer</code>, and <code>Categorical</code> to define hyperparameters and define how sampling is done.</p> <pre><code>from ConfigSpace import ConfigurationSpace, Integer, Float, Categorical, Normal\n\ncs = ConfigurationSpace(\n    name=\"myspace\",\n    seed=1234,\n    space={\n        \"a\": Float(\"a\", bounds=(0.1, 1.5), distribution=Normal(1, 0.5)),\n        \"b\": Integer(\"b\", bounds=(1, 10_00), log=True, default=100),\n        \"c\": Categorical(\"c\", [\"mouse\", \"cat\", \"dog\"], weights=[2, 1, 1]),\n    },\n)\nconfigs = cs.sample_configuration(2)\nprint(configs)\n</code></pre> <pre><code>[Configuration(values={\n  'a': 0.561388655784,\n  'b': 6,\n  'c': np.str_('mouse'),\n}), Configuration(values={\n  'a': 1.0464213025979,\n  'b': 6,\n  'c': np.str_('cat'),\n})]\n</code></pre> <p>Maximum flexibility with conditionals, see the user guide for more information.</p> <pre><code>from ConfigSpace import Categorical, ConfigurationSpace, EqualsCondition, Float\n\ncs = ConfigurationSpace(seed=1234)\n\nc = Categorical(\"c1\", items=[\"a\", \"b\"])\nf = Float(\"f1\", bounds=(1.0, 10.0))\n\n# A condition where `f` is only active if `c` is equal to `a` when sampled\ncond = EqualsCondition(f, c, \"a\")\n\n# Add them explicitly to the configuration space\ncs.add([c, f])\ncs.add(cond)\n\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    c1, Type: Categorical, Choices: {a, b}, Default: a\n    f1, Type: UniformFloat, Range: [1.0, 10.0], Default: 5.5\n  Conditions:\n    f1 | c1 == 'a'\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>ConfigSpace requires Python 3.8 or higher and can be installed directly from the Python Package Index (PyPI) using <code>pip</code>.</p> <pre><code>pip install ConfigSpace\n</code></pre>"},{"location":"#citing-configspace","title":"Citing ConfigSpace","text":"<pre><code> @article{\n     title   = {BOAH: A Tool Suite for Multi-Fidelity Bayesian Optimization &amp; Analysis of Hyperparameters},\n     author  = {M. Lindauer and K. Eggensperger and M. Feurer and A. Biedenkapp and J. Marben and P. M\u00fcller and F. Hutter},\n     journal = {arXiv:1908.06756 {[cs.LG]}},\n     date    = {2019},\n }\n</code></pre>"},{"location":"guide/","title":"Guide","text":""},{"location":"guide/#user-guide","title":"User Guide","text":"<p>In this user guide, the concepts of using different hyperparameters, applying conditions and forbidden clauses to a configuration space are explained.</p> <p>These concepts will be introduced by defining a more complex configuration space for a support vector machine.</p>"},{"location":"guide/#1st-example-integer-hyperparameters-and-float-hyperparameters","title":"1st Example: Integer hyperparameters and float hyperparameters","text":"<p>Assume that we want to use a support vector machine (=SVM) for classification tasks and therefore, we want to optimize its hyperparameters:</p> <ul> <li><code>C</code>: regularization constant  with <code>C</code> being a float value.</li> <li><code>max_iter</code>: the maximum number of iterations within the solver with <code>max_iter</code> being a positive integer.</li> </ul> <p>The implementation of the classifier is out of scope and thus not shown. But for further reading about support vector machines and the meaning of its hyperparameter, you can continue reading here or in the scikit-learn documentation.</p> <p>The first step is always to create a <code>ConfigurationSpace</code> with the hyperparameters <code>C</code> and <code>max_iter</code>.</p> <p>To restrict the search space, we choose <code>C</code> to be a <code>Float</code> between -1 and 1. Furthermore, we choose <code>max_iter</code> to be an <code>Integer</code>.</p> <pre><code>from ConfigSpace import ConfigurationSpace\n\ncs = ConfigurationSpace(\n    space={\n        \"C\": (-1.0, 1.0),  # Note the decimal to make it a float\n        \"max_iter\": (10, 100),\n    },\n    seed=1234,\n)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    C, Type: UniformFloat, Range: [-1.0, 1.0], Default: 0.0\n    max_iter, Type: UniformInteger, Range: [10, 100], Default: 55\n</code></pre> <p>Now, the <code>ConfigurationSpace</code> object cs contains definitions of the hyperparameters <code>C</code> and <code>max_iter</code> with their value-ranges.</p> <p>For demonstration purpose, we sample a configuration from it.</p> <pre><code>config = cs.sample_configuration()\nprint(config)\n</code></pre> <pre><code>Configuration(values={\n  'C': -0.6169610992422,\n  'max_iter': 33,\n})\n</code></pre> <p>Sampled instances from a <code>ConfigurationSpace</code> are called a <code>Configuration</code>. In a <code>Configuration</code>, a parameter can be accessed or modified similar to a python dictionary.</p> <pre><code>for key, value in config.items():\n    print(f\"{key}: {value}\")\n\nprint(config[\"C\"])\n</code></pre> <pre><code>C: -0.6169610992422\nmax_iter: 33\n-0.6169610992422\n</code></pre>"},{"location":"guide/#2nd-example-categorical-hyperparameters-and-conditions","title":"2nd Example: Categorical hyperparameters and conditions","text":"<p>The scikit-learn SVM supports different kernels, such as an RBF, a sigmoid, a linear or a polynomial kernel. We want to include them in the configuration space. Since this new hyperparameter has a finite number of values, we use a [<code>Categorical</code>][<code>ConfigSpace.api.types.categorical.Categorical</code>].</p> <ul> <li><code>kernel_type</code> in <code>['linear', 'poly', 'rbf', 'sigmoid']</code>.</li> </ul> <p>Taking a look at the SVM documentation, we observe that if the kernel type is chosen to be <code>'poly'</code>, another hyperparameter <code>degree</code> must be specified. Also, for the kernel types <code>'poly'</code> and <code>'sigmoid'</code>, there is an additional hyperparameter <code>coef0</code>. As well as the hyperparameter <code>gamma</code> for the kernel types <code>'rbf'</code>, <code>'poly'</code> and <code>'sigmoid'</code>.</p> <ul> <li><code>degree</code>: the integer degree of a polynomial kernel function.</li> <li><code>coef0</code>: Independent term in kernel function. It is only needed for <code>'poly'</code> and <code>'sigmoid'</code> kernel.</li> <li><code>gamma</code>: Kernel coefficient for <code>'rbf'</code>, <code>'poly'</code> and <code>'sigmoid'</code>.</li> </ul> <p>To realize the different hyperparameter for the kernels, we use Conditionals. Please refer to their reference page for more.</p> <p>Even in simple examples, the configuration space grows easily very fast and with it the number of possible configurations. It makes sense to limit the search space for hyperparameter optimizations in order to quickly find good configurations. For conditional hyperparameters (hyperparameters which only take a value if some condition is met), ConfigSpace achieves this by sampling those hyperparameters from the configuration space only if their condition is met.</p> <p>To add conditions on hyperparameters to the configuration space, we first have to insert the new hyperparameters in the <code>ConfigSpace</code> and in a second step, the conditions on them.</p> <pre><code>from ConfigSpace import ConfigurationSpace, Categorical, Float, Integer\n\nkernel_type = Categorical('kernel_type', ['linear', 'poly', 'rbf', 'sigmoid'])\ndegree = Integer('degree', bounds=(2, 4), default=2)\ncoef0 = Float('coef0', bounds=(0, 1), default=0.0)\ngamma = Float('gamma', bounds=(1e-5, 1e2), default=1, log=True)\n\ncs = ConfigurationSpace()\ncs.add([kernel_type, degree, coef0, gamma])\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    coef0, Type: UniformFloat, Range: [0.0, 1.0], Default: 0.0\n    degree, Type: UniformInteger, Range: [2, 4], Default: 2\n    gamma, Type: UniformFloat, Range: [1e-05, 100.0], Default: 1.0, on log-scale\n    kernel_type, Type: Categorical, Choices: {linear, poly, rbf, sigmoid}, Default: linear\n</code></pre> <p>First, we define the conditions. Conditions work by constraining a child hyperparameter (the first argument) on its parent hyperparameter (the second argument) being in a certain relation to a value (the third argument). <code>EqualsCondition(degree, kernel_type, 'poly')</code> expresses that <code>degree</code> is constrained on <code>kernel_type</code> being equal to the value <code>'poly'</code>. To express constraints involving multiple parameters or values, we can use conjunctions. In the following example, <code>cond_2</code> describes that <code>coef0</code> is a valid hyperparameter, if the <code>kernel_type</code> has either the value <code>'poly'</code> or <code>'sigmoid'</code>.</p> <pre><code>from ConfigSpace import EqualsCondition, InCondition, OrConjunction\n\n# read as: \"degree is active if kernel_type == 'poly'\"\ncond_1 = EqualsCondition(degree, kernel_type, 'poly')\n\n# read as: \"coef0 is active if (kernel_type == 'poly' or kernel_type == 'sigmoid')\"\n# You could also define this using an InCondition as shown below\ncond_2 = OrConjunction(\n    EqualsCondition(coef0, kernel_type, 'poly'),\n    EqualsCondition(coef0, kernel_type, 'sigmoid')\n)\n\n# read as: \"gamma is active if kernel_type in ['rbf', 'poly', 'sigmoid']\"\ncond_3 = InCondition(gamma, kernel_type, ['rbf', 'poly','sigmoid'])\n</code></pre> <pre><code>\n</code></pre> <p>Finally, we add the conditions to the configuration space</p> <pre><code>cs.add([cond_1, cond_2, cond_3])\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    coef0, Type: UniformFloat, Range: [0.0, 1.0], Default: 0.0\n    degree, Type: UniformInteger, Range: [2, 4], Default: 2\n    gamma, Type: UniformFloat, Range: [1e-05, 100.0], Default: 1.0, on log-scale\n    kernel_type, Type: Categorical, Choices: {linear, poly, rbf, sigmoid}, Default: linear\n  Conditions:\n    (coef0 | kernel_type == 'poly' || coef0 | kernel_type == 'sigmoid')\n    degree | kernel_type == 'poly'\n    gamma | kernel_type in {'rbf', 'poly', 'sigmoid'}\n</code></pre> <p>Note</p> <p>ConfigSpace offers a lot of different condition types. Please check out the conditions reference page for more.</p> <p>Warning</p> <p>We advise not  using the <code>EqualsCondition</code> or the <code>InCondition</code> on float hyperparameters. Due to numerical rounding that can occur, it can be the case that these conditions evaluate to <code>False</code> even if they should evaluate to <code>True</code>.</p>"},{"location":"guide/#3rd-example-forbidden-clauses","title":"3rd Example: Forbidden clauses","text":"<p>It may occur that some states in the configuration space are not allowed. ConfigSpace supports this functionality by offering Forbidden clauses.</p> <p>We demonstrate the usage of Forbidden clauses by defining the configuration space for the linear SVM. Again, we use the sklearn implementation. This implementation has three hyperparameters to tune:</p> <ul> <li><code>penalty</code>: Specifies the norm used in the penalization with values <code>'l1'</code> or <code>'l2j'</code>.</li> <li><code>loss</code>: Specifies the loss function with values <code>'hinge'</code> or <code>'squared_hinge'</code>.</li> <li><code>dual</code>: Solves the optimization problem either in the dual or simple form with values <code>True</code> or <code>False</code>.</li> </ul> <p>Because some combinations of <code>penalty</code>, <code>loss</code> and <code>dual</code> just don't work together, we want to make sure that these combinations are not sampled from the configuration space. It is possible to represent these as conditionals, however sometimes it is easier to express them as forbidden clauses.</p> <p>First, we add these three new hyperparameters to the configuration space.</p> <pre><code>from ConfigSpace import ConfigurationSpace, Categorical, Constant\n\ncs = ConfigurationSpace()\n\npenalty = Categorical(\"penalty\", [\"l1\", \"l2\"], default=\"l2\")\nloss = Categorical(\"loss\", [\"hinge\", \"squared_hinge\"], default=\"squared_hinge\")\ndual = Constant(\"dual\", \"False\")\ncs.add([penalty, loss, dual])\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    dual, Type: Constant, Value: False\n    loss, Type: Categorical, Choices: {hinge, squared_hinge}, Default: squared_hinge\n    penalty, Type: Categorical, Choices: {l1, l2}, Default: l2\n</code></pre> <p>Now, we want to forbid the following hyperparameter combinations:</p> <ul> <li><code>penalty</code> is <code>'l1'</code> and <code>loss</code> is <code>'hinge'</code>.</li> <li><code>dual</code> is False and <code>penalty</code> is <code>'l2'</code> and <code>loss</code> is <code>'hinge'</code></li> <li><code>dual</code> is False and <code>penalty</code> is <code>'l1'</code></li> </ul> <pre><code>from ConfigSpace import ForbiddenEqualsClause, ForbiddenAndConjunction\n\npenalty_and_loss = ForbiddenAndConjunction(\n    ForbiddenEqualsClause(penalty, \"l1\"),\n    ForbiddenEqualsClause(loss, \"hinge\")\n)\nconstant_penalty_and_loss = ForbiddenAndConjunction(\n    ForbiddenEqualsClause(dual, \"False\"),\n    ForbiddenEqualsClause(penalty, \"l2\"),\n    ForbiddenEqualsClause(loss, \"hinge\")\n)\npenalty_and_dual = ForbiddenAndConjunction(\n    ForbiddenEqualsClause(dual, \"False\"),\n    ForbiddenEqualsClause(penalty, \"l1\")\n)\n</code></pre> <pre><code>\n</code></pre> <p>In the last step, we add them to the configuration space object:</p> <pre><code>cs.add([penalty_and_loss, constant_penalty_and_loss, penalty_and_dual])\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    dual, Type: Constant, Value: False\n    loss, Type: Categorical, Choices: {hinge, squared_hinge}, Default: squared_hinge\n    penalty, Type: Categorical, Choices: {l1, l2}, Default: l2\n  Forbidden Clauses:\n    (Forbidden: dual == 'False' &amp;&amp; Forbidden: penalty == 'l1')\n    (Forbidden: dual == 'False' &amp;&amp; Forbidden: penalty == 'l2' &amp;&amp; Forbidden: loss == 'hinge')\n    (Forbidden: penalty == 'l1' &amp;&amp; Forbidden: loss == 'hinge')\n</code></pre>"},{"location":"guide/#4th-example-serialization","title":"4th Example Serialization","text":"<p>To serialize the <code>ConfigurationSpace</code> object, we can choose between different output formats, such as as plain-type dictionary, directly to <code>.yaml</code> or <code>.json</code> and if required for backwards compatiblity <code>pcs</code>. Plese see the serialization reference page for more.</p> <p>In this example, we want to store the <code>ConfigurationSpace</code> object as a <code>.yaml</code> file.</p> <pre><code>from pathlib import Path\nfrom ConfigSpace import ConfigurationSpace\n\npath = Path(\"configspace.yaml\")\ncs = ConfigurationSpace(\n    space={\n        \"C\": (-1.0, 1.0),  # Note the decimal to make it a float\n        \"max_iter\": (10, 100),\n    },\n    seed=1234,\n)\ncs.to_yaml(path)\nloaded_cs = ConfigurationSpace.from_yaml(path)\n\nwith path.open() as f:\n    print(f.read())\n</code></pre> <pre><code>conditions: []\nforbiddens: []\nformat_version: 0.4\nhyperparameters:\n- default_value: 0.0\n  log: false\n  lower: -1.0\n  meta: null\n  name: C\n  type: uniform_float\n  upper: 1.0\n- default_value: 55\n  log: false\n  lower: 10\n  meta: null\n  name: max_iter\n  type: uniform_int\n  upper: 100\nname: null\npython_module_version: 1.1.3\n</code></pre> <p>If you require custom encoding or decoding or parameters, please refer to the serialization reference page for more.</p>"},{"location":"guide/#5th-example-placing-priors-on-the-hyperparameters","title":"5th Example: Placing priors on the hyperparameters","text":"<p>If you want to conduct black-box optimization in SMAC, and you have prior knowledge about the which regions of the search space are more likely to contain the optimum, you may include this knowledge when designing the configuration space. More specifically, you place prior distributions over the optimum on the parameters, either by a (log)-normal or (log)-Beta distribution. SMAC then considers the given priors through the optimization by using PiBO.</p> <p>Consider the case of optimizing the accuracy of an MLP with three hyperparameters:</p> <ul> <li>learning rate in  <code>(1e-5, 1e-1)</code></li> <li>dropout in <code>(0, 0.99)</code></li> <li>activation in <code>[\"Tanh\", \"ReLU\"]</code>.</li> </ul> <p>From prior experience, you believe the optimal learning rate to be around <code>1e-3</code>, a good dropout to be around <code>0.25</code>, and the optimal activation function to be ReLU about 80% of the time.</p> <p>This can be represented accordingly:</p> <pre><code>import numpy as np\nfrom ConfigSpace import ConfigurationSpace, Float, Categorical, Beta, Normal\n\ncs = ConfigurationSpace(\n    space={\n        \"lr\": Float(\n            'lr',\n            bounds=(1e-5, 1e-1),\n            default=1e-3,\n            log=True,\n            distribution=Normal(1e-3, 1e-1)\n        ),\n        \"dropout\": Float(\n            'dropout',\n            bounds=(0, 0.99),\n            default=0.25,\n            distribution=Beta(alpha=2, beta=4)\n        ),\n        \"activation\": Categorical(\n            'activation',\n            items=['tanh', 'relu'],\n            weights=[0.2, 0.8]\n        ),\n    },\n    seed=1234,\n)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    activation, Type: Categorical, Choices: {tanh, relu}, Default: relu, Probabilities: [0.2 0.8]\n    dropout, Type: BetaFloat, Alpha: 2.0, Beta: 4.0, Range: [0.0, 0.99], Default: 0.25\n    lr, Type: NormalFloat, Mu: 0.001, Sigma: 0.1, Range: [1e-05, 0.1], Default: 0.001, on log-scale\n</code></pre> <p>To check that your prior makes sense for each hyperparameter, you can easily do so with the <code>pdf_values()</code> method. There, you will see that the probability of the optimal learning rate peaks at 10^-3, and decays as we go further away from it:</p> <pre><code>test_points = np.logspace(-5, -1, 5)\nprint(test_points)\nprint(cs['lr'].pdf_values(test_points))\n</code></pre> <pre><code>[1.e-05 1.e-04 1.e-03 1.e-02 1.e-01]\n[0.226227   1.01401116 1.67189438 1.01401116 0.226227  ]\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#quickstart","title":"Quickstart","text":"<p>A ConfigurationSpace is a data structure to describe the configuration space of an algorithm to tune. Possible hyperparameter types are numerical, categorical, conditional and ordinal hyperparameters.</p> <p>AutoML tools, such as <code>SMAC3</code> and <code>BOHB</code> are using the configuration space module to sample hyperparameter configurations. Also, <code>auto-sklearn</code>, an automated machine learning toolkit, which frees the machine learning user from algorithm selection and hyperparameter tuning, makes heavy use of the ConfigSpace package.</p> <p>This simple quickstart tutorial will show you, how to set up your own ConfigurationSpace, and will demonstrate what you can realize with it. This Basic Usage will include the following:</p> <ul> <li>Create a ConfigurationSpace</li> <li>Define a simple hyperparameter with a float value</li> </ul> <p>The Advanced Usage will cover:</p> <ul> <li>Creating two sets of possible model configs, using Conditions.</li> <li>Use a different distirbution for one of the hyperparameters.</li> <li>Create two subspaces from these and add them to a parent ConfigurationSpace</li> <li>Turn these configs into actual models!</li> </ul> <p>These will not show the following and you should refer to the user guide for more:</p> <ul> <li>Add Forbidden clauses</li> <li>Add Conditions</li> <li>Serialize</li> </ul>"},{"location":"quickstart/#basic-usage","title":"Basic Usage","text":"<p>We take a look at a simple ridge regression, which has only one floating hyperparameter <code>alpha</code>.</p> <p>The first step is always to create a ConfigurationSpace object. All the hyperparameters and constraints will be added to this object.</p> <pre><code>from ConfigSpace import ConfigurationSpace, Float\n\ncs = ConfigurationSpace(space={\"alpha\": (0.0, 1.0)}, seed=1234)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    alpha, Type: UniformFloat, Range: [0.0, 1.0], Default: 0.5\n</code></pre> <p>The hyperparameter <code>alpha</code> is chosen to have floating point values from <code>0</code> to <code>1</code>. For demonstration purpose, we sample a configuration from the ConfigurationSpace object.</p> <pre><code>config = cs.sample_configuration()\nprint(config)\n</code></pre> <pre><code>Configuration(values={\n  'alpha': 0.1915194503789,\n})\n</code></pre> <p>You can use this configuration just like you would a regular old python dictionary!</p> <pre><code>for key, value in config.items():\n    print(key, value)\n</code></pre> <pre><code>alpha 0.1915194503789\n</code></pre> <p>And that's it!</p>"},{"location":"quickstart/#advanced-usage","title":"Advanced Usage","text":"<p>Lets create a more complex example where we have two models, model <code>A</code> and model <code>B</code>. Model <code>B</code> is some kernel based algorithm and <code>A</code> just needs a simple float hyperparamter.</p> <p>We're going to create a config space that will let us correctly build a randomly selected model.</p> <pre><code>from typing import Literal\nfrom dataclasses import dataclass\n\n@dataclass\nclass ModelA:\n    alpha: float\n    \"\"\"Some value between 0 and 1\"\"\"\n\n@dataclass\nclass ModelB:\n    kernel: Literal[\"rbf\", \"flooper\"]\n    \"\"\"Kernel type.\"\"\"\n\n    kernel_floops: int | None = None\n    \"\"\"Number of floops for the flooper kernel, only used if kernel == \"flooper\".\"\"\"\n</code></pre> <pre><code>\n</code></pre> <p>First, lets start with building the two individual subspaces where for <code>A</code>, we want to sample alpha from a normal distribution and for <code>B</code> we have the conditioned parameter and we slightly weight one kernel over another.</p> <pre><code>from typing import Literal\nfrom ConfigSpace import ConfigurationSpace, Categorical, Integer, Float, Normal, EqualsCondition\n\n@dataclass\nclass ModelA:\n    alpha: float\n    \"\"\"Some value between 0 and 1\"\"\"\n\n    @staticmethod\n    def space() -&gt; ConfigurationSpace:\n        return ConfigurationSpace({\n            \"alpha\": Float(\"alpha\", bounds=(0, 1), distribution=Normal(mu=0.5, sigma=0.2))\n        })\n\n@dataclass\nclass ModelB:\n    kernel: Literal[\"rbf\", \"flooper\"]\n    \"\"\"Kernel type.\"\"\"\n\n    kernel_floops: int | None = None\n    \"\"\"Number of floops for the flooper kernel, only used if kernel == \"flooper\".\"\"\"\n\n    @staticmethod\n    def space() -&gt; ConfigurationSpace:\n        cs = ConfigurationSpace(\n            {\n                \"kernel\": Categorical(\"kernel\", [\"rbf\", \"flooper\"], default=\"rbf\", weights=[.75, .25]),\n                \"kernel_floops\": Integer(\"kernel_floops\", bounds=(1, 10)),\n            }\n        )\n\n        # We have to make sure \"kernel_floops\" is only active when the kernel is \"floops\"\n        cs.add(EqualsCondition(cs[\"kernel_floops\"], cs[\"kernel\"], \"flooper\"))\n\n        return cs\n</code></pre> <pre><code>\n</code></pre> <p>Finally, we need add these two a parent space where we condition each subspace to only be active depending on a parent. We'll have the default configuration be <code>A</code> but we put more emphasis when sampling on <code>B</code></p> <pre><code>from ConfigSpace import ConfigurationSpace, Categorical\n\ncs = ConfigurationSpace(\n    seed=123456,\n    space={\n        \"model\": Categorical(\"model\", [\"A\", \"B\"], default=\"A\", weights=[1, 2]),\n    }\n)\n\n# We set the prefix and delimiter to be empty string \"\" so that we don't have to do\n# any extra parsing once sampling\ncs.add_configuration_space(\n    prefix=\"\",\n    delimiter=\"\",\n    configuration_space=ModelA.space(),\n    parent_hyperparameter={\"parent\": cs[\"model\"], \"value\": \"A\"},\n)\n\ncs.add_configuration_space(\n    prefix=\"\",\n    delimiter=\"\",\n    configuration_space=ModelB.space(),\n    parent_hyperparameter={\"parent\": cs[\"model\"], \"value\": \"B\"}\n)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    alpha, Type: NormalFloat, Mu: 0.5, Sigma: 0.2, Range: [0.0, 1.0], Default: 0.5\n    kernel, Type: Categorical, Choices: {rbf, flooper}, Default: rbf, Probabilities: [0.75 0.25]\n    kernel_floops, Type: UniformInteger, Range: [1, 10], Default: 6\n    model, Type: Categorical, Choices: {A, B}, Default: A, Probabilities: [0.33333333 0.66666667]\n  Conditions:\n    alpha | model == 'A'\n    kernel | model == 'B'\n    kernel_floops | kernel == 'flooper'\n</code></pre> <p>And that's it!</p> <p>However for completness, lets examine how this works by first sampling from our config space.</p> <pre><code>configs = cs.sample_configuration(4)\nprint(configs)\n</code></pre> <pre><code>[Configuration(values={\n  'model': np.str_('A'),\n  'alpha': 0.4165543657281,\n}), Configuration(values={\n  'model': np.str_('B'),\n  'kernel': np.str_('rbf'),\n}), Configuration(values={\n  'model': np.str_('A'),\n  'alpha': 0.6956537933613,\n}), Configuration(values={\n  'model': np.str_('B'),\n  'kernel': np.str_('flooper'),\n  'kernel_floops': 5,\n})]\n</code></pre> <p>We can see the three different kinds of models we have, our basic <code>A</code> model as well as our <code>B</code> model with the two kernels.</p> <p>Next, we do some processing of these configs to generate valid params to pass to these models</p> <pre><code>models = []\n\nfor config in configs:\n    config_as_dict = dict(config)\n    model_type = config_as_dict.pop(\"model\")\n\n    model = ModelA(**config_as_dict) if model_type == \"A\" else ModelB(**config_as_dict)\n\n    models.append(model)\n\nprint(models)\n</code></pre> <pre><code>[ModelA(alpha=0.4165543657281), ModelB(kernel=np.str_('rbf'), kernel_floops=None), ModelA(alpha=0.6956537933613), ModelB(kernel=np.str_('flooper'), kernel_floops=5)]\n</code></pre> <p>To continue reading, visit the user guide section. There are more information about hyperparameters, as well as an introduction to the powerful concepts of Conditions and Forbidden clauses.</p>"},{"location":"api/ConfigSpace/c_util/","title":"C util","text":""},{"location":"api/ConfigSpace/c_util/#ConfigSpace.c_util","title":"ConfigSpace.c_util","text":""},{"location":"api/ConfigSpace/conditions/","title":"Conditions","text":""},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions","title":"ConfigSpace.conditions","text":""},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.AndConjunction","title":"AndConjunction","text":"<pre><code>AndConjunction(*args: Condition | Conjunction)\n</code></pre> <p>               Bases: <code>Conjunction</code></p> <p>The following example shows how two constraints with an AndConjunction can be combined.</p> <pre><code>from ConfigSpace import (\n    ConfigurationSpace,\n    LessThanCondition,\n    GreaterThanCondition,\n    AndConjunction\n)\n\ncs = ConfigurationSpace({ \"a\": (5, 15), \"b\": (0, 10), \"c\": (0.0, 1.0) })\n\nless_cond = LessThanCondition(cs['c'], cs['a'], 10)\ngreater_cond = GreaterThanCondition(cs['c'], cs['b'], 5)\ncs.add(AndConjunction(less_cond, greater_cond))\n\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: UniformInteger, Range: [5, 15], Default: 10\n    b, Type: UniformInteger, Range: [0, 10], Default: 5\n    c, Type: UniformFloat, Range: [0.0, 1.0], Default: 0.5\n  Conditions:\n    (c | a &lt; 10 &amp;&amp; c | b &gt; 5)\n</code></pre> PARAMETER DESCRIPTION <code>*args</code> <p>conditions, which will be combined with an AndConjunction</p> <p> TYPE: <code>Condition | Conjunction</code> DEFAULT: <code>()</code> </p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def __init__(self, *args: Condition | Conjunction) -&gt; None:\n    \"\"\"By using the *AndConjunction*, constraints can easily be connected.\n\n    The following example shows how two constraints with an *AndConjunction*\n    can be combined.\n\n    ```python exec=\"true\", source=\"material-block\" result=\"python\"\n    from ConfigSpace import (\n        ConfigurationSpace,\n        LessThanCondition,\n        GreaterThanCondition,\n        AndConjunction\n    )\n\n    cs = ConfigurationSpace({ \"a\": (5, 15), \"b\": (0, 10), \"c\": (0.0, 1.0) })\n\n    less_cond = LessThanCondition(cs['c'], cs['a'], 10)\n    greater_cond = GreaterThanCondition(cs['c'], cs['b'], 5)\n    cs.add(AndConjunction(less_cond, greater_cond))\n\n    print(cs)\n    ```\n\n    Args:\n        *args: conditions, which will be combined with an *AndConjunction*\n    \"\"\"\n    if len(args) &lt; 2:\n        raise ValueError(\"AndConjunction must at least have two Conditions.\")\n    super().__init__(*args)\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.BinaryOpCondition","title":"BinaryOpCondition","text":"<pre><code>BinaryOpCondition(\n    child: Hyperparameter,\n    parent: Hyperparameter,\n    value: Any,\n    *,\n    check_condition_legality: bool = True\n)\n</code></pre> <p>               Bases: <code>Condition</code></p> <p>This is a base class for conditions that are based on a binary operations.</p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def __init__(\n    self,\n    child: Hyperparameter,\n    parent: Hyperparameter,\n    value: Any,  # HACK: Typing here is to allow in conditional\n    *,\n    check_condition_legality: bool = True,\n) -&gt; None:\n    super().__init__(child, parent, value)\n\n    if self._REQUIRES_ORDERABLE_PARENT and not parent.ORDERABLE:\n        _clsname = self.__class__.__name__\n        raise ValueError(\n            f\"The parent hyperparameter must be orderable to use \"\n            f\"{_clsname}, however {self.parent} is not.\",\n        )\n    if check_condition_legality and not parent.legal_value(value):\n        raise ValueError(\n            f\"Hyperparameter '{child.name}' is \"\n            f\"conditional on the illegal value '{value}' of \"\n            f\"its parent hyperparameter '{parent.name}'\",\n        )\n\n    self.vector_value = f64(self.parent.to_vector(value))\n\n    # HACK: For now, the only kind of hyperparameter that can **not** be ordered\n    # as a value type but can be ordered as a vector type is an\n    # OrdinalHyperparameter. This is an explicit hack for that, but if the\n    # needs arise, we can make this more generic\n    from ConfigSpace.hyperparameters.ordinal import OrdinalHyperparameter\n\n    self.need_compare_as_vector = isinstance(self.parent, OrdinalHyperparameter)\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.BinaryOpCondition.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, int]\n) -&gt; None\n</code></pre> <p>Sets the index of the hyperparameter for the vectorized form.</p> <p>This is sort of a second-stage init that is called when a condition is added to the search space.</p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, int]) -&gt; None:\n    \"\"\"Sets the index of the hyperparameter for the vectorized form.\n\n    This is sort of a second-stage init that is called when a condition is\n    added to the search space.\n    \"\"\"\n    self.child_vector_id = np.intp(hyperparameter_to_idx[self.child.name])\n    self.parent_vector_id = np.intp(hyperparameter_to_idx[self.parent.name])\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.Condition","title":"Condition","text":"<pre><code>Condition(\n    child: Hyperparameter,\n    parent: Hyperparameter,\n    value: Any,\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def __init__(\n    self,\n    child: Hyperparameter,\n    parent: Hyperparameter,\n    value: Any,\n) -&gt; None:\n    if child == parent:\n        raise ValueError(\n            \"The child and parent hyperparameter must be different \"\n            \"hyperparameters.\",\n        )\n    self.child = child\n    self.parent = parent\n\n    self.child_vector_id: np.intp | None = None\n    self.parent_vector_id: np.intp | None = None\n\n    self.value = value\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.Condition.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, int]\n) -&gt; None\n</code></pre> <p>Sets the index of the hyperparameter for the vectorized form.</p> <p>This is sort of a second-stage init that is called when a condition is added to the search space.</p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, int]) -&gt; None:\n    \"\"\"Sets the index of the hyperparameter for the vectorized form.\n\n    This is sort of a second-stage init that is called when a condition is\n    added to the search space.\n    \"\"\"\n    self.child_vector_id = np.intp(hyperparameter_to_idx[self.child.name])\n    self.parent_vector_id = np.intp(hyperparameter_to_idx[self.parent.name])\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.EqualsCondition","title":"EqualsCondition","text":"<pre><code>EqualsCondition(\n    child: Hyperparameter,\n    parent: Hyperparameter,\n    value: Any,\n    *,\n    check_condition_legality: bool = True\n)\n</code></pre> <p>               Bases: <code>BinaryOpCondition</code></p> <p>Hyperparameter <code>child</code> is conditional on the <code>parent</code> hyperparameter being equal to <code>value</code>.</p> <p>Make b an active hyperparameter if a has the value 1</p> <pre><code>from ConfigSpace import ConfigurationSpace, EqualsCondition\ncs = ConfigurationSpace({ \"a\": [1, 2, 3], \"b\": (1.0, 8.0)})\ncond = EqualsCondition(cs['b'], cs['a'], 1)\ncs.add(cond)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: Categorical, Choices: {1, 2, 3}, Default: 1\n    b, Type: UniformFloat, Range: [1.0, 8.0], Default: 4.5\n  Conditions:\n    b | a == 1\n</code></pre> PARAMETER DESCRIPTION <code>child</code> <p>This hyperparameter will be sampled in the configspace if the equal condition is satisfied</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>parent</code> <p>The hyperparameter, which has to satisfy the equal condition</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>value</code> <p>Value, which the parent is compared to</p> <p> TYPE: <code>Any</code> </p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def __init__(\n    self,\n    child: Hyperparameter,\n    parent: Hyperparameter,\n    value: Any,  # HACK: Typing here is to allow in conditional\n    *,\n    check_condition_legality: bool = True,\n) -&gt; None:\n    super().__init__(child, parent, value)\n\n    if self._REQUIRES_ORDERABLE_PARENT and not parent.ORDERABLE:\n        _clsname = self.__class__.__name__\n        raise ValueError(\n            f\"The parent hyperparameter must be orderable to use \"\n            f\"{_clsname}, however {self.parent} is not.\",\n        )\n    if check_condition_legality and not parent.legal_value(value):\n        raise ValueError(\n            f\"Hyperparameter '{child.name}' is \"\n            f\"conditional on the illegal value '{value}' of \"\n            f\"its parent hyperparameter '{parent.name}'\",\n        )\n\n    self.vector_value = f64(self.parent.to_vector(value))\n\n    # HACK: For now, the only kind of hyperparameter that can **not** be ordered\n    # as a value type but can be ordered as a vector type is an\n    # OrdinalHyperparameter. This is an explicit hack for that, but if the\n    # needs arise, we can make this more generic\n    from ConfigSpace.hyperparameters.ordinal import OrdinalHyperparameter\n\n    self.need_compare_as_vector = isinstance(self.parent, OrdinalHyperparameter)\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.EqualsCondition.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, int]\n) -&gt; None\n</code></pre> <p>Sets the index of the hyperparameter for the vectorized form.</p> <p>This is sort of a second-stage init that is called when a condition is added to the search space.</p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, int]) -&gt; None:\n    \"\"\"Sets the index of the hyperparameter for the vectorized form.\n\n    This is sort of a second-stage init that is called when a condition is\n    added to the search space.\n    \"\"\"\n    self.child_vector_id = np.intp(hyperparameter_to_idx[self.child.name])\n    self.parent_vector_id = np.intp(hyperparameter_to_idx[self.parent.name])\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.GreaterThanCondition","title":"GreaterThanCondition","text":"<pre><code>GreaterThanCondition(\n    child: Hyperparameter,\n    parent: Hyperparameter,\n    value: Any,\n    *,\n    check_condition_legality: bool = True\n)\n</code></pre> <p>               Bases: <code>BinaryOpCondition</code></p> <p>Hyperparameter <code>child</code> is conditional on the <code>parent</code> hyperparameter being greater than <code>value</code>.</p> <p>Make b an active hyperparameter if a is greater than 5</p> <p>from ConfigSpace import ConfigurationSpace, GreaterThanCondition</p> <p>cs = ConfigurationSpace({ \"a\": (0, 10), \"b\": (1.0, 8.0) }) cond = GreaterThanCondition(cs['b'], cs['a'], 5) cs.add(cond) print(cs) ```</p> <p>Args:     child:         This hyperparameter will be sampled in the configspace,         if the GreaterThanCondition is satisfied     parent: The hyperparameter, which has to satisfy the GreaterThanCondition     value: Value, which the parent is compared to</p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def __init__(\n    self,\n    child: Hyperparameter,\n    parent: Hyperparameter,\n    value: Any,  # HACK: Typing here is to allow in conditional\n    *,\n    check_condition_legality: bool = True,\n) -&gt; None:\n    super().__init__(child, parent, value)\n\n    if self._REQUIRES_ORDERABLE_PARENT and not parent.ORDERABLE:\n        _clsname = self.__class__.__name__\n        raise ValueError(\n            f\"The parent hyperparameter must be orderable to use \"\n            f\"{_clsname}, however {self.parent} is not.\",\n        )\n    if check_condition_legality and not parent.legal_value(value):\n        raise ValueError(\n            f\"Hyperparameter '{child.name}' is \"\n            f\"conditional on the illegal value '{value}' of \"\n            f\"its parent hyperparameter '{parent.name}'\",\n        )\n\n    self.vector_value = f64(self.parent.to_vector(value))\n\n    # HACK: For now, the only kind of hyperparameter that can **not** be ordered\n    # as a value type but can be ordered as a vector type is an\n    # OrdinalHyperparameter. This is an explicit hack for that, but if the\n    # needs arise, we can make this more generic\n    from ConfigSpace.hyperparameters.ordinal import OrdinalHyperparameter\n\n    self.need_compare_as_vector = isinstance(self.parent, OrdinalHyperparameter)\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.GreaterThanCondition.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, int]\n) -&gt; None\n</code></pre> <p>Sets the index of the hyperparameter for the vectorized form.</p> <p>This is sort of a second-stage init that is called when a condition is added to the search space.</p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, int]) -&gt; None:\n    \"\"\"Sets the index of the hyperparameter for the vectorized form.\n\n    This is sort of a second-stage init that is called when a condition is\n    added to the search space.\n    \"\"\"\n    self.child_vector_id = np.intp(hyperparameter_to_idx[self.child.name])\n    self.parent_vector_id = np.intp(hyperparameter_to_idx[self.parent.name])\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.InCondition","title":"InCondition","text":"<pre><code>InCondition(\n    child: Hyperparameter,\n    parent: Hyperparameter,\n    values: list[Any],\n)\n</code></pre> <p>               Bases: <code>Condition</code></p> <p>Hyperparameter <code>child</code> is conditional on the <code>parent</code> hyperparameter being in a set of <code>values</code>.</p> <p>make b an active hyperparameter if a is in the set [1, 2, 3, 4]</p> <pre><code>from ConfigSpace import ConfigurationSpace, InCondition\ncs = ConfigurationSpace({ \"a\": (0, 10), \"b\": (1.0, 8.0) })\ncond = InCondition(cs['b'], cs['a'], [1, 2, 3, 4])\ncs.add(cond)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: UniformInteger, Range: [0, 10], Default: 5\n    b, Type: UniformFloat, Range: [1.0, 8.0], Default: 4.5\n  Conditions:\n    b | a in {1, 2, 3, 4}\n</code></pre> PARAMETER DESCRIPTION <code>child</code> <p>This hyperparameter will be sampled in the configspace, if the InCondition is satisfied</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>parent</code> <p>The hyperparameter, which has to satisfy the InCondition</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>values</code> <p>Collection of values, which the parent is compared to</p> <p> TYPE: <code>list[Any]</code> </p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def __init__(\n    self,\n    child: Hyperparameter,\n    parent: Hyperparameter,\n    values: list[Any],\n) -&gt; None:\n    super().__init__(child, parent, values)\n    for value in values:\n        if not parent.legal_value(value):\n            raise ValueError(\n                f\"Hyperparameter '{child.name}' is \"\n                f\"conditional on the illegal value '{value}' of \"\n                f\"its parent hyperparameter '{parent.name}'\",\n            )\n\n    self.values = values\n    self.vector_values = [self.parent.to_vector(value) for value in self.values]\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.InCondition.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, int]\n) -&gt; None\n</code></pre> <p>Sets the index of the hyperparameter for the vectorized form.</p> <p>This is sort of a second-stage init that is called when a condition is added to the search space.</p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, int]) -&gt; None:\n    \"\"\"Sets the index of the hyperparameter for the vectorized form.\n\n    This is sort of a second-stage init that is called when a condition is\n    added to the search space.\n    \"\"\"\n    self.child_vector_id = np.intp(hyperparameter_to_idx[self.child.name])\n    self.parent_vector_id = np.intp(hyperparameter_to_idx[self.parent.name])\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.LessThanCondition","title":"LessThanCondition","text":"<pre><code>LessThanCondition(\n    child: Hyperparameter,\n    parent: Hyperparameter,\n    value: Any,\n    *,\n    check_condition_legality: bool = True\n)\n</code></pre> <p>               Bases: <code>BinaryOpCondition</code></p> <p>Hyperparameter <code>child</code> is conditional on the <code>parent</code> hyperparameter being less than <code>value</code>.</p> <p>Make b an active hyperparameter if a is less than 5</p> <pre><code>from ConfigSpace import ConfigurationSpace, LessThanCondition\n\ncs = ConfigurationSpace({ \"a\": (0, 10), \"b\": (1.0, 8.0) })\ncond = LessThanCondition(cs['b'], cs['a'], 5)\ncs.add(cond)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: UniformInteger, Range: [0, 10], Default: 5\n    b, Type: UniformFloat, Range: [1.0, 8.0], Default: 4.5\n  Conditions:\n    b | a &lt; 5\n</code></pre> PARAMETER DESCRIPTION <code>child</code> <p>This hyperparameter will be sampled in the configspace, if the LessThanCondition is satisfied</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>parent</code> <p>The hyperparameter, which has to satisfy the LessThanCondition</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>value</code> <p>Value, which the parent is compared to</p> <p> TYPE: <code>Any</code> </p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def __init__(\n    self,\n    child: Hyperparameter,\n    parent: Hyperparameter,\n    value: Any,  # HACK: Typing here is to allow in conditional\n    *,\n    check_condition_legality: bool = True,\n) -&gt; None:\n    super().__init__(child, parent, value)\n\n    if self._REQUIRES_ORDERABLE_PARENT and not parent.ORDERABLE:\n        _clsname = self.__class__.__name__\n        raise ValueError(\n            f\"The parent hyperparameter must be orderable to use \"\n            f\"{_clsname}, however {self.parent} is not.\",\n        )\n    if check_condition_legality and not parent.legal_value(value):\n        raise ValueError(\n            f\"Hyperparameter '{child.name}' is \"\n            f\"conditional on the illegal value '{value}' of \"\n            f\"its parent hyperparameter '{parent.name}'\",\n        )\n\n    self.vector_value = f64(self.parent.to_vector(value))\n\n    # HACK: For now, the only kind of hyperparameter that can **not** be ordered\n    # as a value type but can be ordered as a vector type is an\n    # OrdinalHyperparameter. This is an explicit hack for that, but if the\n    # needs arise, we can make this more generic\n    from ConfigSpace.hyperparameters.ordinal import OrdinalHyperparameter\n\n    self.need_compare_as_vector = isinstance(self.parent, OrdinalHyperparameter)\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.LessThanCondition.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, int]\n) -&gt; None\n</code></pre> <p>Sets the index of the hyperparameter for the vectorized form.</p> <p>This is sort of a second-stage init that is called when a condition is added to the search space.</p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, int]) -&gt; None:\n    \"\"\"Sets the index of the hyperparameter for the vectorized form.\n\n    This is sort of a second-stage init that is called when a condition is\n    added to the search space.\n    \"\"\"\n    self.child_vector_id = np.intp(hyperparameter_to_idx[self.child.name])\n    self.parent_vector_id = np.intp(hyperparameter_to_idx[self.parent.name])\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.NotEqualsCondition","title":"NotEqualsCondition","text":"<pre><code>NotEqualsCondition(\n    child: Hyperparameter,\n    parent: Hyperparameter,\n    value: Any,\n    *,\n    check_condition_legality: bool = True\n)\n</code></pre> <p>               Bases: <code>BinaryOpCondition</code></p> <p>Hyperparameter <code>child</code> is conditional on the <code>parent</code> hyperparameter being not equal to <code>value</code>.</p> <p>Make b an active hyperparameter if a has not the value 1</p> <pre><code>from ConfigSpace import ConfigurationSpace, NotEqualsCondition\n\ncs = ConfigurationSpace({ \"a\": [1, 2, 3], \"b\": (1.0, 8.0) })\ncond = NotEqualsCondition(cs['b'], cs['a'], 1)\ncs.add(cond)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: Categorical, Choices: {1, 2, 3}, Default: 1\n    b, Type: UniformFloat, Range: [1.0, 8.0], Default: 4.5\n  Conditions:\n    b | a != 1\n</code></pre> PARAMETER DESCRIPTION <code>child</code> <p>This hyperparameter will be sampled in the configspace if the not-equals condition is satisfied</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>parent</code> <p>The hyperparameter, which has to satisfy the not equal condition</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>value</code> <p>Value, which the parent is compared to</p> <p> TYPE: <code>Any</code> </p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def __init__(\n    self,\n    child: Hyperparameter,\n    parent: Hyperparameter,\n    value: Any,  # HACK: Typing here is to allow in conditional\n    *,\n    check_condition_legality: bool = True,\n) -&gt; None:\n    super().__init__(child, parent, value)\n\n    if self._REQUIRES_ORDERABLE_PARENT and not parent.ORDERABLE:\n        _clsname = self.__class__.__name__\n        raise ValueError(\n            f\"The parent hyperparameter must be orderable to use \"\n            f\"{_clsname}, however {self.parent} is not.\",\n        )\n    if check_condition_legality and not parent.legal_value(value):\n        raise ValueError(\n            f\"Hyperparameter '{child.name}' is \"\n            f\"conditional on the illegal value '{value}' of \"\n            f\"its parent hyperparameter '{parent.name}'\",\n        )\n\n    self.vector_value = f64(self.parent.to_vector(value))\n\n    # HACK: For now, the only kind of hyperparameter that can **not** be ordered\n    # as a value type but can be ordered as a vector type is an\n    # OrdinalHyperparameter. This is an explicit hack for that, but if the\n    # needs arise, we can make this more generic\n    from ConfigSpace.hyperparameters.ordinal import OrdinalHyperparameter\n\n    self.need_compare_as_vector = isinstance(self.parent, OrdinalHyperparameter)\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.NotEqualsCondition.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, int]\n) -&gt; None\n</code></pre> <p>Sets the index of the hyperparameter for the vectorized form.</p> <p>This is sort of a second-stage init that is called when a condition is added to the search space.</p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, int]) -&gt; None:\n    \"\"\"Sets the index of the hyperparameter for the vectorized form.\n\n    This is sort of a second-stage init that is called when a condition is\n    added to the search space.\n    \"\"\"\n    self.child_vector_id = np.intp(hyperparameter_to_idx[self.child.name])\n    self.parent_vector_id = np.intp(hyperparameter_to_idx[self.parent.name])\n</code></pre>"},{"location":"api/ConfigSpace/conditions/#ConfigSpace.conditions.OrConjunction","title":"OrConjunction","text":"<pre><code>OrConjunction(*args: ConditionLike)\n</code></pre> <p>               Bases: <code>Conjunction</code></p> <p>Similar to the AndConjunction, constraints can be combined by using the OrConjunction.</p> <pre><code>from ConfigSpace import (\n    ConfigurationSpace,\n    LessThanCondition,\n    GreaterThanCondition,\n    OrConjunction\n)\n\ncs = ConfigurationSpace({ \"a\": (5, 15), \"b\": (0, 10), \"c\": (0.0, 1.0) })\n\nless_cond = LessThanCondition(cs['c'], cs['a'], 10)\ngreater_cond = GreaterThanCondition(cs['c'], cs['b'], 5)\ncs.add(OrConjunction(less_cond, greater_cond))\n\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: UniformInteger, Range: [5, 15], Default: 10\n    b, Type: UniformInteger, Range: [0, 10], Default: 5\n    c, Type: UniformFloat, Range: [0.0, 1.0], Default: 0.5\n  Conditions:\n    (c | a &lt; 10 || c | b &gt; 5)\n</code></pre> PARAMETER DESCRIPTION <code>*args</code> <p>conditions, which will be combined with an OrConjunction.</p> <p> TYPE: <code>ConditionLike</code> DEFAULT: <code>()</code> </p> Source code in <code>src/ConfigSpace/conditions.py</code> <pre><code>def __init__(self, *args: ConditionLike) -&gt; None:\n    \"\"\"Initialize the *OrConjunction*.\n\n    Args:\n        *args: conditions, which will be combined with an *OrConjunction*.\n    \"\"\"\n    if len(args) &lt; 2:\n        raise ValueError(\"OrConjunction must at least have two Conditions.\")\n    super().__init__(*args)\n</code></pre>"},{"location":"api/ConfigSpace/configuration/","title":"Configuration","text":""},{"location":"api/ConfigSpace/configuration/#ConfigSpace.configuration","title":"ConfigSpace.configuration","text":""},{"location":"api/ConfigSpace/configuration/#ConfigSpace.configuration.Configuration","title":"Configuration","text":"<pre><code>Configuration(\n    configuration_space: ConfigurationSpace,\n    values: Mapping[str, Any] | None = None,\n    vector: Array[f64] | None = None,\n    allow_inactive_with_values: bool = False,\n    origin: Any | None = None,\n    config_id: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Mapping[str, Any]</code></p> <p>Class for a single configuration.</p> <p>The <code>Configuration</code> object holds for all active hyperparameters a value. While the <code>ConfigurationSpace</code> stores the definitions for the hyperparameters (value ranges, constraints,...), a <code>Configuration</code> object is more an instance of it. Parameters of a <code>Configuration</code> object can be accessed and modified similar to python dictionaries (c.f. user guilde).</p> PARAMETER DESCRIPTION <code>configuration_space</code> <p>The space this configuration is in</p> <p> TYPE: <code>ConfigurationSpace</code> </p> <code>values</code> <p>A dictionary with pairs (hyperparameter_name, value), where value is a legal value of the hyperparameter in the above configuration_space</p> <p> TYPE: <code>Mapping[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>vector</code> <p>A numpy array for efficient representation. Either values or vector has to be given</p> <p> TYPE: <code>Array[f64] | None</code> DEFAULT: <code>None</code> </p> <code>allow_inactive_with_values</code> <p>Whether an Exception will be raised if a value for an inactive hyperparameter is given. Default is to raise an Exception. Default to False</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>origin</code> <p>Store information about the origin of this configuration. Defaults to None.</p> <p> TYPE: <code>Any | None</code> DEFAULT: <code>None</code> </p> <code>config_id</code> <p>Integer configuration ID which can be used by a program using the ConfigSpace package.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/ConfigSpace/configuration.py</code> <pre><code>def __init__(\n    self,\n    configuration_space: ConfigurationSpace,\n    values: Mapping[str, Any] | None = None,\n    vector: Array[f64] | None = None,\n    allow_inactive_with_values: bool = False,\n    origin: Any | None = None,\n    config_id: int | None = None,\n) -&gt; None:\n    \"\"\"Create a new configuration.\n\n    Args:\n        configuration_space:\n            The space this configuration is in\n        values:\n            A dictionary with pairs (hyperparameter_name, value), where value is\n            a legal value of the hyperparameter in the above configuration_space\n        vector:\n            A numpy array for efficient representation. Either values or vector\n            has to be given\n        allow_inactive_with_values:\n            Whether an Exception will be raised if a value for an inactive\n            hyperparameter is given. Default is to raise an Exception.\n            Default to False\n        origin:\n            Store information about the origin of this configuration.\n            Defaults to None.\n        config_id:\n            Integer configuration ID which can be used by a program using the\n            ConfigSpace package.\n    \"\"\"\n    if (\n        values is not None\n        and vector is not None\n        or values is None\n        and vector is None\n    ):\n        raise ValueError(\n            \"Specify Configuration as either a dictionary or a vector.\",\n        )\n\n    self.config_space = configuration_space\n    self.allow_inactive_with_values = allow_inactive_with_values\n    self.origin = origin\n    self.config_id = config_id\n\n    # This is cached. When it's None, it means it needs to be relaoaded\n    # which is primarly handled in __getitem__.\n    self._values: dict[str, Any] | None = None\n\n    # Will be set below\n    self._vector: np.ndarray\n\n    if values is not None:\n        unknown_keys = values.keys() - self.config_space.keys()\n        if any(unknown_keys):\n            raise ValueError(f\"Unknown hyperparameter(s) {unknown_keys}\")\n\n        # Using cs._hyperparameters to iterate makes sure that the hyperparameters\n        # in the configuration are sorted in the same way as they are sorted in\n        # the configuration space\n        self._values = {}\n        self._vector = np.empty(shape=len(configuration_space), dtype=f64)\n\n        for key, hp in configuration_space.items():\n            i = configuration_space.index_of[key]\n\n            value = values.get(key, NotSet)\n            if value is NotSet:\n                self._vector[i] = np.nan\n                continue\n\n            if not hp.legal_value(value):\n                raise IllegalValueError(hp, value)\n\n            # Truncate the float to be of constant lengt\n            if isinstance(hp, FloatHyperparameter):\n                value = float(np.round(value, ROUND_PLACES))  # type: ignore\n\n            self._values[key] = value\n            self._vector[i] = hp.to_vector(value)  # type: ignore\n\n        self.check_valid_configuration()\n\n    elif vector is not None:\n        if not isinstance(vector, np.ndarray):\n            _vector = np.asarray(vector, dtype=f64)\n        else:\n            _vector = vector\n\n        if _vector.ndim != 1:\n            # If we have a 2d array with shape (n, 1), flatten it\n            if len(_vector.shape) == 2 and _vector.shape[1] == 1:\n                _vector = _vector.flatten()\n            else:\n                raise ValueError(\n                    \"Only 1d arrays can be converted to a Configuration, \"\n                    f\"you passed an array of shape {_vector.shape}\",\n                )\n\n        n_hyperparameters = len(self.config_space)\n        if len(_vector) != n_hyperparameters:\n            raise ValueError(\n                f\"Expected array of length {n_hyperparameters}, got {len(_vector)}\",\n            )\n\n        self._vector = _vector\n</code></pre>"},{"location":"api/ConfigSpace/configuration/#ConfigSpace.configuration.Configuration.config_id","title":"config_id  <code>instance-attribute</code>","text":"<pre><code>config_id: int | None = config_id\n</code></pre> <p>The configuration id of the Configuration, sometimes used by tools working with ConfigSpace.</p>"},{"location":"api/ConfigSpace/configuration/#ConfigSpace.configuration.Configuration.config_space","title":"config_space  <code>instance-attribute</code>","text":"<pre><code>config_space: ConfigurationSpace = configuration_space\n</code></pre> <p>The space this configuration is in.</p>"},{"location":"api/ConfigSpace/configuration/#ConfigSpace.configuration.Configuration.origin","title":"origin  <code>instance-attribute</code>","text":"<pre><code>origin: Any | None = origin\n</code></pre> <p>The origin of the Configuration, sometimes used by tools working with ConfigSpace.</p>"},{"location":"api/ConfigSpace/configuration/#ConfigSpace.configuration.Configuration.check_valid_configuration","title":"check_valid_configuration","text":"<pre><code>check_valid_configuration() -&gt; None\n</code></pre> <p>Check if the object is a valid.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If configuration is not valid.</p> Source code in <code>src/ConfigSpace/configuration.py</code> <pre><code>def check_valid_configuration(self) -&gt; None:\n    \"\"\"Check if the object is a valid.\n\n    Raises:\n        ValueError: If configuration is not valid.\n    \"\"\"\n    from ConfigSpace.util import check_configuration\n\n    check_configuration(\n        self.config_space,\n        self._vector,\n        allow_inactive_with_values=self.allow_inactive_with_values,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/configuration/#ConfigSpace.configuration.Configuration.get_array","title":"get_array","text":"<pre><code>get_array() -&gt; Array[f64]\n</code></pre> <p>The internal vector representation of this config.</p> <p>All continuous values are scaled between zero and one.</p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The vector representation of the configuration</p> Source code in <code>src/ConfigSpace/configuration.py</code> <pre><code>def get_array(self) -&gt; Array[f64]:\n    \"\"\"The internal vector representation of this config.\n\n    All continuous values are scaled between zero and one.\n\n    Returns:\n        The vector representation of the configuration\n    \"\"\"\n    return self._vector\n</code></pre>"},{"location":"api/ConfigSpace/configuration/#ConfigSpace.configuration.Configuration.get_dictionary","title":"get_dictionary","text":"<pre><code>get_dictionary() -&gt; dict[str, Any]\n</code></pre> <p>A representation of the <code>Configuration</code> in dictionary form.</p> <p>Deprecated</p> <p>Please use <code>dict(config)</code> instead of <code>config.get_dictionary()</code> or use it as a dictionary directly if needed.,</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Configuration as dictionary</p> Source code in <code>src/ConfigSpace/configuration.py</code> <pre><code>@deprecated(\n    \"Please use `dict(config)` instead of `config.get_dictionary()`\"\n    \" or use it as a dictionary directly if needed.\",\n)\ndef get_dictionary(self) -&gt; dict[str, Any]:\n    \"\"\"A representation of the `Configuration` in dictionary form.\n\n    !!! warning \"Deprecated\"\n        Please use `dict(config)` instead of `config.get_dictionary()`\n        or use it as a dictionary directly if needed.,\n\n    Returns:\n        Configuration as dictionary\n    \"\"\"\n    return dict(self)\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/","title":"Configuration space","text":""},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space","title":"ConfigSpace.configuration_space","text":""},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace","title":"ConfigurationSpace","text":"<pre><code>ConfigurationSpace(\n    name: str | Mapping[str, Any] | None = None,\n    seed: int | None = None,\n    meta: dict | None = None,\n    *,\n    space: (\n        None\n        | Mapping[\n            str,\n            tuple[int, int]\n            | tuple[float, float]\n            | Sequence[Any]\n            | int\n            | float\n            | str\n            | Hyperparameter,\n        ]\n    ) = None\n)\n</code></pre> <p>               Bases: <code>Mapping[str, Hyperparameter]</code></p> <p>A collection-like object containing a set of hyperparameter definitions and conditions.</p> <p>A configuration space organizes all hyperparameters and its conditions as well as its forbidden clauses. Configurations can be sampled from this configuration space. As underlying data structure, the configuration space uses a tree-based approach to represent the conditions and restrictions between hyperparameters.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the configuration space. If a dict is passed, this is considered the same as the <code>space=</code> arg.</p> <p> TYPE: <code>str | Mapping[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>Random seed</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>meta</code> <p>Field for holding meta data provided by the user. Not used by the configuration space.</p> <p> TYPE: <code>dict | None</code> DEFAULT: <code>None</code> </p> <code>space</code> <p>A simple configuration space to use:</p> <pre><code>from ConfigSpace import ConfigurationSpace\n\nConfigurationSpace(\n    name=\"myspace\",\n    space={\n        \"uniform_integer\": (1, 10),\n        \"uniform_float\": (1.0, 10.0),\n        \"categorical\": [\"a\", \"b\", \"c\"],\n        \"constant\": 1337,\n    }\n)\n</code></pre> <pre><code>\n</code></pre> <p> TYPE: <code>None | Mapping[str, tuple[int, int] | tuple[float, float] | Sequence[Any] | int | float | str | Hyperparameter]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def __init__(\n    self,\n    name: str | Mapping[str, Any] | None = None,\n    seed: int | None = None,\n    meta: dict | None = None,\n    *,\n    space: None\n    | (\n        Mapping[\n            str,\n            tuple[int, int]\n            | tuple[float, float]\n            | Sequence[Any]\n            | int\n            | float\n            | str\n            | Hyperparameter,\n        ]\n    ) = None,\n) -&gt; None:\n    \"\"\"Initialize a configuration space.\n\n    Args:\n        name:\n            Name of the configuration space. If a dict is passed,\n            this is considered the same as the `space=` arg.\n        seed:\n            Random seed\n        meta:\n            Field for holding meta data provided by the user.\n            Not used by the configuration space.\n        space:\n            A simple configuration space to use:\n\n            ```python exec=\"true\" result=\"python\" source=\"material-block\"\n            from ConfigSpace import ConfigurationSpace\n\n            ConfigurationSpace(\n                name=\"myspace\",\n                space={\n                    \"uniform_integer\": (1, 10),\n                    \"uniform_float\": (1.0, 10.0),\n                    \"categorical\": [\"a\", \"b\", \"c\"],\n                    \"constant\": 1337,\n                }\n            )\n            ```\n\n    \"\"\"\n    # If first arg is a dict, we assume this to be `space`\n    if isinstance(name, Mapping):\n        space = name\n        _name = None\n    else:\n        _name = name\n\n    self.name = _name\n    self.meta = meta\n    self.random = np.random.RandomState(seed)\n    self._dag = DAG()\n    self._len = 0\n\n    if space is not None:\n        hyperparameters = list(_parse_hyperparameters_from_dict(space))\n        self.add(hyperparameters)\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.at","title":"at  <code>property</code>","text":"<pre><code>at: Sequence[str]\n</code></pre> <p>The hyperparameters by their index.</p>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.child_conditions_of","title":"child_conditions_of  <code>property</code>","text":"<pre><code>child_conditions_of: Mapping[str, Sequence[ConditionLike]]\n</code></pre> <p>Conditions of a hyperparameter.</p> RETURNS DESCRIPTION <code>Mapping[str, Sequence[ConditionLike]]</code> <p>Mapping from a parent hyperparameter name to all conditions which check the value of the parent.</p>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.children_of","title":"children_of  <code>property</code>","text":"<pre><code>children_of: Mapping[str, Sequence[Hyperparameter]]\n</code></pre> <p>Children of a hyperparameter.</p> RETURNS DESCRIPTION <code>Mapping[str, Sequence[Hyperparameter]]</code> <p>Mapping from a parent hyperparameter name to all hyperparameters which are activate, depending on the value of the parent.</p>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.conditional_hyperparameters","title":"conditional_hyperparameters  <code>property</code>","text":"<pre><code>conditional_hyperparameters: Sequence[str]\n</code></pre> <p>Names of all conditional hyperparameters.</p> RETURNS DESCRIPTION <code>Sequence[str]</code> <p>Set with all hyperparameter names which are only active under certain conditions</p>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.conditions","title":"conditions  <code>property</code>","text":"<pre><code>conditions: Sequence[ConditionLike]\n</code></pre> <p>All conditions from the configuration space.</p>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.forbidden_clauses","title":"forbidden_clauses  <code>property</code>","text":"<pre><code>forbidden_clauses: Sequence[ForbiddenLike]\n</code></pre> <p>All forbidden clauses from the configuration space.</p>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.index_of","title":"index_of  <code>property</code>","text":"<pre><code>index_of: Mapping[str, int]\n</code></pre> <p>The index of hyperparameters by their name.</p>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.parent_conditions_of","title":"parent_conditions_of  <code>property</code>","text":"<pre><code>parent_conditions_of: Mapping[str, Sequence[ConditionLike]]\n</code></pre> <p>Conditions of a hyperparameter.</p> RETURNS DESCRIPTION <code>Mapping[str, Sequence[ConditionLike]]</code> <p>Mapping from a child hyperparameter name to all conditions which need to be check to activate the child.</p>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.parents_of","title":"parents_of  <code>property</code>","text":"<pre><code>parents_of: Mapping[str, Sequence[Hyperparameter]]\n</code></pre> <p>Parents of a hyperparameter.</p> RETURNS DESCRIPTION <code>Mapping[str, Sequence[Hyperparameter]]</code> <p>Mapping from a child hyperparameter name to all hyperparameters which activate the child, depending on their values.</p>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.unconditional_hyperparameters","title":"unconditional_hyperparameters  <code>property</code>","text":"<pre><code>unconditional_hyperparameters: Sequence[str]\n</code></pre> <p>Names of all unconditional hyperparameters.</p> RETURNS DESCRIPTION <code>Sequence[str]</code> <p>Set of all hyperparameter names which are always active</p>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> <p>Override the default Equals behavior.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Override the default Equals behavior.\"\"\"\n    if isinstance(other, self.__class__):\n        other_dict = other.__dict__\n\n        # _minimum_condition_span has a np.ndarray which doesn't allow ==\n        # to give a direct bool but is based off the others\n        for k, v in self.__dict__.items():\n            if k in (\"random\",):\n                continue\n            if v != other_dict.get(k):\n                return False\n\n        return True\n\n    return NotImplemented\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[str]\n</code></pre> <p>Iterate over the hyperparameter names in the right order.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def __iter__(self) -&gt; Iterator[str]:\n    \"\"\"Iterate over the hyperparameter names in the right order.\"\"\"\n    return iter(self._dag.nodes.keys())\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of hyperparameters.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of hyperparameters.\"\"\"\n    return self._len\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.add","title":"add","text":"<pre><code>add(\n    *args: Hyperparameter\n    | ConditionLike\n    | ForbiddenLike\n    | Iterable[\n        Hyperparameter | ConditionLike | ForbiddenLike\n    ],\n) -&gt; None\n</code></pre> <p>Add a hyperparameter, condition or forbidden clause to the configuration space.</p> <p>Note</p> <p>If adding multiple hyperparameters, conditions or forbidden clauses, it is better to add them all at once with one call to <code>add()</code>, as we rebuilt a cache after each call to <code>add()</code>.</p> PARAMETER DESCRIPTION <code>args</code> <p>Hyperparameter, condition or forbidden clause to add</p> <p> TYPE: <code>Hyperparameter | ConditionLike | ForbiddenLike | Iterable[Hyperparameter | ConditionLike | ForbiddenLike]</code> DEFAULT: <code>()</code> </p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def add(\n    self,\n    *args: (\n        Hyperparameter\n        | ConditionLike\n        | ForbiddenLike\n        | Iterable[Hyperparameter | ConditionLike | ForbiddenLike]\n    ),\n) -&gt; None:\n    \"\"\"Add a hyperparameter, condition or forbidden clause to the configuration\n    space.\n\n    !!! note\n\n        If adding multiple hyperparameters, conditions or forbidden clauses, it\n        is better to add them all at once with one call to `add()`, as we\n        rebuilt a cache after each call to `add()`.\n\n    Args:\n        args:\n            Hyperparameter, condition or forbidden clause to add\n    \"\"\"\n    # First turn everything into one large iterable\n    hps = []\n    conditions = []\n    forbiddens = []\n\n    def _put_to_list(\n        arg: Hyperparameter\n        | ConditionLike\n        | ForbiddenLike\n        | Iterable[Hyperparameter | ConditionLike | ForbiddenLike],\n    ) -&gt; None:\n        if isinstance(arg, Hyperparameter):\n            hps.append(arg)\n        elif isinstance(arg, (Condition, Conjunction)):\n            conditions.append(arg)\n        elif isinstance(\n            arg,\n            (ForbiddenClause, ForbiddenConjunction, ForbiddenRelation),\n        ):\n            forbiddens.append(arg)\n        elif isinstance(arg, Iterable):\n            for a in arg:\n                _put_to_list(a)\n        else:\n            raise TypeError(f\"Unknown type {type(arg)}\")\n\n    for a in args:\n        _put_to_list(a)\n\n    with self._dag.update():\n        for hp in hps:\n            self._dag.add(hp)\n\n        for condition in conditions:\n            self._dag.add_condition(condition)\n\n        for forbidden in forbiddens:\n            self._dag.add_forbidden(forbidden)\n\n    self._len = len(self._dag.nodes)\n    self._check_default_configuration()\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.add_condition","title":"add_condition","text":"<pre><code>add_condition(condition: ConditionLike) -&gt; ConditionLike\n</code></pre> <p>Deprecated. Please use <code>space.add()</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.add(condition)`\")\ndef add_condition(self, condition: ConditionLike) -&gt; ConditionLike:\n    \"\"\"Deprecated. Please use [`space.add()`][ConfigSpace.configuration_space.ConfigurationSpace.add].\"\"\"  # noqa: E501\n    self.add(condition)\n    return condition\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.add_conditions","title":"add_conditions","text":"<pre><code>add_conditions(\n    conditions: list[ConditionLike],\n) -&gt; list[ConditionLike]\n</code></pre> <p>Deprecated. Please use <code>space.add()</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.add(conditions)`\")\ndef add_conditions(self, conditions: list[ConditionLike]) -&gt; list[ConditionLike]:\n    \"\"\"Deprecated. Please use [`space.add()`][ConfigSpace.configuration_space.ConfigurationSpace.add].\"\"\"  # noqa: E501\n    self.add(conditions)\n    return conditions\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.add_configuration_space","title":"add_configuration_space","text":"<pre><code>add_configuration_space(\n    prefix: str,\n    configuration_space: ConfigurationSpace,\n    delimiter: str = \":\",\n    parent_hyperparameter: dict | None = None,\n) -&gt; ConfigurationSpace\n</code></pre> <p>Combine two configuration space by adding one the other configuration space. The contents of the configuration space, which should be added, are renamed to <code>prefix</code> + <code>delimiter</code> + old_name.</p> PARAMETER DESCRIPTION <code>prefix</code> <p>The prefix for the renamed hyperparameter | conditions | forbidden clauses</p> <p> TYPE: <code>str</code> </p> <code>configuration_space</code> <p>The configuration space which should be added</p> <p> TYPE: <code>ConfigurationSpace</code> </p> <code>delimiter</code> <p>Defaults to ':'</p> <p> TYPE: <code>str</code> DEFAULT: <code>':'</code> </p> <code>parent_hyperparameter</code> <p>Adds for each new hyperparameter the condition, that <code>parent_hyperparameter</code> is active. Must be a dictionary with two keys \"parent\" and \"value\", meaning that the added configuration space is active when <code>parent</code> is equal to <code>value</code></p> <p> TYPE: <code>dict | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ConfigurationSpace</code> <p>The configuration space, which was added.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def add_configuration_space(\n    self,\n    prefix: str,\n    configuration_space: ConfigurationSpace,\n    delimiter: str = \":\",\n    parent_hyperparameter: dict | None = None,\n) -&gt; ConfigurationSpace:\n    \"\"\"Combine two configuration space by adding one the other configuration\n    space. The contents of the configuration space, which should be added,\n    are renamed to `prefix` + `delimiter` + old_name.\n\n    Args:\n        prefix:\n            The prefix for the renamed hyperparameter | conditions |\n            forbidden clauses\n        configuration_space:\n            The configuration space which should be added\n        delimiter:\n            Defaults to ':'\n        parent_hyperparameter:\n            Adds for each new hyperparameter the condition, that\n            `parent_hyperparameter` is active. Must be a dictionary with two keys\n            \"parent\" and \"value\", meaning that the added configuration space is\n            active when `parent` is equal to `value`\n\n    Returns:\n        The configuration space, which was added.\n    \"\"\"\n    prefix_delim = f\"{prefix}{delimiter}\"\n\n    def _new_name(_item: Hyperparameter) -&gt; str:\n        if _item.name in (\"\", prefix):\n            return prefix\n\n        if not _item.name.startswith(prefix_delim):\n            return f\"{prefix_delim}{_item.name}\"\n\n        return _item.name\n\n    new_parameters = []\n    for hp in configuration_space.values():\n        new_hp = copy.copy(hp)\n        new_hp.name = _new_name(hp)\n        new_parameters.append(new_hp)\n\n    conditions_to_add = []\n    for condition in configuration_space.conditions:\n        new_condition = copy.copy(condition)\n        cond_dlcs = (\n            new_condition.dlcs\n            if isinstance(new_condition, Conjunction)\n            else [new_condition]\n        )\n        for cond_dlc in cond_dlcs:\n            # Rename children\n            cond_dlc.child.name = _new_name(cond_dlc.child)\n            cond_dlc.parent.name = _new_name(cond_dlc.parent)\n\n        conditions_to_add.append(new_condition)\n\n    forbiddens_to_add = []\n    for forbidden_clause in configuration_space.forbidden_clauses:\n        new_forbidden = copy.copy(forbidden_clause)\n        forb_dlcs = (\n            new_forbidden.dlcs\n            if isinstance(new_forbidden, ForbiddenConjunction)\n            else [new_forbidden]\n        )\n        for forb_dlc in forb_dlcs:\n            if isinstance(forb_dlc, ForbiddenRelation):\n                forb_dlc.left.name = _new_name(forb_dlc.left)\n                forb_dlc.right.name = _new_name(forb_dlc.right)\n            else:\n                forb_dlc.hyperparameter.name = _new_name(forb_dlc.hyperparameter)\n        forbiddens_to_add.append(new_forbidden)\n\n    self.add(new_parameters, conditions_to_add, forbiddens_to_add)\n\n    # Finally, we may need to add conditions to the added search space\n    conditions_to_add = []\n    if parent_hyperparameter is not None:\n        parent = parent_hyperparameter[\"parent\"]\n        value = parent_hyperparameter[\"value\"]\n\n        # Only add a condition if the parameter is a top-level parameter of the new\n        # configuration space (this will be some kind of tree structure).\n        root_params = [\n            hp for hp in new_parameters if len(self.parents_of[hp.name]) == 0\n        ]\n        for param in root_params:\n            conditions_to_add.append(EqualsCondition(param, parent, value))\n\n    if len(conditions_to_add) &gt; 0:\n        self.add(conditions_to_add)\n\n    return configuration_space\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.add_forbidden_clause","title":"add_forbidden_clause","text":"<pre><code>add_forbidden_clause(\n    clause: ForbiddenLike,\n) -&gt; ForbiddenLike\n</code></pre> <p>Deprecated. Please use <code>space.add()</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.add(clause)`\")\ndef add_forbidden_clause(self, clause: ForbiddenLike) -&gt; ForbiddenLike:\n    \"\"\"Deprecated. Please use [`space.add()`][ConfigSpace.configuration_space.ConfigurationSpace.add].\"\"\"  # noqa: E501\n    self.add(clause)\n    return clause\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.add_forbidden_clauses","title":"add_forbidden_clauses","text":"<pre><code>add_forbidden_clauses(\n    clauses: list[ForbiddenLike],\n) -&gt; list[ForbiddenLike]\n</code></pre> <p>Deprecated. Please use <code>space.add()</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.add(clause)`\")\ndef add_forbidden_clauses(\n    self,\n    clauses: list[ForbiddenLike],\n) -&gt; list[ForbiddenLike]:\n    \"\"\"Deprecated. Please use [`space.add()`][ConfigSpace.configuration_space.ConfigurationSpace.add].\"\"\"  # noqa: E501\n    self.add(clauses)\n    return clauses\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.add_hyperparameter","title":"add_hyperparameter","text":"<pre><code>add_hyperparameter(\n    hyperparameter: Hyperparameter,\n) -&gt; Hyperparameter\n</code></pre> <p>Deprecated. Please use <code>space.add()</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.add(hyperparameter)`\")\ndef add_hyperparameter(self, hyperparameter: Hyperparameter) -&gt; Hyperparameter:\n    \"\"\"Deprecated. Please use [`space.add()`][ConfigSpace.configuration_space.ConfigurationSpace.add].\"\"\"  # noqa: E501\n    self.add(hyperparameter)\n    return hyperparameter\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.add_hyperparameters","title":"add_hyperparameters","text":"<pre><code>add_hyperparameters(\n    hyperparameters: Iterable[Hyperparameter],\n) -&gt; list[Hyperparameter]\n</code></pre> <p>Deprecated. Please use <code>space.add()</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.add(hyperparameters)`\")\ndef add_hyperparameters(\n    self,\n    hyperparameters: Iterable[Hyperparameter],\n) -&gt; list[Hyperparameter]:\n    \"\"\"Deprecated. Please use [`space.add()`][ConfigSpace.configuration_space.ConfigurationSpace.add].\"\"\"  # noqa: E501\n    warnings.warn(\n        \"Please use public function `add()` instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    hyperparameters = list(hyperparameters)\n    self.add(hyperparameters)\n    return hyperparameters\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.check_configuration","title":"check_configuration","text":"<pre><code>check_configuration(configuration: Configuration) -&gt; None\n</code></pre> <p>Check if a configuration is legal. Raises an error if not.</p> PARAMETER DESCRIPTION <code>configuration</code> <p>Configuration to check</p> <p> TYPE: <code>Configuration</code> </p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please call `configuration.check_valid_configuration()` instead.\")\ndef check_configuration(self, configuration: Configuration) -&gt; None:\n    \"\"\"Check if a configuration is legal. Raises an error if not.\n\n    Args:\n        configuration: Configuration to check\n    \"\"\"\n    ConfigSpace.util.check_configuration(self, configuration.get_array())\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.check_configuration_vector_representation","title":"check_configuration_vector_representation","text":"<pre><code>check_configuration_vector_representation(\n    vector: Array[f64],\n) -&gt; None\n</code></pre> <p>Raise error if configuration in vector representation is not legal.</p> PARAMETER DESCRIPTION <code>vector</code> <p>configuration in vector representation</p> <p> TYPE: <code>Array[f64]</code> </p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def check_configuration_vector_representation(self, vector: Array[f64]) -&gt; None:\n    \"\"\"Raise error if configuration in vector representation is not legal.\n\n    Args:\n        vector: configuration in vector representation\n    \"\"\"\n    ConfigSpace.util.check_configuration(self, vector)\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.estimate_size","title":"estimate_size","text":"<pre><code>estimate_size() -&gt; float | int\n</code></pre> <p>Estimate the number of unique configurations.</p> <p>This is <code>np.inf</code> in case if there is a single hyperparameter of size <code>np.inf</code> (i.e. a <code>UniformFloatParameter</code>), otherwise it is the product of the size of all hyperparameters. The function correctly guesses the number of unique configurations if there are no condition and forbidden statements in the configuration spaces. Otherwise, this is an upper bound. Use <code>generate_grid()</code> to generate all valid configurations if required.</p> RETURNS DESCRIPTION <code>float | int</code> <p>The estimated number of unique configurations</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def estimate_size(self) -&gt; float | int:\n    \"\"\"Estimate the number of unique configurations.\n\n    This is `np.inf` in case if there is a single hyperparameter of size `np.inf`\n    (i.e. a `UniformFloatParameter`),\n    otherwise it is the product of the size of all hyperparameters. The function\n    correctly guesses the number of unique configurations if there are no condition\n    and forbidden statements in the configuration spaces. Otherwise, this is an\n    upper bound. Use [`generate_grid()`][ConfigSpace.util.generate_grid] to generate\n    all valid configurations if required.\n\n    Returns:\n        The estimated number of unique configurations\n    \"\"\"\n    sizes = [hp.size for hp in self.values()]\n\n    if len(sizes) == 0:\n        return 0.0\n\n    acc: int | float = 1\n    for size in sizes:\n        acc *= size\n\n    return acc\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(\n    path: str | Path | IO[str],\n    *,\n    decoders: (\n        Mapping[\n            Literal[\n                \"hyperparameters\",\n                \"conditions\",\n                \"forbiddens\",\n            ],\n            Mapping[str, _Decoder],\n        ]\n        | None\n    ) = None,\n    **kwargs: Any\n) -&gt; ConfigurationSpace\n</code></pre> <p>Decode a serialized configuration space from a json file.</p> <p>Please see the serialization reference for more</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the serialized configuration space</p> <p> TYPE: <code>str | Path | IO[str]</code> </p> <code>decoders</code> <p>A mapping from one of the kinds of things that can be decoded to a dictionary of type names to a decoder that will be used. Anything not specified will fall back to the default decoders.</p> <p> TYPE: <code>Mapping[Literal['hyperparameters', 'conditions', 'forbiddens'], Mapping[str, _Decoder]] | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Any additional arguments to pass to <code>json.load</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ConfigurationSpace</code> <p>The decoded configuration space</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@classmethod\ndef from_json(\n    cls,\n    path: str | Path | IO[str],\n    *,\n    decoders: (\n        Mapping[\n            Literal[\"hyperparameters\", \"conditions\", \"forbiddens\"],\n            Mapping[str, _Decoder],\n        ]\n        | None\n    ) = None,\n    **kwargs: Any,\n) -&gt; ConfigurationSpace:\n    \"\"\"Decode a serialized configuration space from a json file.\n\n    Please see the [serialization reference](../../reference/serialization.md) for\n    more\n\n    Args:\n        path: Path to the serialized configuration space\n        decoders:\n            A mapping from one of the kinds of things that can be decoded\n            to a dictionary of type names to a decoder that will be used.\n            Anything not specified will fall back to the default decoders.\n        **kwargs: Any additional arguments to pass to `json.load`\n\n    Returns:\n        The decoded configuration space\n    \"\"\"\n    if isinstance(path, (str, Path)):\n        p = Path(path)\n        with p.open(\"r\") as f:\n            d = json.load(f, **kwargs)\n    else:\n        d = json.load(path, **kwargs)\n\n    return cls.from_serialized_dict(d, decoders=decoders)\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.from_serialized_dict","title":"from_serialized_dict  <code>classmethod</code>","text":"<pre><code>from_serialized_dict(\n    d: dict[str, Any],\n    decoders: (\n        Mapping[\n            Literal[\n                \"hyperparameters\",\n                \"conditions\",\n                \"forbiddens\",\n            ],\n            Mapping[str, _Decoder],\n        ]\n        | None\n    ) = None,\n) -&gt; ConfigurationSpace\n</code></pre> <p>Decode a serialized configuration space from a dictionary.</p> <p>Please see the serialization reference for more</p> PARAMETER DESCRIPTION <code>d</code> <p>The serialized configuration space</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>decoders</code> <p>A mapping from one of the kinds of things that can be decoded to a dictionary of type names to a decoder that will be used. Anything not specified will fall back to the default decoders.</p> <p> TYPE: <code>Mapping[Literal['hyperparameters', 'conditions', 'forbiddens'], Mapping[str, _Decoder]] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ConfigurationSpace</code> <p>The decoded configuration space</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@classmethod\ndef from_serialized_dict(\n    cls,\n    d: dict[str, Any],\n    decoders: (\n        Mapping[\n            Literal[\"hyperparameters\", \"conditions\", \"forbiddens\"],\n            Mapping[str, _Decoder],\n        ]\n        | None\n    ) = None,\n) -&gt; ConfigurationSpace:\n    \"\"\"Decode a serialized configuration space from a dictionary.\n\n    Please see the [serialization reference](../../reference/serialization.md) for more\n\n    Args:\n        d: The serialized configuration space\n        decoders:\n            A mapping from one of the kinds of things that can be decoded\n            to a dictionary of type names to a decoder that will be used.\n            Anything not specified will fall back to the default decoders.\n\n    Returns:\n        The decoded configuration space\n    \"\"\"\n    user_decoders = decoders or {}\n\n    def get_decoder(_decoders: Mapping[str, _Decoder]) -&gt; _Decoder:\n        def dec(\n            item: dict[str, Any],\n            cs: ConfigurationSpace,\n            _dec: _Decoder,\n        ) -&gt; Any:\n            _type = item.pop(\"type\", None)\n            if _type is None:\n                raise KeyError(\n                    f\"Expected a key 'type' in item {item} but did not find it.\"\n                    \" Did you include this in the encoding?\",\n                )\n\n            decoder = _decoders.get(_type)\n            if decoder is None:\n                raise ValueError(\n                    f\"No found decoder for '{_type}'.  Registered decoders are\"\n                    f\" {_decoders.keys()}. Please include a custom `decoder=` if\"\n                    \" you want to decode this type.\",\n                )\n\n            return decoder(item, cs, _dec)\n\n        return dec\n\n    space = ConfigurationSpace(name=d.get(\"name\"))\n    _hyperparameters = d.get(\"hyperparameters\", [])\n    _conditions = d.get(\"conditions\", [])\n    _forbiddens = d.get(\"forbiddens\", [])\n\n    hp_decoder = get_decoder(\n        {**HYPERPARAMETER_DECODERS, **user_decoders.get(\"hyperparameters\", {})},\n    )\n    cond_decoder = get_decoder(\n        {**CONDITION_DECODERS, **user_decoders.get(\"conditions\", {})},\n    )\n    forb_decoder = get_decoder(\n        {**FORBIDDEN_DECODERS, **user_decoders.get(\"forbiddens\", {})},\n    )\n\n    # Important that we add hyperparameters first as decoding conditions\n    # and forbiddens rely on having access to the hyperparameters\n    hyperparameters = [hp_decoder(hp, space, hp_decoder) for hp in _hyperparameters]\n    space.add(hyperparameters)\n\n    conditions = [cond_decoder(c, space, cond_decoder) for c in _conditions]\n    forbidden = [forb_decoder(f, space, forb_decoder) for f in _forbiddens]\n    space.add(conditions, forbidden)\n    return space\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.from_yaml","title":"from_yaml  <code>classmethod</code>","text":"<pre><code>from_yaml(\n    path: str | Path | IO[str],\n    *,\n    decoders: (\n        Mapping[\n            Literal[\n                \"hyperparameters\",\n                \"conditions\",\n                \"forbiddens\",\n            ],\n            Mapping[str, _Decoder],\n        ]\n        | None\n    ) = None,\n    **kwargs: Any\n) -&gt; ConfigurationSpace\n</code></pre> <p>Decode a serialized configuration space from a yaml file.</p> <p>Please see the serialization reference for more</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the serialized configuration space</p> <p> TYPE: <code>str | Path | IO[str]</code> </p> <code>decoders</code> <p>A mapping from one of the kinds of things that can be decoded to a dictionary of type names to a decoder that will be used. Anything not specified will fall back to the default decoders.</p> <p> TYPE: <code>Mapping[Literal['hyperparameters', 'conditions', 'forbiddens'], Mapping[str, _Decoder]] | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Any additional arguments to pass to <code>yaml.safe_load</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ConfigurationSpace</code> <p>The decoded configuration space</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@classmethod\ndef from_yaml(\n    cls,\n    path: str | Path | IO[str],\n    *,\n    decoders: (\n        Mapping[\n            Literal[\"hyperparameters\", \"conditions\", \"forbiddens\"],\n            Mapping[str, _Decoder],\n        ]\n        | None\n    ) = None,\n    **kwargs: Any,\n) -&gt; ConfigurationSpace:\n    \"\"\"Decode a serialized configuration space from a yaml file.\n\n    Please see the [serialization reference](../../reference/serialization.md) for more\n\n    Args:\n        path: Path to the serialized configuration space\n        decoders:\n            A mapping from one of the kinds of things that can be decoded\n            to a dictionary of type names to a decoder that will be used.\n            Anything not specified will fall back to the default decoders.\n        **kwargs: Any additional arguments to pass to `yaml.safe_load`\n\n    Returns:\n        The decoded configuration space\n    \"\"\"\n    import yaml\n\n    if isinstance(path, (str, Path)):\n        p = Path(path)\n        with p.open(\"r\") as f:\n            d = yaml.safe_load(f, **kwargs)\n    else:\n        d = yaml.safe_load(path, **kwargs)\n\n    return cls.from_serialized_dict(d, decoders=decoders)\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.generate_all_continuous_from_bounds","title":"generate_all_continuous_from_bounds","text":"<pre><code>generate_all_continuous_from_bounds(\n    bounds: Iterable[tuple[float, float]]\n) -&gt; None\n</code></pre> <p>Fill a ConfigurationSpace from a list of bounded numericals.</p> <p>The generated hyperparameters are added to the configuration space.</p> PARAMETER DESCRIPTION <code>bounds</code> <p>List containing lists with two elements: lower and upper bound</p> <p> TYPE: <code>Iterable[tuple[float, float]]</code> </p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def generate_all_continuous_from_bounds(\n    self,\n    bounds: Iterable[tuple[float, float]],\n) -&gt; None:\n    \"\"\"Fill a ConfigurationSpace from a list of bounded numericals.\n\n    The generated hyperparameters are added to the configuration space.\n\n    Args:\n        bounds: List containing lists with two elements: lower and upper bound\n    \"\"\"\n    self.add(\n        UniformFloatHyperparameter(name=f\"x{i}\", lower=lower, upper=upper)\n        for i, (lower, upper) in enumerate(bounds)\n    )\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.get_active_hyperparameters","title":"get_active_hyperparameters","text":"<pre><code>get_active_hyperparameters(\n    configuration: Configuration | Array[f64],\n) -&gt; set[str]\n</code></pre> <p>Set of active hyperparameter names for a given configuration.</p> PARAMETER DESCRIPTION <code>configuration</code> <p>Configuration to get active hyperparameters of</p> <p> TYPE: <code>Configuration | Array[f64]</code> </p> RETURNS DESCRIPTION <code>set[str]</code> <p>The set of names of all active hyperparameter</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def get_active_hyperparameters(\n    self,\n    configuration: Configuration | Array[f64],\n) -&gt; set[str]:\n    \"\"\"Set of active hyperparameter names for a given configuration.\n\n    Args:\n        configuration: Configuration to get active hyperparameters of\n\n    Returns:\n        The set of names of all active hyperparameter\n    \"\"\"\n    vector = (\n        configuration.get_array()\n        if isinstance(configuration, Configuration)\n        else configuration\n    )\n    active_hyperparameters = set()\n    for hp_name in self.keys():\n        conditions = self.parent_conditions_of[hp_name]\n\n        active = True\n        for condition in conditions:\n            parent_vector_idx: np.intp | Array[np.intp]\n            if isinstance(condition, Conjunction):\n                assert condition.parent_vector_ids is not None\n                parent_vector_idx = condition.parent_vector_ids\n            else:\n                parent_vector_idx = np.asarray(condition.parent_vector_id)\n\n            if np.isnan(vector[parent_vector_idx]).any():\n                active = False\n                break\n\n            if not condition.satisfied_by_vector(vector):\n                active = False\n                break\n\n        if active:\n            active_hyperparameters.add(hp_name)\n\n    return active_hyperparameters\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.get_all_conditional_hyperparameters","title":"get_all_conditional_hyperparameters","text":"<pre><code>get_all_conditional_hyperparameters() -&gt; Sequence[str]\n</code></pre> <p>Deprecated. Please use <code>space.conditional_hyperparameters</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.conditional_hyperparameters`\")\ndef get_all_conditional_hyperparameters(self) -&gt; Sequence[str]:\n    \"\"\"Deprecated. Please use [`space.conditional_hyperparameters`][ConfigSpace.configuration_space.ConfigurationSpace.conditional_hyperparameters].\"\"\"  # noqa: E501\n    return self.conditional_hyperparameters\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.get_all_unconditional_hyperparameters","title":"get_all_unconditional_hyperparameters","text":"<pre><code>get_all_unconditional_hyperparameters() -&gt; Sequence[str]\n</code></pre> <p>Deprecated. Please use <code>space.unconditional_hyperparameters</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.uncoditional_hyperparameters`\")\ndef get_all_unconditional_hyperparameters(self) -&gt; Sequence[str]:\n    \"\"\"Deprecated. Please use [`space.unconditional_hyperparameters`][ConfigSpace.configuration_space.ConfigurationSpace.unconditional_hyperparameters].\"\"\"  # noqa: E501\n    return self.unconditional_hyperparameters\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.get_child_conditions_of","title":"get_child_conditions_of","text":"<pre><code>get_child_conditions_of(\n    name: str | Hyperparameter,\n) -&gt; Sequence[ConditionLike]\n</code></pre> <p>Deprecated. Please use <code>space.child_conditions_of[name]</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.child_conditions_of[hyperparameter.name]`\")\ndef get_child_conditions_of(\n    self,\n    name: str | Hyperparameter,\n) -&gt; Sequence[ConditionLike]:\n    \"\"\"Deprecated. Please use [`space.child_conditions_of[name]`][ConfigSpace.configuration_space.ConfigurationSpace.child_conditions_of].\"\"\"  # noqa: E501\n    _name = name.name if isinstance(name, Hyperparameter) else name\n    return self.child_conditions_of[_name]\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.get_children_of","title":"get_children_of","text":"<pre><code>get_children_of(\n    name: str | Hyperparameter,\n) -&gt; Sequence[Hyperparameter]\n</code></pre> <p>Deprecated. Please use <code>space.children_of[name]</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.children_of[hyperparameter.name]`\")\ndef get_children_of(self, name: str | Hyperparameter) -&gt; Sequence[Hyperparameter]:\n    \"\"\"Deprecated. Please use [`space.children_of[name]`][ConfigSpace.configuration_space.ConfigurationSpace.children_of].\"\"\"  # noqa: E501\n    _name = name.name if isinstance(name, Hyperparameter) else name\n    return self.children_of[_name]\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.get_conditions","title":"get_conditions","text":"<pre><code>get_conditions() -&gt; Sequence[ConditionLike]\n</code></pre> <p>Deprecated. Please use <code>space.conditions</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.conditions`\")\ndef get_conditions(self) -&gt; Sequence[ConditionLike]:\n    \"\"\"Deprecated. Please use [`space.conditions`][ConfigSpace.configuration_space.ConfigurationSpace.conditions].\"\"\"  # noqa: E501\n    return self.conditions\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.get_default_configuration","title":"get_default_configuration","text":"<pre><code>get_default_configuration() -&gt; Configuration\n</code></pre> <p>Configuration containing hyperparameters with default values.</p> RETURNS DESCRIPTION <code>Configuration</code> <p>Configuration with the set default values</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def get_default_configuration(self) -&gt; Configuration:\n    \"\"\"Configuration containing hyperparameters with default values.\n\n    Returns:\n        Configuration with the set default values\n    \"\"\"\n    return self._check_default_configuration()\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.get_forbiddens","title":"get_forbiddens","text":"<pre><code>get_forbiddens() -&gt; Sequence[ForbiddenLike]\n</code></pre> <p>Deprecated. Please use <code>space.forbidden_clauses</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.forbidden_clauses`\")\ndef get_forbiddens(self) -&gt; Sequence[ForbiddenLike]:\n    \"\"\"Deprecated. Please use [`space.forbidden_clauses`][ConfigSpace.configuration_space.ConfigurationSpace.forbidden_clauses].\"\"\"  # noqa: E501\n    return self.forbidden_clauses\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.get_hyperparameter_by_idx","title":"get_hyperparameter_by_idx","text":"<pre><code>get_hyperparameter_by_idx(idx: int) -&gt; str\n</code></pre> <p>Deprecated. Please use <code>space.at[idx]</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.at[idx]`\")\ndef get_hyperparameter_by_idx(self, idx: int) -&gt; str:\n    \"\"\"Deprecated. Please use [`space.at[idx]`][ConfigSpace.configuration_space.ConfigurationSpace.at].\"\"\"  # noqa: E501\n    return self.at[idx]\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.get_idx_by_hyperparameter_name","title":"get_idx_by_hyperparameter_name","text":"<pre><code>get_idx_by_hyperparameter_name(name: str) -&gt; int\n</code></pre> <p>Deprecated. Please use <code>space.index_of[name]</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.index_of[name]`\")\ndef get_idx_by_hyperparameter_name(self, name: str) -&gt; int:\n    \"\"\"Deprecated. Please use [`space.index_of[name]`][ConfigSpace.configuration_space.ConfigurationSpace.index_of].\"\"\"  # noqa: E501\n    return self.index_of[name]\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.get_parent_conditions_of","title":"get_parent_conditions_of","text":"<pre><code>get_parent_conditions_of(\n    name: str | Hyperparameter,\n) -&gt; Sequence[Condition | Conjunction]\n</code></pre> <p>Deprecated. Please use <code>space.parent_conditions_of[name]</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.parent_conditions_of[hyperparameter.name]`\")\ndef get_parent_conditions_of(\n    self,\n    name: str | Hyperparameter,\n) -&gt; Sequence[Condition | Conjunction]:\n    \"\"\"Deprecated. Please use [`space.parent_conditions_of[name]`][ConfigSpace.configuration_space.ConfigurationSpace.parent_conditions_of].\"\"\"  # noqa: E501\n    _name = name.name if isinstance(name, Hyperparameter) else name\n    return self.parent_conditions_of[_name]\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.get_parents_of","title":"get_parents_of","text":"<pre><code>get_parents_of(\n    name: str | Hyperparameter,\n) -&gt; Sequence[Hyperparameter]\n</code></pre> <p>Deprecated. Please use <code>space.parents_of[name]</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@deprecated(\"Please use `space.parents_of[hyperparameter.name]`\")\ndef get_parents_of(self, name: str | Hyperparameter) -&gt; Sequence[Hyperparameter]:\n    \"\"\"Deprecated. Please use [`space.parents_of[name]`][ConfigSpace.configuration_space.ConfigurationSpace.parents_of].\"\"\"  # noqa: E501\n    _name = name.name if isinstance(name, Hyperparameter) else name\n    return self.parents_of[_name]\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.items","title":"items","text":"<pre><code>items() -&gt; ItemsView[str, Hyperparameter]\n</code></pre> <p>Return an items view of the hyperparameters, same as <code>dict.items()</code>.</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def items(self) -&gt; ItemsView[str, Hyperparameter]:\n    \"\"\"Return an items view of the hyperparameters, same as `dict.items()`.\"\"\"  # noqa: D402\n    return {name: node.hp for name, node in self._dag.nodes.items()}.items()\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.remove_hyperparameter_priors","title":"remove_hyperparameter_priors","text":"<pre><code>remove_hyperparameter_priors() -&gt; ConfigurationSpace\n</code></pre> <p>Produces a new ConfigurationSpace where all priors on parameters are removed.</p> <p>Non-uniform hyperpararmeters are replaced with uniform ones, and CategoricalHyperparameters with weights have their weights removed.</p> RETURNS DESCRIPTION <code>ConfigurationSpace</code> <p>The resulting configuration space, without priors on the hyperparameters</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def remove_hyperparameter_priors(self) -&gt; ConfigurationSpace:\n    \"\"\"Produces a new ConfigurationSpace where all priors on parameters are removed.\n\n    Non-uniform hyperpararmeters are replaced with uniform ones, and\n    CategoricalHyperparameters with weights have their weights removed.\n\n    Returns:\n        The resulting configuration space, without priors on the hyperparameters\n    \"\"\"\n    uniform_config_space = ConfigurationSpace(\n        {\n            name: p.to_uniform()\n            if isinstance(p, (NumericalHyperparameter, CategoricalHyperparameter))\n            else copy.copy(p)\n            for name, p in self.items()\n        },\n    )\n    uniform_config_space.add(\n        self.substitute_hyperparameters_in_conditions(\n            self.conditions,\n            uniform_config_space,\n        ),\n        self.substitute_hyperparameters_in_forbiddens(\n            self.forbidden_clauses,\n            uniform_config_space,\n        ),\n    )\n    return uniform_config_space\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.sample_configuration","title":"sample_configuration","text":"<pre><code>sample_configuration(\n    size: int | None = None,\n) -&gt; Configuration | list[Configuration]\n</code></pre> <p>Sample <code>size</code> configurations from the configuration space object.</p> PARAMETER DESCRIPTION <code>size</code> <p>Number of configurations to sample. Default (<code>None</code>) is to sample a single configuration.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Configuration | list[Configuration]</code> <p>A single configuration if <code>size</code> 1 else a list of Configurations</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def sample_configuration(\n    self,\n    size: int | None = None,\n) -&gt; Configuration | list[Configuration]:\n    \"\"\"Sample `size` configurations from the configuration space object.\n\n    Args:\n        size: Number of configurations to sample. Default (`None`) is to\n            sample a single configuration.\n\n    Returns:\n        A single configuration if `size` 1 else a list of Configurations\n    \"\"\"\n    if len(self) == 0:\n        if size is None:\n            return Configuration(self, vector=np.array([]))\n        return [Configuration(self, vector=np.array([])) for _ in range(size)]\n\n    if size is not None and not isinstance(size, int):\n        raise TypeError(f\"Expected int or None, got {type(size)}\")\n\n    if size == 1:\n        warnings.warn(\n            \"Please leave at default or explicitly set `size=None`.\"\n            \" In the future, specifying a size will always return a list, even if\"\n            \" 1\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    # Maintain old behaviour by setting this\n    if size is None:\n        size = 1\n\n    if size &lt; 1:\n        return []\n\n    accepted_configurations: list[Configuration] = []\n    num_hyperparameters = len(self)\n\n    # Main sampling loop\n    MULT = (\n        len(self.forbidden_clauses) + len(self.conditional_hyperparameters)\n    ) / num_hyperparameters\n    sample_size = size\n    while len(accepted_configurations) &lt; size:\n        sample_size = max(int(MULT**2 * sample_size), 5)\n\n        # Sample a vector for each hp, filling out columns\n        # OPTIM: We put the hyperparameters as rows as we perform row-wise\n        # operations and the matrices themselves are row-oriented in memory,\n        # helping to improve cache locality.\n        config_matrix: Array[f64] = np.empty(\n            (num_hyperparameters, sample_size),\n            dtype=f64,\n        )\n        for i, hp in enumerate(self.values()):\n            config_matrix[i] = hp._vector_dist.sample_vector(\n                n=sample_size,\n                seed=self.random,\n            )\n\n        # Apply unconditional forbiddens across the columns (hps)\n        # We treat this as an OR, i.e. if any of the forbidden clauses are\n        # forbidden, the entire configuration (row) is forbidden\n        uncond_forbidden: Mask = np.zeros(sample_size, dtype=np.bool_)\n        for clause in self._dag.unconditional_forbiddens:\n            uncond_forbidden |= clause.is_forbidden_vector_array(config_matrix)\n\n        valid_configs = config_matrix[:, ~uncond_forbidden]\n\n        for cnode in self._dag.minimum_conditions:\n            condition = cnode.condition\n            satisfied = condition.satisfied_by_vector_array(valid_configs)\n            valid_configs[np.ix_(cnode.children_indices, ~satisfied)] = np.nan\n\n        # Now we apply the forbiddens that depend on conditionals\n        cond_forbidden: Mask = np.zeros(valid_configs.shape[1], dtype=np.bool_)\n        for clause in self._dag.conditional_forbiddens:\n            cond_forbidden |= clause.is_forbidden_vector_array(valid_configs)\n\n        valid_configs = valid_configs[:, ~cond_forbidden]\n\n        # And now we have a matrix of valid configurations\n        accepted_configurations.extend(\n            [Configuration(self, vector=vec) for vec in valid_configs.T],\n        )\n        sample_size = size - len(accepted_configurations)\n\n    if size &lt;= 1:\n        return accepted_configurations[0]\n\n    return accepted_configurations[:size]\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.seed","title":"seed","text":"<pre><code>seed(seed: int) -&gt; None\n</code></pre> <p>Set the random seed to a number.</p> PARAMETER DESCRIPTION <code>seed</code> <p>The random seed</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def seed(self, seed: int) -&gt; None:\n    \"\"\"Set the random seed to a number.\n\n    Args:\n        seed: The random seed\n    \"\"\"\n    self.random = np.random.RandomState(seed)\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.substitute_hyperparameters_in_conditions","title":"substitute_hyperparameters_in_conditions  <code>staticmethod</code>","text":"<pre><code>substitute_hyperparameters_in_conditions(\n    conditions: Iterable[ConditionLike],\n    new_configspace: ConfigurationSpace,\n) -&gt; list[ConditionLike]\n</code></pre> <p>Takes a set of conditions and generates a new set of conditions with the same structure, where each hyperparameter is replaced with its namesake in new_configspace. As such, the set of conditions remain unchanged, but the included hyperparameters are changed to match those types that exist in new_configspace.</p> PARAMETER DESCRIPTION <code>conditions</code> <p>The conditions to adjust</p> <p> TYPE: <code>Iterable[ConditionLike]</code> </p> <code>new_configspace</code> <p>A ConfigurationSpace containing hyperparameters with the same names as those in the conditions.</p> <p> TYPE: <code>ConfigurationSpace</code> </p> RETURNS DESCRIPTION <code>list[ConditionLike]</code> <p>The list of conditions, adjusted to fit the new ConfigurationSpace</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@staticmethod\ndef substitute_hyperparameters_in_conditions(\n    conditions: Iterable[ConditionLike],\n    new_configspace: ConfigurationSpace,\n) -&gt; list[ConditionLike]:\n    \"\"\"Takes a set of conditions and generates a new set of conditions with the same\n    structure, where each hyperparameter is replaced with its namesake in\n    new_configspace. As such, the set of conditions remain unchanged, but the\n    included hyperparameters are changed to match those types that exist in\n    new_configspace.\n\n    Args:\n        conditions: The conditions to adjust\n        new_configspace:\n            A ConfigurationSpace containing hyperparameters with the same names\n            as those in the conditions.\n\n    Returns:\n        The list of conditions, adjusted to fit the new ConfigurationSpace\n    \"\"\"\n    new_conditions: list[ConditionLike] = []\n    for condition in conditions:\n        if isinstance(condition, Conjunction):\n            conjunction_type = type(condition)\n            children = condition.dlcs\n            substituted_children = (\n                ConfigurationSpace.substitute_hyperparameters_in_conditions(\n                    children,\n                    new_configspace,\n                )\n            )\n            substituted_conjunction = conjunction_type(*substituted_children)\n            new_conditions.append(substituted_conjunction)\n\n        elif isinstance(condition, Condition):\n            new_conditions.append(\n                condition.__class__(\n                    **{\n                        **condition.to_dict(),\n                        \"parent\": new_configspace[condition.parent.name],\n                        \"child\": new_configspace[condition.child.name],\n                    },\n                ),\n            )\n        else:\n            raise TypeError(\n                f\"Did not expect the supplied condition type {type(condition)}.\",\n            )\n\n    return new_conditions\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.substitute_hyperparameters_in_forbiddens","title":"substitute_hyperparameters_in_forbiddens  <code>staticmethod</code>","text":"<pre><code>substitute_hyperparameters_in_forbiddens(\n    forbiddens: Iterable[ForbiddenLike],\n    new_configspace: ConfigurationSpace,\n) -&gt; list[ForbiddenLike]\n</code></pre> <p>Takes a set of forbidden clauses and generates a new set of forbidden clauses with the same structure, where each hyperparameter is replaced with its namesake in new_configspace. As such, the set of forbidden clauses remain unchanged, but the included hyperparameters are changed to match those types that exist in new_configspace.</p> PARAMETER DESCRIPTION <code>forbiddens</code> <p>An iterable of forbiddens</p> <p> TYPE: <code>Iterable[ForbiddenLike]</code> </p> <code>new_configspace</code> <p>ConfigurationSpace A ConfigurationSpace containing hyperparameters with the same names as those in the forbidden clauses.</p> <p> TYPE: <code>ConfigurationSpace</code> </p> RETURNS DESCRIPTION <code>list[ForbiddenLike]</code> <p>The list of forbidden clauses, adjusted to fit the new ConfigurationSpace</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>@staticmethod\ndef substitute_hyperparameters_in_forbiddens(\n    forbiddens: Iterable[ForbiddenLike],\n    new_configspace: ConfigurationSpace,\n) -&gt; list[ForbiddenLike]:\n    \"\"\"Takes a set of forbidden clauses and generates a new set of forbidden clauses\n    with the same structure, where each hyperparameter is replaced with its\n    namesake in new_configspace.\n    As such, the set of forbidden clauses remain unchanged, but the included\n    hyperparameters are changed to match those types that exist in new_configspace.\n\n    Args:\n        forbiddens: An iterable of forbiddens\n        new_configspace: ConfigurationSpace\n            A ConfigurationSpace containing hyperparameters with the same\n            names as those in the forbidden clauses.\n\n    Returns:\n        The list of forbidden clauses, adjusted to fit the new ConfigurationSpace\n    \"\"\"\n    new_forbiddens: list[ForbiddenLike] = []\n    for forbidden in forbiddens:\n        if isinstance(forbidden, ForbiddenConjunction):\n            substituted_children = (\n                ConfigurationSpace.substitute_hyperparameters_in_forbiddens(\n                    forbidden.components,\n                    new_configspace,\n                )\n            )\n            substituted_conjunction = forbidden.__class__(*substituted_children)\n            new_forbiddens.append(substituted_conjunction)\n\n        elif isinstance(forbidden, ForbiddenClause):\n            if isinstance(forbidden, ForbiddenInClause):\n                new_forbiddens.append(\n                    forbidden.__class__(\n                        hyperparameter=new_configspace[\n                            forbidden.hyperparameter.name\n                        ],\n                        values=forbidden.values,\n                    ),\n                )\n            elif isinstance(forbidden, ForbiddenEqualsClause):\n                new_forbiddens.append(\n                    forbidden.__class__(\n                        hyperparameter=new_configspace[\n                            forbidden.hyperparameter.name\n                        ],\n                        value=forbidden.value,\n                    ),\n                )\n            else:\n                raise TypeError(\n                    f\"Forbidden of type '{type(forbidden)}' not recognized.\",\n                )\n\n        elif isinstance(forbidden, ForbiddenRelation):\n            new_forbiddens.append(\n                forbidden.__class__(\n                    left=new_configspace[forbidden.left.name],\n                    right=new_configspace[forbidden.right.name],\n                ),\n            )\n        else:\n            raise TypeError(f\"Did not expect type {type(forbidden)}.\")\n\n    return new_forbiddens\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.to_json","title":"to_json","text":"<pre><code>to_json(\n    path: str | Path | IO[str],\n    *,\n    encoders: (\n        Mapping[type, tuple[str, _Encoder]] | None\n    ) = None,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Serialize the configuration space to a JSON file.</p> <p>Please see the serialization reference for more</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the file or a file object to write to</p> <p> TYPE: <code>str | Path | IO[str]</code> </p> <code>encoders</code> <p>A mapping from types to a tuple of the type name and an encoder function. If not provided, the default encoders will be used.</p> <p> TYPE: <code>Mapping[type, tuple[str, _Encoder]] | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional arguments to pass to <code>json.dump</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def to_json(\n    self,\n    path: str | Path | IO[str],\n    *,\n    encoders: Mapping[type, tuple[str, _Encoder]] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Serialize the configuration space to a JSON file.\n\n    Please see the [serialization reference](../../reference/serialization.md) for more\n\n    Args:\n        path: Path to the file or a file object to write to\n        encoders:\n            A mapping from types to a tuple of the type name and an encoder\n            function. If not provided, the default encoders will be used.\n        **kwargs: Additional arguments to pass to `json.dump`\n    \"\"\"\n    serialized = self.to_serialized_dict(encoders=encoders)\n    if isinstance(path, (str, Path)):\n        with open(path, \"w\") as f:\n            json.dump(serialized, f, **kwargs)\n    else:\n        json.dump(serialized, path, **kwargs)\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.to_serialized_dict","title":"to_serialized_dict","text":"<pre><code>to_serialized_dict(\n    encoders: (\n        Mapping[type, tuple[str, _Encoder]] | None\n    ) = None\n) -&gt; dict[str, Any]\n</code></pre> <p>Serialize the configuration space to a dictionary.</p> <p>Please see the serialization reference for more</p> PARAMETER DESCRIPTION <code>encoders</code> <p>A mapping from types to a tuple of the type name and an encoder function. If not provided, the default encoders will be used.</p> <p> TYPE: <code>Mapping[type, tuple[str, _Encoder]] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>A dictionary containing the serialized configuration space</p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def to_serialized_dict(\n    self,\n    encoders: Mapping[type, tuple[str, _Encoder]] | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Serialize the configuration space to a dictionary.\n\n    Please see the [serialization reference](../../reference/serialization.md) for more\n\n    Args:\n        encoders:\n            A mapping from types to a tuple of the type name and an encoder\n            function. If not provided, the default encoders will be used.\n\n    Returns:\n        A dictionary containing the serialized configuration space\n    \"\"\"\n    # NOTE: Used to be called JSON format\n    SERIALIZATION_FORMAT_VERSION = 0.4\n\n    _encoders = {\n        **HYPERPARAMETER_ENCODERS,\n        **CONDITION_ENCODERS,\n        **FORBIDDEN_ENCODERS,\n        **(encoders or {}),\n    }\n\n    def enc(item: Any, _enc: _Encoder) -&gt; dict[str, Any]:\n        key = type(item)\n        res = _encoders.get(key)\n        if res is None:\n            raise ValueError(\n                f\"No found encoder for '{key}'. Registered encoders are\"\n                f\" {_encoders.keys()}. Please include a custom `encoders=` if\"\n                \" you want to encode this type.\",\n            )\n\n        type_name, encoder = res\n        encoding = encoder(item, _enc)\n        return {\"type\": type_name, **encoding}\n\n    from ConfigSpace import __version__\n\n    return {\n        \"name\": self.name,\n        \"hyperparameters\": [enc(hp, enc) for hp in self.values()],\n        \"conditions\": [enc(c, enc) for c in self.conditions],\n        \"forbiddens\": [enc(f, enc) for f in self.forbidden_clauses],\n        \"python_module_version\": __version__,\n        \"format_version\": SERIALIZATION_FORMAT_VERSION,\n    }\n</code></pre>"},{"location":"api/ConfigSpace/configuration_space/#ConfigSpace.configuration_space.ConfigurationSpace.to_yaml","title":"to_yaml","text":"<pre><code>to_yaml(\n    path: str | Path | IO[str],\n    *,\n    encoders: (\n        Mapping[type, tuple[str, _Encoder]] | None\n    ) = None,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Serialize the configuration space to a JSON file.</p> <p>Please see the serialization reference for more</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the file or a file object to write to</p> <p> TYPE: <code>str | Path | IO[str]</code> </p> <code>encoders</code> <p>A mapping from types to a tuple of the type name and an encoder function. If not provided, the default encoders will be used.</p> <p> TYPE: <code>Mapping[type, tuple[str, _Encoder]] | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional arguments to pass to <code>json.dump</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/ConfigSpace/configuration_space.py</code> <pre><code>def to_yaml(\n    self,\n    path: str | Path | IO[str],\n    *,\n    encoders: Mapping[type, tuple[str, _Encoder]] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Serialize the configuration space to a JSON file.\n\n    Please see the [serialization reference](../../reference/serialization.md) for more\n\n    Args:\n        path: Path to the file or a file object to write to\n        encoders:\n            A mapping from types to a tuple of the type name and an encoder\n            function. If not provided, the default encoders will be used.\n        **kwargs: Additional arguments to pass to `json.dump`\n    \"\"\"\n    import yaml\n\n    serialized = self.to_serialized_dict(encoders=encoders)\n    if isinstance(path, (str, Path)):\n        with open(path, \"w\") as f:\n            yaml.dump(serialized, f, **kwargs)\n    else:\n        yaml.dump(serialized, path, **kwargs)\n</code></pre>"},{"location":"api/ConfigSpace/exceptions/","title":"Exceptions","text":""},{"location":"api/ConfigSpace/exceptions/#ConfigSpace.exceptions","title":"ConfigSpace.exceptions","text":""},{"location":"api/ConfigSpace/exceptions/#ConfigSpace.exceptions.ForbiddenValueError","title":"ForbiddenValueError","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a combination of values is forbidden for a Configuration.</p>"},{"location":"api/ConfigSpace/forbidden/","title":"Forbidden","text":""},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden","title":"ConfigSpace.forbidden","text":""},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenLike","title":"ForbiddenLike  <code>module-attribute</code>","text":"<pre><code>ForbiddenLike = Union[\n    ForbiddenClause, ForbiddenConjunction, ForbiddenRelation\n]\n</code></pre> <p>Type alias for forbidden clauses, conjunctions, and relations.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenAndConjunction","title":"ForbiddenAndConjunction","text":"<pre><code>ForbiddenAndConjunction(\n    *args: ForbiddenClause\n    | ForbiddenConjunction\n    | ForbiddenRelation,\n)\n</code></pre> <p>               Bases: <code>ForbiddenConjunction</code></p> <p>A ForbiddenAndConjunction.</p> <p>The ForbiddenAndConjunction combines forbidden-clauses, which allows to build powerful constraints.</p> <pre><code>from ConfigSpace import (\n    ConfigurationSpace,\n    ForbiddenEqualsClause,\n    ForbiddenInClause,\n    ForbiddenAndConjunction,\n)\n\ncs = ConfigurationSpace({\"a\": [1, 2, 3], \"b\": [2, 5, 6]})\nforbidden_clause_a = ForbiddenEqualsClause(cs[\"a\"], 2)\nforbidden_clause_b = ForbiddenInClause(cs[\"b\"], [2])\n\nforbidden_clause = ForbiddenAndConjunction(forbidden_clause_a, forbidden_clause_b)\n\ncs.add(forbidden_clause)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: Categorical, Choices: {1, 2, 3}, Default: 1\n    b, Type: Categorical, Choices: {2, 5, 6}, Default: 2\n  Forbidden Clauses:\n    (Forbidden: a == 2 &amp;&amp; Forbidden: b in {2})\n</code></pre> PARAMETER DESCRIPTION <code>*args</code> <p>forbidden clauses, which should be combined</p> <p> TYPE: <code>ForbiddenClause | ForbiddenConjunction | ForbiddenRelation</code> DEFAULT: <code>()</code> </p> PARAMETER DESCRIPTION <code>*args</code> <p>forbidden clauses, which should be combined</p> <p> TYPE: <code>ForbiddenClause | ForbiddenConjunction | ForbiddenRelation</code> DEFAULT: <code>()</code> </p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def __init__(\n    self,\n    *args: ForbiddenClause | ForbiddenConjunction | ForbiddenRelation,\n) -&gt; None:\n    \"\"\"Initialize a ForbiddenConjunction.\n\n    Args:\n        *args: forbidden clauses, which should be combined\n    \"\"\"\n    # Test the classes\n    acceptable = (ForbiddenClause, ForbiddenConjunction, ForbiddenRelation)\n    for idx, component in enumerate(args):\n        if not isinstance(component, acceptable):\n            raise TypeError(\n                \"Argument #%d is not an instance of %s, \"\n                \"but %s\" % (idx, acceptable, type(component)),\n            )\n\n    self.components = args\n    dlcs: list[ForbiddenClause | ForbiddenRelation] = []\n    for component in self.components:\n        if isinstance(component, ForbiddenConjunction):\n            dlcs.extend(component.dlcs)\n        else:\n            dlcs.append(component)\n\n    self.dlcs: tuple[ForbiddenClause | ForbiddenRelation, ...] = tuple(\n        unique_everseen(dlcs, key=lambda x: id(x)),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenAndConjunction.components","title":"components  <code>instance-attribute</code>","text":"<pre><code>components: tuple[\n    ForbiddenClause\n    | ForbiddenConjunction\n    | ForbiddenRelation,\n    ...,\n]\n</code></pre> <p>Components of the conjunction.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenAndConjunction.dlcs","title":"dlcs  <code>instance-attribute</code>","text":"<pre><code>dlcs: tuple[ForbiddenClause | ForbiddenRelation, ...]\n</code></pre> <p>Descendant literal clauses of the conjunction.</p> <p>These are the base forbidden clauses/relations that are part of conjunctions.</p> <p>Note</p> <p>This will only store a unique set of the descendant clauses, no duplicates.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenAndConjunction.get_descendant_literal_clauses","title":"get_descendant_literal_clauses","text":"<pre><code>get_descendant_literal_clauses() -&gt; (\n    tuple[ForbiddenClause | ForbiddenRelation, ...]\n)\n</code></pre> <p>Get the descendant literal clauses of the conjunction.</p> <p>Deprecated</p> <p>Please use the <code>.dlcs</code> attribute instead.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>@deprecated(\"Use `.dlcs` instead\")\ndef get_descendant_literal_clauses(\n    self,\n) -&gt; tuple[ForbiddenClause | ForbiddenRelation, ...]:\n    \"\"\"Get the descendant literal clauses of the conjunction.\n\n    !!! note \"Deprecated\"\n\n        Please use the `.dlcs` attribute instead.\n    \"\"\"\n    return self.dlcs\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenAndConjunction.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, int]\n) -&gt; None\n</code></pre> <p>Set vector index of hyperparameters in each element of the conjunction.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, int]) -&gt; None:\n    \"\"\"Set vector index of hyperparameters in each element of the conjunction.\"\"\"\n    for component in self.components:\n        component.set_vector_idx(hyperparameter_to_idx)\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenClause","title":"ForbiddenClause","text":"<pre><code>ForbiddenClause(hyperparameter: Hyperparameter)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class for forbidden clauses.</p> PARAMETER DESCRIPTION <code>hyperparameter</code> <p>Hyperparameter on which a restriction will be made</p> <p> TYPE: <code>Hyperparameter</code> </p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def __init__(self, hyperparameter: Hyperparameter) -&gt; None:\n    \"\"\"Initialize a ForbiddenClause.\n\n    Args:\n        hyperparameter: Hyperparameter on which a restriction will be made\n    \"\"\"\n    self.hyperparameter = hyperparameter\n    self.vector_id: np.intp | None = None\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenClause.hyperparameter","title":"hyperparameter  <code>instance-attribute</code>","text":"<pre><code>hyperparameter: Hyperparameter = hyperparameter\n</code></pre> <p>Hyperparameter on which a restriction will be made.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenClause.vector_id","title":"vector_id  <code>instance-attribute</code>","text":"<pre><code>vector_id: intp | None = None\n</code></pre> <p>Index of the hyperparameter in the vector representation.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenClause.is_forbidden_value","title":"is_forbidden_value  <code>abstractmethod</code>","text":"<pre><code>is_forbidden_value(values: dict[str, Any]) -&gt; bool\n</code></pre> <p>Check if a value is forbidden.</p> PARAMETER DESCRIPTION <code>values</code> <p>A dictionary of hyperparameter names to values</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the value is forbidden, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>@abstractmethod\ndef is_forbidden_value(self, values: dict[str, Any]) -&gt; bool:\n    \"\"\"Check if a value is forbidden.\n\n    Args:\n        values: A dictionary of hyperparameter names to values\n\n    Returns:\n        bool: True if the value is forbidden, False otherwise\n    \"\"\"\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenClause.is_forbidden_vector","title":"is_forbidden_vector  <code>abstractmethod</code>","text":"<pre><code>is_forbidden_vector(vector: Array[f64]) -&gt; bool\n</code></pre> <p>Check if a vector is forbidden.</p> <p>Will use <code>.vector_id</code> to index the vector.</p> PARAMETER DESCRIPTION <code>vector</code> <p>A vector representation of the hyperparameters</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the vector is forbidden, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>@abstractmethod\ndef is_forbidden_vector(self, vector: Array[f64]) -&gt; bool:\n    \"\"\"Check if a vector is forbidden.\n\n    Will use [`.vector_id`][ConfigSpace.forbidden.ForbiddenClause.vector_id] to\n    index the vector.\n\n    Args:\n        vector: A vector representation of the hyperparameters\n\n    Returns:\n        bool: True if the vector is forbidden, False otherwise\n    \"\"\"\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenClause.is_forbidden_vector_array","title":"is_forbidden_vector_array  <code>abstractmethod</code>","text":"<pre><code>is_forbidden_vector_array(arr: Array[f64]) -&gt; Mask\n</code></pre> <p>Check if an array of vectors is forbidden.</p> <p>Will use <code>.vector_id</code> to index the array.</p> PARAMETER DESCRIPTION <code>arr</code> <p>An array of vector representations of the hyperparameters</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask</code> <p>A boolean mask of the forbidden vectors</p> <p> TYPE: <code>Mask</code> </p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>@abstractmethod\ndef is_forbidden_vector_array(self, arr: Array[f64]) -&gt; Mask:\n    \"\"\"Check if an array of vectors is forbidden.\n\n    Will use [`.vector_id`][ConfigSpace.forbidden.ForbiddenClause.vector_id] to\n    index the array.\n\n    Args:\n        arr: An array of vector representations of the hyperparameters\n\n    Returns:\n        Mask: A boolean mask of the forbidden vectors\n    \"\"\"\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenClause.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, Any]\n) -&gt; None\n</code></pre> <p>Set the vector index of the hyperparameter.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, Any]) -&gt; None:\n    \"\"\"Set the vector index of the hyperparameter.\"\"\"\n    self.vector_id = np.intp(hyperparameter_to_idx[self.hyperparameter.name])\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenClause.to_dict","title":"to_dict  <code>abstractmethod</code>","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert the forbidden clause to a dictionary representation.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>@abstractmethod\ndef to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the forbidden clause to a dictionary representation.\"\"\"\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenConjunction","title":"ForbiddenConjunction","text":"<pre><code>ForbiddenConjunction(\n    *args: ForbiddenClause\n    | ForbiddenConjunction\n    | ForbiddenRelation,\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class for forbidden conjunctions.</p> PARAMETER DESCRIPTION <code>*args</code> <p>forbidden clauses, which should be combined</p> <p> TYPE: <code>ForbiddenClause | ForbiddenConjunction | ForbiddenRelation</code> DEFAULT: <code>()</code> </p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def __init__(\n    self,\n    *args: ForbiddenClause | ForbiddenConjunction | ForbiddenRelation,\n) -&gt; None:\n    \"\"\"Initialize a ForbiddenConjunction.\n\n    Args:\n        *args: forbidden clauses, which should be combined\n    \"\"\"\n    # Test the classes\n    acceptable = (ForbiddenClause, ForbiddenConjunction, ForbiddenRelation)\n    for idx, component in enumerate(args):\n        if not isinstance(component, acceptable):\n            raise TypeError(\n                \"Argument #%d is not an instance of %s, \"\n                \"but %s\" % (idx, acceptable, type(component)),\n            )\n\n    self.components = args\n    dlcs: list[ForbiddenClause | ForbiddenRelation] = []\n    for component in self.components:\n        if isinstance(component, ForbiddenConjunction):\n            dlcs.extend(component.dlcs)\n        else:\n            dlcs.append(component)\n\n    self.dlcs: tuple[ForbiddenClause | ForbiddenRelation, ...] = tuple(\n        unique_everseen(dlcs, key=lambda x: id(x)),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenConjunction.components","title":"components  <code>instance-attribute</code>","text":"<pre><code>components: tuple[\n    ForbiddenClause\n    | ForbiddenConjunction\n    | ForbiddenRelation,\n    ...,\n] = args\n</code></pre> <p>Components of the conjunction.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenConjunction.dlcs","title":"dlcs  <code>instance-attribute</code>","text":"<pre><code>dlcs: tuple[ForbiddenClause | ForbiddenRelation, ...] = (\n    tuple(unique_everseen(dlcs, key=lambda x: id(x)))\n)\n</code></pre> <p>Descendant literal clauses of the conjunction.</p> <p>These are the base forbidden clauses/relations that are part of conjunctions.</p> <p>Note</p> <p>This will only store a unique set of the descendant clauses, no duplicates.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenConjunction.get_descendant_literal_clauses","title":"get_descendant_literal_clauses","text":"<pre><code>get_descendant_literal_clauses() -&gt; (\n    tuple[ForbiddenClause | ForbiddenRelation, ...]\n)\n</code></pre> <p>Get the descendant literal clauses of the conjunction.</p> <p>Deprecated</p> <p>Please use the <code>.dlcs</code> attribute instead.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>@deprecated(\"Use `.dlcs` instead\")\ndef get_descendant_literal_clauses(\n    self,\n) -&gt; tuple[ForbiddenClause | ForbiddenRelation, ...]:\n    \"\"\"Get the descendant literal clauses of the conjunction.\n\n    !!! note \"Deprecated\"\n\n        Please use the `.dlcs` attribute instead.\n    \"\"\"\n    return self.dlcs\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenConjunction.is_forbidden_value","title":"is_forbidden_value  <code>abstractmethod</code>","text":"<pre><code>is_forbidden_value(values: dict[str, Any]) -&gt; bool\n</code></pre> <p>Check if a value is forbidden.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>@abstractmethod\ndef is_forbidden_value(self, values: dict[str, Any]) -&gt; bool:\n    \"\"\"Check if a value is forbidden.\"\"\"\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenConjunction.is_forbidden_vector","title":"is_forbidden_vector  <code>abstractmethod</code>","text":"<pre><code>is_forbidden_vector(vector: Array[f64]) -&gt; bool\n</code></pre> <p>Check if a vector is forbidden.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>@abstractmethod\ndef is_forbidden_vector(self, vector: Array[f64]) -&gt; bool:\n    \"\"\"Check if a vector is forbidden.\"\"\"\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenConjunction.is_forbidden_vector_array","title":"is_forbidden_vector_array  <code>abstractmethod</code>","text":"<pre><code>is_forbidden_vector_array(arr: Array[f64]) -&gt; Mask\n</code></pre> <p>Check if an array of vectors is forbidden.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>@abstractmethod\ndef is_forbidden_vector_array(self, arr: Array[f64]) -&gt; Mask:\n    \"\"\"Check if an array of vectors is forbidden.\"\"\"\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenConjunction.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, int]\n) -&gt; None\n</code></pre> <p>Set vector index of hyperparameters in each element of the conjunction.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, int]) -&gt; None:\n    \"\"\"Set vector index of hyperparameters in each element of the conjunction.\"\"\"\n    for component in self.components:\n        component.set_vector_idx(hyperparameter_to_idx)\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenConjunction.to_dict","title":"to_dict  <code>abstractmethod</code>","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert the forbidden conjunction to a dictionary representation.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>@abstractmethod\ndef to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the forbidden conjunction to a dictionary representation.\"\"\"\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenEqualsClause","title":"ForbiddenEqualsClause","text":"<pre><code>ForbiddenEqualsClause(\n    hyperparameter: Hyperparameter, value: Any\n)\n</code></pre> <p>               Bases: <code>ForbiddenClause</code></p> <p>A ForbiddenEqualsClause.</p> <p>It forbids a value from the value range of a hyperparameter to be equal to <code>value</code>.</p> <p>Forbids the value 2 for the hyperparameter a</p> <pre><code>from ConfigSpace import ConfigurationSpace, ForbiddenEqualsClause\n\ncs = ConfigurationSpace({\"a\": [1, 2, 3]})\nforbidden_clause_a = ForbiddenEqualsClause(cs[\"a\"], 2)\ncs.add(forbidden_clause_a)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: Categorical, Choices: {1, 2, 3}, Default: 1\n  Forbidden Clauses:\n    Forbidden: a == 2\n</code></pre> PARAMETER DESCRIPTION <code>hyperparameter</code> <p>Methods on which a restriction will be made</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>value</code> <p>forbidden value</p> <p> TYPE: <code>Any</code> </p> PARAMETER DESCRIPTION <code>hyperparameter</code> <p>Hyperparameter on which a restriction will be made</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>value</code> <p>forbidden value</p> <p> TYPE: <code>Any</code> </p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def __init__(self, hyperparameter: Hyperparameter, value: Any) -&gt; None:\n    \"\"\"Initialize a ForbiddenEqualsClause.\n\n    Args:\n        hyperparameter: Hyperparameter on which a restriction will be made\n        value: forbidden value\n    \"\"\"\n    if not hyperparameter.legal_value(value):\n        raise ValueError(\n            \"Forbidden clause must be instantiated with a \"\n            f\"legal hyperparameter value for '{hyperparameter}', but got \"\n            f\"'{value!s}'\",\n        )\n    super().__init__(hyperparameter)\n    self.value = value\n\n    # OPTIM: Since forbiddens are used in sampling which converts everything to\n    # f64, we pre-convert the value here to make the comparison check faster\n    self.vector_value = f64(self.hyperparameter.to_vector(self.value))\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenEqualsClause.hyperparameter","title":"hyperparameter  <code>instance-attribute</code>","text":"<pre><code>hyperparameter: Hyperparameter\n</code></pre> <p>Hyperparameter on which a restriction will be made.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenEqualsClause.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Any = value\n</code></pre> <p>Forbidden value.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenEqualsClause.vector_id","title":"vector_id  <code>instance-attribute</code>","text":"<pre><code>vector_id: intp | None = None\n</code></pre> <p>Index of the hyperparameter in the vector representation.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenEqualsClause.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, Any]\n) -&gt; None\n</code></pre> <p>Set the vector index of the hyperparameter.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, Any]) -&gt; None:\n    \"\"\"Set the vector index of the hyperparameter.\"\"\"\n    self.vector_id = np.intp(hyperparameter_to_idx[self.hyperparameter.name])\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenEqualsRelation","title":"ForbiddenEqualsRelation","text":"<pre><code>ForbiddenEqualsRelation(\n    left: Hyperparameter, right: Hyperparameter\n)\n</code></pre> <p>               Bases: <code>ForbiddenRelation</code></p> <p>A ForbiddenEquals relation between two hyperparameters.</p> <p>The ForbiddenEquals compares the values of two hyperparameters.</p> <pre><code>from ConfigSpace import ConfigurationSpace, ForbiddenEqualsRelation\n\ncs = ConfigurationSpace({\"a\": [1, 2, 3], \"b\": [2, 5, 6]})\n\nforbidden_clause = ForbiddenEqualsRelation(cs['a'], cs['b'])\ncs.add(forbidden_clause)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: Categorical, Choices: {1, 2, 3}, Default: 1\n    b, Type: Categorical, Choices: {2, 5, 6}, Default: 2\n  Forbidden Clauses:\n    Forbidden: a == b\n</code></pre> <p>Note</p> <p>If the values of the both hyperparameters are not comparible (e.g. comparing int and str), a TypeError is raised. For OrdinalHyperparameters the actual values are used for comparison not their ordinal value.</p> PARAMETER DESCRIPTION <code>left</code> <p>left side of the comparison</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>right</code> <p>right side of the comparison</p> <p> TYPE: <code>Hyperparameter</code> </p> PARAMETER DESCRIPTION <code>left</code> <p>left side of the comparison</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>right</code> <p>right side of the comparison</p> <p> TYPE: <code>Hyperparameter</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If <code>left</code> or <code>right</code> are not instances of <code>Hyperparameter</code></p> <p>Note</p> <p>If the values of the both hyperparameters are not comparible (e.g. comparing int and str), a TypeError is raised. For OrdinalHyperparameters the actual values are used for comparison not their ordinal value.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def __init__(self, left: Hyperparameter, right: Hyperparameter):\n    \"\"\"Initialize a ForbiddenRelation.\n\n    Args:\n        left: left side of the comparison\n        right: right side of the comparison\n\n    Raises:\n        TypeError: If `left` or `right` are not instances of `Hyperparameter`\n\n    !!! note\n\n        If the values of the both hyperparameters are not comparible\n        (e.g. comparing int and str), a TypeError is raised. For\n        OrdinalHyperparameters the actual values are used for comparison **not**\n        their ordinal value.\n    \"\"\"\n    if not isinstance(left, Hyperparameter):\n        raise TypeError(f\"Argument 'left' is not of type {Hyperparameter}.\")\n    if not isinstance(right, Hyperparameter):\n        raise TypeError(f\"Argument 'right' is not of type {Hyperparameter}.\")\n\n    self.left = left\n    self.right = right\n    self.vector_ids: tuple[None, None] | tuple[np.intp, np.intp] = (None, None)\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenEqualsRelation.left","title":"left  <code>instance-attribute</code>","text":"<pre><code>left: Hyperparameter\n</code></pre> <p>Left side of the comparison.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenEqualsRelation.right","title":"right  <code>instance-attribute</code>","text":"<pre><code>right: Hyperparameter\n</code></pre> <p>Right side of the comparison.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenEqualsRelation.vector_ids","title":"vector_ids  <code>instance-attribute</code>","text":"<pre><code>vector_ids: tuple[None, None] | tuple[intp, intp]\n</code></pre> <p>Indices of the hyperparameters in the vector representation.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenEqualsRelation.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, int]\n) -&gt; None\n</code></pre> <p>Set the vector index of the hyperparameters.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, int]) -&gt; None:\n    \"\"\"Set the vector index of the hyperparameters.\"\"\"\n    self.vector_ids = (\n        np.intp(hyperparameter_to_idx[self.left.name]),\n        np.intp(hyperparameter_to_idx[self.right.name]),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenEqualsRelation.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert the forbidden relation to a dictionary representation.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the forbidden relation to a dictionary representation.\"\"\"\n    return {\n        \"left\": self.left.name,\n        \"right\": self.right.name,\n        \"type\": \"RELATION\",\n        \"lambda\": self._RELATION_STR,\n    }\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenGreaterThanRelation","title":"ForbiddenGreaterThanRelation","text":"<pre><code>ForbiddenGreaterThanRelation(\n    left: Hyperparameter, right: Hyperparameter\n)\n</code></pre> <p>               Bases: <code>ForbiddenRelation</code></p> <p>A ForbiddenGreaterThan relation between two hyperparameters.</p> <p>The ForbiddenGreaterThan compares the values of two hyperparameters.</p> <pre><code>from ConfigSpace import ConfigurationSpace, ForbiddenGreaterThanRelation\n\ncs = ConfigurationSpace({\"a\": [1, 2, 3], \"b\": [2, 5, 6]})\nforbidden_clause = ForbiddenGreaterThanRelation(cs['a'], cs['b'])\n\ncs.add(forbidden_clause)\n</code></pre> <pre><code>\n</code></pre> <p>Note</p> <p>If the values of the both hyperparameters are not comparible (e.g. comparing int and str), a TypeError is raised. For OrdinalHyperparameters the actual values are used for comparison not their ordinal value.</p> PARAMETER DESCRIPTION <code>left</code> <p>left side of the comparison</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>right</code> <p>right side of the comparison</p> <p> TYPE: <code>Hyperparameter</code> </p> PARAMETER DESCRIPTION <code>left</code> <p>left side of the comparison</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>right</code> <p>right side of the comparison</p> <p> TYPE: <code>Hyperparameter</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If <code>left</code> or <code>right</code> are not instances of <code>Hyperparameter</code></p> <p>Note</p> <p>If the values of the both hyperparameters are not comparible (e.g. comparing int and str), a TypeError is raised. For OrdinalHyperparameters the actual values are used for comparison not their ordinal value.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def __init__(self, left: Hyperparameter, right: Hyperparameter):\n    \"\"\"Initialize a ForbiddenRelation.\n\n    Args:\n        left: left side of the comparison\n        right: right side of the comparison\n\n    Raises:\n        TypeError: If `left` or `right` are not instances of `Hyperparameter`\n\n    !!! note\n\n        If the values of the both hyperparameters are not comparible\n        (e.g. comparing int and str), a TypeError is raised. For\n        OrdinalHyperparameters the actual values are used for comparison **not**\n        their ordinal value.\n    \"\"\"\n    if not isinstance(left, Hyperparameter):\n        raise TypeError(f\"Argument 'left' is not of type {Hyperparameter}.\")\n    if not isinstance(right, Hyperparameter):\n        raise TypeError(f\"Argument 'right' is not of type {Hyperparameter}.\")\n\n    self.left = left\n    self.right = right\n    self.vector_ids: tuple[None, None] | tuple[np.intp, np.intp] = (None, None)\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenGreaterThanRelation.left","title":"left  <code>instance-attribute</code>","text":"<pre><code>left: Hyperparameter\n</code></pre> <p>Left side of the comparison.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenGreaterThanRelation.right","title":"right  <code>instance-attribute</code>","text":"<pre><code>right: Hyperparameter\n</code></pre> <p>Right side of the comparison.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenGreaterThanRelation.vector_ids","title":"vector_ids  <code>instance-attribute</code>","text":"<pre><code>vector_ids: tuple[None, None] | tuple[intp, intp]\n</code></pre> <p>Indices of the hyperparameters in the vector representation.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenGreaterThanRelation.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, int]\n) -&gt; None\n</code></pre> <p>Set the vector index of the hyperparameters.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, int]) -&gt; None:\n    \"\"\"Set the vector index of the hyperparameters.\"\"\"\n    self.vector_ids = (\n        np.intp(hyperparameter_to_idx[self.left.name]),\n        np.intp(hyperparameter_to_idx[self.right.name]),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenGreaterThanRelation.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert the forbidden relation to a dictionary representation.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the forbidden relation to a dictionary representation.\"\"\"\n    return {\n        \"left\": self.left.name,\n        \"right\": self.right.name,\n        \"type\": \"RELATION\",\n        \"lambda\": self._RELATION_STR,\n    }\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenInClause","title":"ForbiddenInClause","text":"<pre><code>ForbiddenInClause(\n    hyperparameter: Hyperparameter, values: Iterable[Any]\n)\n</code></pre> <p>               Bases: <code>ForbiddenClause</code></p> <p>A ForbiddenInClause.</p> <p>It forbids a value from the value range of a hyperparameter to be in a collection of <code>values</code>.</p> <p>Forbids the values 2, 3 for the hyperparameter a</p> <pre><code>from ConfigSpace import ConfigurationSpace, ForbiddenInClause\n\ncs = ConfigurationSpace({\"a\": [1, 2, 3]})\nforbidden_clause_a = ForbiddenInClause(cs['a'], [2, 3])\ncs.add(forbidden_clause_a)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: Categorical, Choices: {1, 2, 3}, Default: 1\n  Forbidden Clauses:\n    Forbidden: a in {2, 3}\n</code></pre> <p>Note</p> <p>The forbidden values have to be a subset of the hyperparameter's values.</p> PARAMETER DESCRIPTION <code>hyperparameter</code> <p>Hyperparameter on which a restriction will be made</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>values</code> <p>Collection of forbidden values</p> <p> TYPE: <code>Iterable[Any]</code> </p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def __init__(self, hyperparameter: Hyperparameter, values: Iterable[Any]) -&gt; None:\n    \"\"\"Initialize a ForbiddenInClause.\n\n    Args:\n        hyperparameter: Hyperparameter on which a restriction will be made\n        values: Collection of forbidden values\n    \"\"\"\n    values = tuple(values)\n    for v in values:\n        if not hyperparameter.legal_value(v):\n            raise ValueError(\n                \"Forbidden clause must be instantiated with a \"\n                f\"legal hyperparameter value for '{hyperparameter}', but got \"\n                f\"'{v!s}'\",\n            )\n    super().__init__(hyperparameter)\n    self.values = values\n    self.vector_values = tuple(hyperparameter.to_vector(v) for v in values)\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenInClause.hyperparameter","title":"hyperparameter  <code>instance-attribute</code>","text":"<pre><code>hyperparameter: Hyperparameter\n</code></pre> <p>Hyperparameter on which a restriction will be made.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenInClause.values","title":"values  <code>instance-attribute</code>","text":"<pre><code>values: tuple[Any, ...] = values\n</code></pre> <p>Collection of forbidden values.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenInClause.vector_id","title":"vector_id  <code>instance-attribute</code>","text":"<pre><code>vector_id: intp | None = None\n</code></pre> <p>Index of the hyperparameter in the vector representation.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenInClause.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, Any]\n) -&gt; None\n</code></pre> <p>Set the vector index of the hyperparameter.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, Any]) -&gt; None:\n    \"\"\"Set the vector index of the hyperparameter.\"\"\"\n    self.vector_id = np.intp(hyperparameter_to_idx[self.hyperparameter.name])\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenLessThanRelation","title":"ForbiddenLessThanRelation","text":"<pre><code>ForbiddenLessThanRelation(\n    left: Hyperparameter, right: Hyperparameter\n)\n</code></pre> <p>               Bases: <code>ForbiddenRelation</code></p> <p>A ForbiddenLessThan relation between two hyperparameters.</p> <p>The ForbiddenLessThan compares the values of two hyperparameters.</p> <pre><code>from ConfigSpace import ConfigurationSpace, ForbiddenLessThanRelation\n\ncs = ConfigurationSpace({\"a\": [10, 2, 3], \"b\": [2, 5, 6]})\n\nforbidden_clause = ForbiddenLessThanRelation(cs['a'], cs['b'])\ncs.add(forbidden_clause)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: Categorical, Choices: {10, 2, 3}, Default: 10\n    b, Type: Categorical, Choices: {2, 5, 6}, Default: 2\n  Forbidden Clauses:\n    Forbidden: a &lt; b\n</code></pre> <p>Note</p> <p>If the values of the both hyperparameters are not comparible (e.g. comparing int and str), a TypeError is raised. For OrdinalHyperparameters the actual values are used for comparison not their ordinal value.</p> PARAMETER DESCRIPTION <code>left</code> <p>left side of the comparison</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>right</code> <p>right side of the comparison</p> <p> TYPE: <code>Hyperparameter</code> </p> PARAMETER DESCRIPTION <code>left</code> <p>left side of the comparison</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>right</code> <p>right side of the comparison</p> <p> TYPE: <code>Hyperparameter</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If <code>left</code> or <code>right</code> are not instances of <code>Hyperparameter</code></p> <p>Note</p> <p>If the values of the both hyperparameters are not comparible (e.g. comparing int and str), a TypeError is raised. For OrdinalHyperparameters the actual values are used for comparison not their ordinal value.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def __init__(self, left: Hyperparameter, right: Hyperparameter):\n    \"\"\"Initialize a ForbiddenRelation.\n\n    Args:\n        left: left side of the comparison\n        right: right side of the comparison\n\n    Raises:\n        TypeError: If `left` or `right` are not instances of `Hyperparameter`\n\n    !!! note\n\n        If the values of the both hyperparameters are not comparible\n        (e.g. comparing int and str), a TypeError is raised. For\n        OrdinalHyperparameters the actual values are used for comparison **not**\n        their ordinal value.\n    \"\"\"\n    if not isinstance(left, Hyperparameter):\n        raise TypeError(f\"Argument 'left' is not of type {Hyperparameter}.\")\n    if not isinstance(right, Hyperparameter):\n        raise TypeError(f\"Argument 'right' is not of type {Hyperparameter}.\")\n\n    self.left = left\n    self.right = right\n    self.vector_ids: tuple[None, None] | tuple[np.intp, np.intp] = (None, None)\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenLessThanRelation.left","title":"left  <code>instance-attribute</code>","text":"<pre><code>left: Hyperparameter\n</code></pre> <p>Left side of the comparison.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenLessThanRelation.right","title":"right  <code>instance-attribute</code>","text":"<pre><code>right: Hyperparameter\n</code></pre> <p>Right side of the comparison.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenLessThanRelation.vector_ids","title":"vector_ids  <code>instance-attribute</code>","text":"<pre><code>vector_ids: tuple[None, None] | tuple[intp, intp]\n</code></pre> <p>Indices of the hyperparameters in the vector representation.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenLessThanRelation.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, int]\n) -&gt; None\n</code></pre> <p>Set the vector index of the hyperparameters.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, int]) -&gt; None:\n    \"\"\"Set the vector index of the hyperparameters.\"\"\"\n    self.vector_ids = (\n        np.intp(hyperparameter_to_idx[self.left.name]),\n        np.intp(hyperparameter_to_idx[self.right.name]),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenLessThanRelation.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert the forbidden relation to a dictionary representation.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the forbidden relation to a dictionary representation.\"\"\"\n    return {\n        \"left\": self.left.name,\n        \"right\": self.right.name,\n        \"type\": \"RELATION\",\n        \"lambda\": self._RELATION_STR,\n    }\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenRelation","title":"ForbiddenRelation","text":"<pre><code>ForbiddenRelation(\n    left: Hyperparameter, right: Hyperparameter\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class for forbidden relations between hyperparameters.</p> PARAMETER DESCRIPTION <code>left</code> <p>left side of the comparison</p> <p> TYPE: <code>Hyperparameter</code> </p> <code>right</code> <p>right side of the comparison</p> <p> TYPE: <code>Hyperparameter</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If <code>left</code> or <code>right</code> are not instances of <code>Hyperparameter</code></p> <p>Note</p> <p>If the values of the both hyperparameters are not comparible (e.g. comparing int and str), a TypeError is raised. For OrdinalHyperparameters the actual values are used for comparison not their ordinal value.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def __init__(self, left: Hyperparameter, right: Hyperparameter):\n    \"\"\"Initialize a ForbiddenRelation.\n\n    Args:\n        left: left side of the comparison\n        right: right side of the comparison\n\n    Raises:\n        TypeError: If `left` or `right` are not instances of `Hyperparameter`\n\n    !!! note\n\n        If the values of the both hyperparameters are not comparible\n        (e.g. comparing int and str), a TypeError is raised. For\n        OrdinalHyperparameters the actual values are used for comparison **not**\n        their ordinal value.\n    \"\"\"\n    if not isinstance(left, Hyperparameter):\n        raise TypeError(f\"Argument 'left' is not of type {Hyperparameter}.\")\n    if not isinstance(right, Hyperparameter):\n        raise TypeError(f\"Argument 'right' is not of type {Hyperparameter}.\")\n\n    self.left = left\n    self.right = right\n    self.vector_ids: tuple[None, None] | tuple[np.intp, np.intp] = (None, None)\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenRelation.left","title":"left  <code>instance-attribute</code>","text":"<pre><code>left: Hyperparameter = left\n</code></pre> <p>Left side of the comparison.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenRelation.right","title":"right  <code>instance-attribute</code>","text":"<pre><code>right: Hyperparameter = right\n</code></pre> <p>Right side of the comparison.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenRelation.vector_ids","title":"vector_ids  <code>instance-attribute</code>","text":"<pre><code>vector_ids: tuple[None, None] | tuple[intp, intp] = (\n    None,\n    None,\n)\n</code></pre> <p>Indices of the hyperparameters in the vector representation.</p>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenRelation.is_forbidden_value","title":"is_forbidden_value  <code>abstractmethod</code>","text":"<pre><code>is_forbidden_value(values: dict[str, Any]) -&gt; bool\n</code></pre> <p>Check if a value is forbidden.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>@abstractmethod\ndef is_forbidden_value(self, values: dict[str, Any]) -&gt; bool:\n    \"\"\"Check if a value is forbidden.\"\"\"\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenRelation.is_forbidden_vector","title":"is_forbidden_vector  <code>abstractmethod</code>","text":"<pre><code>is_forbidden_vector(vector: Array[f64]) -&gt; bool\n</code></pre> <p>Check if a vector is forbidden.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>@abstractmethod\ndef is_forbidden_vector(self, vector: Array[f64]) -&gt; bool:\n    \"\"\"Check if a vector is forbidden.\"\"\"\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenRelation.is_forbidden_vector_array","title":"is_forbidden_vector_array  <code>abstractmethod</code>","text":"<pre><code>is_forbidden_vector_array(arr: Array[f64]) -&gt; Mask\n</code></pre> <p>Check if an array of vectors is forbidden.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>@abstractmethod\ndef is_forbidden_vector_array(self, arr: Array[f64]) -&gt; Mask:\n    \"\"\"Check if an array of vectors is forbidden.\"\"\"\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenRelation.set_vector_idx","title":"set_vector_idx","text":"<pre><code>set_vector_idx(\n    hyperparameter_to_idx: Mapping[str, int]\n) -&gt; None\n</code></pre> <p>Set the vector index of the hyperparameters.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def set_vector_idx(self, hyperparameter_to_idx: Mapping[str, int]) -&gt; None:\n    \"\"\"Set the vector index of the hyperparameters.\"\"\"\n    self.vector_ids = (\n        np.intp(hyperparameter_to_idx[self.left.name]),\n        np.intp(hyperparameter_to_idx[self.right.name]),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/forbidden/#ConfigSpace.forbidden.ForbiddenRelation.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert the forbidden relation to a dictionary representation.</p> Source code in <code>src/ConfigSpace/forbidden.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the forbidden relation to a dictionary representation.\"\"\"\n    return {\n        \"left\": self.left.name,\n        \"right\": self.right.name,\n        \"type\": \"RELATION\",\n        \"lambda\": self._RELATION_STR,\n    }\n</code></pre>"},{"location":"api/ConfigSpace/functional/","title":"Functional","text":""},{"location":"api/ConfigSpace/functional/#ConfigSpace.functional","title":"ConfigSpace.functional","text":""},{"location":"api/ConfigSpace/functional/#ConfigSpace.functional.arange_chunked","title":"arange_chunked","text":"<pre><code>arange_chunked(\n    start: int, stop: int, step: int = 1, *, chunk_size: int\n) -&gt; Iterator[ndarray]\n</code></pre> <p>Get np.arange in a chunked fashion.</p> <pre><code>from ConfigSpace.functional import arange_chunked\n\nprint(list(arange_chunked(0, 10, chunk_size=3)))\n</code></pre> <pre><code>[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8]), array([9])]\n</code></pre> PARAMETER DESCRIPTION <code>start</code> <p>The start of the range</p> <p> TYPE: <code>int</code> </p> <code>stop</code> <p>The stop of the range</p> <p> TYPE: <code>int</code> </p> <code>chunk_size</code> <p>The size of the chunks</p> <p> TYPE: <code>int</code> </p> <code>step</code> <p>The step size</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Iterator[ndarray]</code> <p>An iterator of np.ndarrays</p> Source code in <code>src/ConfigSpace/functional.py</code> <pre><code>def arange_chunked(\n    start: int,\n    stop: int,\n    step: int = 1,\n    *,\n    chunk_size: int,\n) -&gt; Iterator[np.ndarray]:\n    \"\"\"Get np.arange in a chunked fashion.\n\n    ```python exec=\"true\", source=\"material-block\" result=\"python\"\n    from ConfigSpace.functional import arange_chunked\n\n    print(list(arange_chunked(0, 10, chunk_size=3)))\n    ```\n\n    Args:\n        start: The start of the range\n        stop: The stop of the range\n        chunk_size: The size of the chunks\n        step: The step size\n\n    Returns:\n        An iterator of np.ndarrays\n    \"\"\"\n    assert step &gt; 0\n    assert chunk_size &gt; 0\n    assert start &lt; stop\n\n    n_items = int(np.ceil((stop - start) / step))\n    n_chunks = int(np.ceil(n_items / chunk_size))\n\n    for chunk in range(n_chunks):\n        chunk_start = start + (chunk * chunk_size)\n        chunk_stop = min(chunk_start + chunk_size, stop)\n        yield np.arange(chunk_start, chunk_stop, step)\n</code></pre>"},{"location":"api/ConfigSpace/functional/#ConfigSpace.functional.center_range","title":"center_range","text":"<pre><code>center_range(\n    center: int, low: int, high: int, step: int = 1\n) -&gt; Iterator[int]\n</code></pre> <p>Get a range centered around a value.</p> <pre><code>from ConfigSpace.functional import center_range\n\nprint(list(center_range(5, 0, 10)))\n</code></pre> <pre><code>[4, 6, 3, 7, 2, 8, 1, 9, 0, 10]\n</code></pre> PARAMETER DESCRIPTION <code>center</code> <p>The center of the range</p> <p> TYPE: <code>int</code> </p> <code>low</code> <p>The low end of the range</p> <p> TYPE: <code>int</code> </p> <code>high</code> <p>The high end of the range</p> <p> TYPE: <code>int</code> </p> <code>step</code> <p>The step size</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Iterator[int]</code> <p>An iterator of ints around a center point</p> Source code in <code>src/ConfigSpace/functional.py</code> <pre><code>def center_range(\n    center: int,\n    low: int,\n    high: int,\n    step: int = 1,\n) -&gt; Iterator[int]:\n    \"\"\"Get a range centered around a value.\n\n    ```python exec=\"true\", source=\"material-block\" result=\"python\"\n    from ConfigSpace.functional import center_range\n\n    print(list(center_range(5, 0, 10)))\n    ```\n\n    Args:\n        center: The center of the range\n        low: The low end of the range\n        high: The high end of the range\n        step: The step size\n\n    Returns:\n        An iterator of ints around a center point\n    \"\"\"\n    assert low &lt;= center &lt;= high\n    above_center = range(center + step, high + 1, step)\n    below_center = range(center - step, low - 1, -step)\n    yield from roundrobin(below_center, above_center)\n</code></pre>"},{"location":"api/ConfigSpace/functional/#ConfigSpace.functional.is_close_to_integer","title":"is_close_to_integer","text":"<pre><code>is_close_to_integer(\n    value: f64 | float | Array[f64],\n    *,\n    atol: float = 1e-09,\n    rtol: float = 1e-05\n) -&gt; bool_ | Mask\n</code></pre> <p>Check if a value is close to an integer.</p> <p>This implements the same logic as <code>np.isclose</code> but removes a lot of the overhead.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check</p> <p> TYPE: <code>f64 | float | Array[f64]</code> </p> <code>atol</code> <p>The absolute tolerance</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>rtol</code> <p>The relative tolerance</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-05</code> </p> RETURNS DESCRIPTION <code>bool_ | Mask</code> <p>Whether the value is close to an integer</p> Source code in <code>src/ConfigSpace/functional.py</code> <pre><code>def is_close_to_integer(\n    value: f64 | float | Array[f64],\n    *,\n    atol: float = 1e-9,\n    rtol: float = 1e-5,\n) -&gt; np.bool_ | Mask:\n    \"\"\"Check if a value is close to an integer.\n\n    This implements the same logic as `np.isclose` but removes\n    a lot of the overhead.\n\n    Args:\n        value: The value to check\n        atol: The absolute tolerance\n        rtol: The relative tolerance\n\n    Returns:\n        Whether the value is close to an integer\n    \"\"\"\n    a = np.asarray(value)\n    b = np.rint(a)\n    return np.less_equal(np.abs(a - b), atol + rtol * np.abs(b))  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/functional/#ConfigSpace.functional.is_close_to_integer_single","title":"is_close_to_integer_single","text":"<pre><code>is_close_to_integer_single(\n    value: Number,\n    *,\n    atol: float = 1e-09,\n    rtol: float = 1e-05\n) -&gt; bool_\n</code></pre> <p>Check if a single value is close to an integer.</p> <p>This implements the same logic as <code>np.isclose</code> but removes a lot of the overhead.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check</p> <p> TYPE: <code>Number</code> </p> <code>atol</code> <p>The absolute tolerance</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>rtol</code> <p>The relative tolerance</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-05</code> </p> RETURNS DESCRIPTION <code>bool_</code> <p>Whether the value is close to an integer</p> Source code in <code>src/ConfigSpace/functional.py</code> <pre><code>def is_close_to_integer_single(\n    value: Number,\n    *,\n    atol: float = 1e-9,\n    rtol: float = 1e-5,\n) -&gt; np.bool_:\n    \"\"\"Check if a single value is close to an integer.\n\n    This implements the same logic as `np.isclose` but removes\n    a lot of the overhead.\n\n    Args:\n        value: The value to check\n        atol: The absolute tolerance\n        rtol: The relative tolerance\n\n    Returns:\n        Whether the value is close to an integer\n    \"\"\"\n    a = value\n    _b = np.rint(a)  # type: ignore\n    return abs(a - _b) &lt;= (atol + rtol * abs(_b))  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/functional/#ConfigSpace.functional.linspace_chunked","title":"linspace_chunked","text":"<pre><code>linspace_chunked(\n    start: float,\n    stop: float,\n    num: int,\n    *,\n    chunk_size: int,\n    endpoint: bool = False\n) -&gt; Iterator[ndarray]\n</code></pre> <p>Get np.linspace in a chunked fashion.</p> <pre><code>from ConfigSpace.functional import linspace_chunked\n\nprint(list(linspace_chunked(0, 10, 11, chunk_size=3, endpoint=True)))\n</code></pre> <pre><code>[array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7., 8.]), array([ 9., 10.])]\n</code></pre> PARAMETER DESCRIPTION <code>start</code> <p>The start of the range</p> <p> TYPE: <code>float</code> </p> <code>stop</code> <p>The stop of the range</p> <p> TYPE: <code>float</code> </p> <code>num</code> <p>The number of samples to generate</p> <p> TYPE: <code>int</code> </p> <code>chunk_size</code> <p>The size of the chunks</p> <p> TYPE: <code>int</code> </p> <code>endpoint</code> <p>If True, stop is the last sample. Otherwise, it is not included. Simliar to <code>np.linspace</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Iterator[ndarray]</code> <p>An iterator of np.ndarrays</p> Source code in <code>src/ConfigSpace/functional.py</code> <pre><code>def linspace_chunked(\n    start: float,\n    stop: float,\n    num: int,\n    *,\n    chunk_size: int,\n    endpoint: bool = False,\n) -&gt; Iterator[np.ndarray]:\n    \"\"\"Get np.linspace in a chunked fashion.\n\n    ```python exec=\"true\", source=\"material-block\" result=\"python\"\n    from ConfigSpace.functional import linspace_chunked\n\n    print(list(linspace_chunked(0, 10, 11, chunk_size=3, endpoint=True)))\n    ```\n\n    Args:\n        start: The start of the range\n        stop: The stop of the range\n        num: The number of samples to generate\n        chunk_size: The size of the chunks\n        endpoint:\n            If True, stop is the last sample. Otherwise, it is not included.\n            Simliar to `np.linspace`\n\n    Returns:\n        An iterator of np.ndarrays\n    \"\"\"\n    assert num &gt; 0\n    assert chunk_size &gt; 0\n    assert start &lt; stop\n\n    if num &lt;= chunk_size:\n        yield np.linspace(start, stop, int(num), endpoint=endpoint)\n        return\n\n    _div = num - 1 if endpoint else num\n    for chunk in arange_chunked(0, num, chunk_size=chunk_size):\n        yield (chunk / _div) * (stop - start) + start\n</code></pre>"},{"location":"api/ConfigSpace/functional/#ConfigSpace.functional.normalize","title":"normalize","text":"<pre><code>normalize(\n    x: Array[number],\n    *,\n    bounds: tuple[\n        int | float | number, int | float | number\n    ]\n) -&gt; Array[f64]\n</code></pre> <p>Normalize values to the unit range.</p> <pre><code>import numpy as np\nfrom ConfigSpace.functional import normalize\n\nprint(normalize(np.array([0.0, 5.0, 10.0]), bounds=(0, 10)))\n</code></pre> <pre><code>[0.  0.5 1. ]\n</code></pre> PARAMETER DESCRIPTION <code>x</code> <p>The values to normalize</p> <p> TYPE: <code>Array[number]</code> </p> <code>bounds</code> <p>The bounds of the range</p> <p> TYPE: <code>tuple[int | float | number, int | float | number]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The normalized values</p> Source code in <code>src/ConfigSpace/functional.py</code> <pre><code>def normalize(\n    x: Array[np.number],\n    *,\n    bounds: tuple[int | float | np.number, int | float | np.number],\n) -&gt; Array[f64]:\n    \"\"\"Normalize values to the unit range.\n\n    ```python exec=\"true\", source=\"material-block\" result=\"python\"\n    import numpy as np\n    from ConfigSpace.functional import normalize\n\n    print(normalize(np.array([0.0, 5.0, 10.0]), bounds=(0, 10)))\n    ```\n\n    Args:\n        x: The values to normalize\n        bounds: The bounds of the range\n\n    Returns:\n        The normalized values\n    \"\"\"\n    if bounds == (0, 1):\n        return x.astype(f64)\n\n    return (x - bounds[0]) / (bounds[1] - bounds[0])  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/functional/#ConfigSpace.functional.quantize","title":"quantize","text":"<pre><code>quantize(\n    x: Array[f64] | f64,\n    *,\n    bounds: tuple[Number, Number],\n    bins: int\n) -&gt; Array[f64] | f64\n</code></pre> <p>Discretize an array of values to their closest bin.</p> <p>Similar to <code>np.digitize</code> but does not require the bins to be specified or loaded into memory. Similar to <code>np.histogram</code> but returns the same length as the input array, where each element is assigned to their integer bin.</p> <pre><code>import numpy as np\nfrom ConfigSpace.functional import quantize\n\nprint(quantize(np.array([0.0, 0.32, 0.33, 0.34, 0.65, 0.66, 0.67, 0.99, 1.0]), bounds=(0, 1), bins=3))\n</code></pre> <pre><code>[0.  0.  0.  0.5 0.5 0.5 1.  1.  1. ]\n</code></pre> PARAMETER DESCRIPTION <code>x</code> <p>The values to discretize</p> <p> TYPE: <code>Array[f64] | f64</code> </p> <code>bounds</code> <p>The bounds of the range</p> <p> TYPE: <code>tuple[Number, Number]</code> </p> <code>bins</code> <p>The number of bins</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Array[f64] | f64</code> <p>The discretized values</p> Source code in <code>src/ConfigSpace/functional.py</code> <pre><code>def quantize(\n    x: Array[f64] | f64,\n    *,\n    bounds: tuple[Number, Number],\n    bins: int,\n) -&gt; Array[f64] | f64:\n    \"\"\"Discretize an array of values to their closest bin.\n\n    Similar to `np.digitize` but does not require the bins to be specified or loaded\n    into memory.\n    Similar to `np.histogram` but returns the same length as the input array, where each\n    element is assigned to their integer bin.\n\n    ```python exec=\"true\", source=\"material-block\" result=\"python\"\n    import numpy as np\n    from ConfigSpace.functional import quantize\n\n    print(quantize(np.array([0.0, 0.32, 0.33, 0.34, 0.65, 0.66, 0.67, 0.99, 1.0]), bounds=(0, 1), bins=3))\n    ```\n\n    Args:\n        x: The values to discretize\n        bounds: The bounds of the range\n        bins: The number of bins\n\n    Returns:\n        The discretized values\n    \"\"\"  # noqa: E501\n    # Shortcut out if we have unit norm already\n    l, u = bounds  # noqa: E741\n    unitnorm = x if bounds == (0, 1) else (x - l) / (u - l)\n\n    quantization_levels = np.floor(unitnorm * bins).clip(0, bins - 1)\n    unit_norm_quantized = quantization_levels / (bins - 1)\n    if bounds == (0, 1):\n        return unit_norm_quantized\n\n    return unit_norm_quantized * (u - l) + l  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/functional/#ConfigSpace.functional.quantize_log","title":"quantize_log","text":"<pre><code>quantize_log(\n    x: Array[f64],\n    *,\n    bounds: tuple[\n        int | float | number, int | float | number\n    ],\n    scale_slice: (\n        tuple[int | float | number, int | float | number]\n        | None\n    ) = None,\n    bins: int\n) -&gt; Array[f64]\n</code></pre> <p>Quantize an array of values on a log scale.</p> <p>Works by first lifting the values to the provided slice of the log scale (scale_slice), exponentiate back to linear scale and then perform quantization. Gives back the values in provided scale (bounds).</p> PARAMETER DESCRIPTION <code>x</code> <p>The values to quantize</p> <p> TYPE: <code>Array[f64]</code> </p> <code>bounds</code> <p>The bounds on which the values live on</p> <p> TYPE: <code>tuple[int | float | number, int | float | number]</code> </p> <code>scale_slice</code> <p>The specific slice of the log scale they were logged from.</p> <p> TYPE: <code>tuple[int | float | number, int | float | number] | None</code> DEFAULT: <code>None</code> </p> <code>bins</code> <p>The number of bins to quantize to</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The quantized values</p> Source code in <code>src/ConfigSpace/functional.py</code> <pre><code>def quantize_log(\n    x: Array[f64],\n    *,\n    bounds: tuple[int | float | np.number, int | float | np.number],\n    scale_slice: tuple[int | float | np.number, int | float | np.number] | None = None,\n    bins: int,\n) -&gt; Array[f64]:\n    \"\"\"Quantize an array of values on a log scale.\n\n    Works by first lifting the values to the provided slice of the log scale\n    (scale_slice), exponentiate back to linear scale and then perform quantization.\n    Gives back the values in provided scale (bounds).\n\n    Args:\n        x: The values to quantize\n        bounds: The bounds on which the values live on\n        scale_slice: The specific slice of the log scale they were logged from.\n        bins: The number of bins to quantize to\n\n    Returns:\n        The quantized values\n    \"\"\"\n    if scale_slice is None:\n        scale_slice = bounds\n\n    log_bounds = (np.log(scale_slice[0]), np.log(scale_slice[1]))\n\n    # Lift to the log scale\n    x_log = rescale(x, frm=bounds, to=log_bounds)\n\n    # Lift to original scale\n    x_orig = np.exp(x_log)\n\n    # Quantize on the scale\n    qx_orig = quantize(\n        x_orig,\n        bounds=scale_slice,\n        bins=bins,\n    )\n\n    # Now back to log\n    qx_log = np.log(qx_orig)\n\n    # And norm back to original scale\n    return rescale(qx_log, frm=log_bounds, to=bounds)\n</code></pre>"},{"location":"api/ConfigSpace/functional/#ConfigSpace.functional.rescale","title":"rescale","text":"<pre><code>rescale(\n    x: Array[f64],\n    frm: tuple[int | float | number, int | float | number],\n    to: tuple[int | float | number, int | float | number],\n) -&gt; Array[f64]\n</code></pre> <p>Rescale values from one range to another.</p> <pre><code>import numpy as np\nfrom ConfigSpace.functional import rescale\n\nprint(rescale(np.array([0, 10, 20]), frm=(0, 100), to=(0, 10)))\n</code></pre> <pre><code>[0. 1. 2.]\n</code></pre> PARAMETER DESCRIPTION <code>x</code> <p>The values to rescale</p> <p> TYPE: <code>Array[f64]</code> </p> <code>frm</code> <p>The original range</p> <p> TYPE: <code>tuple[int | float | number, int | float | number]</code> </p> <code>to</code> <p>The new range</p> <p> TYPE: <code>tuple[int | float | number, int | float | number]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The rescaled values</p> Source code in <code>src/ConfigSpace/functional.py</code> <pre><code>def rescale(\n    x: Array[f64],\n    frm: tuple[int | float | np.number, int | float | np.number],\n    to: tuple[int | float | np.number, int | float | np.number],\n) -&gt; Array[f64]:\n    \"\"\"Rescale values from one range to another.\n\n    ```python exec=\"true\", source=\"material-block\" result=\"python\"\n    import numpy as np\n    from ConfigSpace.functional import rescale\n\n    print(rescale(np.array([0, 10, 20]), frm=(0, 100), to=(0, 10)))\n    ```\n\n    Args:\n        x: The values to rescale\n        frm: The original range\n        to: The new range\n\n    Returns:\n        The rescaled values\n    \"\"\"\n    if frm == to:\n        return x.astype(f64)\n\n    normed = normalize(x, bounds=frm)\n    return scale(unit_xs=normed, to=to)\n</code></pre>"},{"location":"api/ConfigSpace/functional/#ConfigSpace.functional.scale","title":"scale","text":"<pre><code>scale(\n    unit_xs: Array[f64],\n    to: tuple[int | float | number, int | float | number],\n) -&gt; Array[f64]\n</code></pre> <p>Scale values from unit range to a new range.</p> <pre><code>import numpy as np\nfrom ConfigSpace.functional import scale\n\nprint(scale(np.array([0.0, 0.5, 1.0]), to=(0, 10)))\n</code></pre> <pre><code>[ 0.  5. 10.]\n</code></pre> PARAMETER DESCRIPTION <code>unit_xs</code> <p>The values to scale</p> <p> TYPE: <code>Array[f64]</code> </p> <code>to</code> <p>The new range</p> <p> TYPE: <code>tuple[int | float | number, int | float | number]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The scaled values</p> Source code in <code>src/ConfigSpace/functional.py</code> <pre><code>def scale(\n    unit_xs: Array[f64],\n    to: tuple[int | float | np.number, int | float | np.number],\n) -&gt; Array[f64]:\n    \"\"\"Scale values from unit range to a new range.\n\n    ```python exec=\"true\", source=\"material-block\" result=\"python\"\n    import numpy as np\n    from ConfigSpace.functional import scale\n\n    print(scale(np.array([0.0, 0.5, 1.0]), to=(0, 10)))\n    ```\n\n    Args:\n        unit_xs: The values to scale\n        to: The new range\n\n    Returns:\n        The scaled values\n    \"\"\"\n    return unit_xs * (to[1] - to[0]) + to[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/functional/#ConfigSpace.functional.split_arange","title":"split_arange","text":"<pre><code>split_arange(\n    frm: int, to: int, *, pivot: int\n) -&gt; Array[i64]\n</code></pre> <p>Split an arange into multiple ranges.</p> <pre><code>from ConfigSpace.functional import split_arange\n\nprint(split_arange(0, 10, pivot=5))\n</code></pre> <pre><code>[0 1 2 3 4 6 7 8 9]\n</code></pre> PARAMETER DESCRIPTION <code>frm</code> <p>Start of range</p> <p> TYPE: <code>int</code> </p> <code>to</code> <p>End of range</p> <p> TYPE: <code>int</code> </p> <code>pivot</code> <p>The pivot point, ommited from the output</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Array[i64]</code> <p>The concatenated ranges without the pivot</p> Source code in <code>src/ConfigSpace/functional.py</code> <pre><code>def split_arange(frm: int, to: int, *, pivot: int) -&gt; Array[i64]:\n    \"\"\"Split an arange into multiple ranges.\n\n    ```python exec=\"true\", source=\"material-block\" result=\"python\"\n    from ConfigSpace.functional import split_arange\n\n    print(split_arange(0, 10, pivot=5))\n    ```\n\n    Args:\n        frm: Start of range\n        to: End of range\n        pivot: The pivot point, ommited from the output\n\n    Returns:\n        The concatenated ranges without the pivot\n    \"\"\"\n    bot = np.arange(frm, pivot)\n    top = np.arange(pivot + 1, to)\n    return np.concatenate([bot, top])\n</code></pre>"},{"location":"api/ConfigSpace/functional/#ConfigSpace.functional.walk_subclasses","title":"walk_subclasses","text":"<pre><code>walk_subclasses(\n    cls: type[T], seen: set[type[T]] | None = None\n) -&gt; Iterator[type[T]]\n</code></pre> <p>Walk all subclasses of a class.</p> PARAMETER DESCRIPTION <code>cls</code> <p>The class to walk</p> <p> TYPE: <code>type[T]</code> </p> <code>seen</code> <p>The set of seen classes</p> <p> TYPE: <code>set[type[T]] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterator[type[T]]</code> <p>An iterator of subclasses</p> Source code in <code>src/ConfigSpace/functional.py</code> <pre><code>def walk_subclasses(\n    cls: type[T],\n    seen: set[type[T]] | None = None,\n) -&gt; Iterator[type[T]]:\n    \"\"\"Walk all subclasses of a class.\n\n    Args:\n        cls: The class to walk\n        seen: The set of seen classes\n\n    Returns:\n        An iterator of subclasses\n    \"\"\"\n    seen = set() if seen is None else seen\n    for subclass in cls.__subclasses__():\n        if subclass not in seen:\n            seen.add(subclass)\n            yield subclass\n            yield from walk_subclasses(subclass)\n</code></pre>"},{"location":"api/ConfigSpace/types/","title":"Types","text":""},{"location":"api/ConfigSpace/types/#ConfigSpace.types","title":"ConfigSpace.types","text":""},{"location":"api/ConfigSpace/types/#ConfigSpace.types.Array","title":"Array  <code>module-attribute</code>","text":"<pre><code>Array: TypeAlias = NDArray[DType]\n</code></pre> <p>Array, a numpy array of a specific dtype.</p>"},{"location":"api/ConfigSpace/types/#ConfigSpace.types.DType","title":"DType  <code>module-attribute</code>","text":"<pre><code>DType = TypeVar('DType', bound=number)\n</code></pre> <p>Some numpy number type.</p> <p>This represents a numpy array of values from the value space, for example a <code>np.int64</code>.</p>"},{"location":"api/ConfigSpace/types/#ConfigSpace.types.Mask","title":"Mask  <code>module-attribute</code>","text":"<pre><code>Mask: TypeAlias = NDArray[bool_]\n</code></pre> <p>Mask, a numpy array of bools.</p>"},{"location":"api/ConfigSpace/types/#ConfigSpace.types.NotSet","title":"NotSet  <code>module-attribute</code>","text":"<pre><code>NotSet: Final = _NotSet()\n</code></pre> <p>Sentinal value for unset values.</p> <p>This is useful in cases where <code>None</code> is a valid value and should not be used to indicate that something was not set.</p>"},{"location":"api/ConfigSpace/types/#ConfigSpace.types.Number","title":"Number  <code>module-attribute</code>","text":"<pre><code>Number: TypeAlias = Union[int, float, number]\n</code></pre> <p>Number, an integer, float, or numpy number.</p>"},{"location":"api/ConfigSpace/types/#ConfigSpace.types.ObjectArray","title":"ObjectArray  <code>module-attribute</code>","text":"<pre><code>ObjectArray: TypeAlias = NDArray[object_]\n</code></pre> <p>Object array, a numpy array of objects.</p>"},{"location":"api/ConfigSpace/types/#ConfigSpace.types.ValueT","title":"ValueT  <code>module-attribute</code>","text":"<pre><code>ValueT = TypeVar('ValueT')\n</code></pre> <p>Some value type.</p> <p>This represents a single value from the value space, not contained within some numpy array, for example a raw <code>int</code>.</p>"},{"location":"api/ConfigSpace/types/#ConfigSpace.types.f64","title":"f64  <code>module-attribute</code>","text":"<pre><code>f64: TypeAlias = float64\n</code></pre> <p>64-bit floating point number.</p>"},{"location":"api/ConfigSpace/types/#ConfigSpace.types.i64","title":"i64  <code>module-attribute</code>","text":"<pre><code>i64: TypeAlias = int64\n</code></pre> <p>64-bit integer.</p>"},{"location":"api/ConfigSpace/util/","title":"Util","text":""},{"location":"api/ConfigSpace/util/#ConfigSpace.util","title":"ConfigSpace.util","text":""},{"location":"api/ConfigSpace/util/#ConfigSpace.util.deactivate_inactive_hyperparameters","title":"deactivate_inactive_hyperparameters","text":"<pre><code>deactivate_inactive_hyperparameters(\n    configuration: dict,\n    configuration_space: ConfigurationSpace,\n    vector: None | ndarray = None,\n) -&gt; Configuration\n</code></pre> <p>Remove inactive hyperparameters from a given configuration.</p> PARAMETER DESCRIPTION <code>configuration</code> <p>a configuration as a dictionary.</p> <ul> <li>Key: name of the hyperparameter.</li> <li>Value: value of this hyperparamter</li> </ul> <p> TYPE: <code>dict</code> </p> <code>configuration_space</code> <p>The defined configuration space. It is necessary to find the inactive hyperparameters by iterating through the conditions of the configuration space.</p> <p> TYPE: <code>ConfigurationSpace</code> </p> <code>vector</code> <p>fficient represantation of a configuration. Either <code>configuration</code> or <code>vector</code> must be specified. If both are specified only <code>configuration</code> will be used.</p> <p> TYPE: <code>None | ndarray</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Configuration</code> <p>A configuration that is equivalent to the given configuration, except that inactivate hyperparameters have been removed.</p> Source code in <code>src/ConfigSpace/util.py</code> <pre><code>def deactivate_inactive_hyperparameters(\n    configuration: dict,\n    configuration_space: ConfigurationSpace,\n    vector: None | np.ndarray = None,\n) -&gt; Configuration:\n    \"\"\"Remove inactive hyperparameters from a given configuration.\n\n    Args:\n        configuration: a configuration as a dictionary.\n\n            * Key: name of the hyperparameter.\n            * Value: value of this hyperparamter\n\n        configuration_space:\n            The defined configuration space. It is necessary to find the inactive\n            hyperparameters by iterating through the conditions of the configuration space.\n        vector:\n            fficient represantation of a configuration. Either `configuration` or\n            `vector` must be specified. If both are specified only\n            `configuration` will be used.\n\n    Returns:\n        A configuration that is equivalent to the given configuration, except\n        that inactivate hyperparameters have been removed.\n    \"\"\"\n    space = configuration_space\n    hyperparameters = list(space.values())\n    config = Configuration(\n        configuration_space=configuration_space,\n        values=configuration,\n        vector=vector,\n        allow_inactive_with_values=True,\n    )\n\n    hps: deque[Hyperparameter] = deque()\n    hps.extendleft(\n        [\n            space[hp]\n            for hp in space.unconditional_hyperparameters\n            if len(space.children_of[hp]) &gt; 0\n        ],\n    )\n\n    inactive = set()\n\n    while len(hps) &gt; 0:\n        hp = hps.pop()\n        for child in space.children_of[hp.name]:\n            for condition in space.parent_conditions_of[child.name]:\n                if not condition.satisfied_by_vector(config.get_array()):\n                    dic = dict(config)\n                    try:\n                        del dic[child.name]\n                    except KeyError:\n                        continue\n\n                    config = Configuration(\n                        configuration_space=space,\n                        values=dic,\n                        allow_inactive_with_values=True,\n                    )\n                    inactive.add(child.name)\n                hps.appendleft(child)\n\n    for hp in hyperparameters:\n        if hp.name in inactive:\n            dic = dict(config)\n            try:\n                del dic[hp.name]\n            except KeyError:\n                continue\n            config = Configuration(\n                configuration_space=configuration_space,\n                values=dic,\n                allow_inactive_with_values=True,\n            )\n\n    return Configuration(configuration_space, values=dict(config))\n</code></pre>"},{"location":"api/ConfigSpace/util/#ConfigSpace.util.fix_types","title":"fix_types","text":"<pre><code>fix_types(\n    configuration: dict[str, Any],\n    configuration_space: ConfigurationSpace,\n) -&gt; dict[str, Any]\n</code></pre> <p>Iterate over all hyperparameters in the ConfigSpace and fix the types of the parameter values in configuration.</p> <p>configuration:     A configuration as a dictionary.</p> <pre><code>* Key: name of the hyperparameter.\n* Value: value of this hyperparamter\n</code></pre> configuration_space <p>Configuration space which knows the types for all parameter values</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Configuration with fixed types of parameter values</p> Source code in <code>src/ConfigSpace/util.py</code> <pre><code>def fix_types(\n    configuration: dict[str, Any],\n    configuration_space: ConfigurationSpace,\n) -&gt; dict[str, Any]:\n    \"\"\"Iterate over all hyperparameters in the ConfigSpace\n    and fix the types of the parameter values in configuration.\n\n    Args:\n    configuration:\n        A configuration as a dictionary.\n\n        * Key: name of the hyperparameter.\n        * Value: value of this hyperparamter\n\n    configuration_space:\n        Configuration space which knows the types for all parameter values\n\n    Returns:\n        Configuration with fixed types of parameter values\n    \"\"\"\n\n    def fix_type_from_candidates(value: Any, candidates: Sequence[Any]) -&gt; Any:\n        result = [c for c in candidates if str(value) == str(c)]\n        if len(result) != 1:\n            raise ValueError(\n                f\"Parameter value {value} cannot be matched to candidates {candidates}.\"\n                \" Either none or too many matching candidates.\",\n            )\n        return result[0]\n\n    for param in configuration_space.values():\n        param_name = param.name\n        if configuration.get(param_name) is not None:\n            if isinstance(param, (CategoricalHyperparameter)):\n                configuration[param_name] = fix_type_from_candidates(\n                    configuration[param_name],\n                    param.choices,\n                )\n            elif isinstance(param, (OrdinalHyperparameter)):\n                configuration[param_name] = fix_type_from_candidates(\n                    configuration[param_name],\n                    param.sequence,\n                )\n            elif isinstance(param, Constant):\n                configuration[param_name] = fix_type_from_candidates(\n                    configuration[param_name],\n                    [param.value],\n                )\n            elif isinstance(param, UniformFloatHyperparameter):\n                configuration[param_name] = float(configuration[param_name])\n            elif isinstance(param, UniformIntegerHyperparameter):\n                configuration[param_name] = int(configuration[param_name])\n            else:\n                raise TypeError(f\"Unknown hyperparameter type {type(param)}\")\n    return configuration\n</code></pre>"},{"location":"api/ConfigSpace/util/#ConfigSpace.util.generate_grid","title":"generate_grid","text":"<pre><code>generate_grid(\n    configuration_space: ConfigurationSpace,\n    num_steps_dict: dict[str, int] | None = None,\n) -&gt; list[Configuration]\n</code></pre> <p>Generates a grid of Configurations for a given ConfigurationSpace. Can be used, for example, for grid search.</p> <p>configuration_spac:     The Configuration space over which to create a grid of HyperParameter     Configuration values. It knows the types for all parameter values.</p> num_steps_dic <p>A dict containing the number of points to divide the grid side formed by Hyperparameters which are either of type UniformFloatHyperparameter or type UniformIntegerHyperparameter. The keys in the dict should be the names of the corresponding Hyperparameters and the values should be the number of points to divide the grid side formed by the corresponding Hyperparameter in to.</p> RETURNS DESCRIPTION <code>list[Configuration]</code> <p>List containing Configurations. It is a cartesian product of tuples of HyperParameter values. Each tuple lists the possible values taken by the corresponding HyperParameter. Within the cartesian product, in each element, the ordering of HyperParameters is the same for the OrderedDict within the ConfigurationSpace.</p> Source code in <code>src/ConfigSpace/util.py</code> <pre><code>def generate_grid(\n    configuration_space: ConfigurationSpace,\n    num_steps_dict: dict[str, int] | None = None,\n) -&gt; list[Configuration]:\n    \"\"\"Generates a grid of Configurations for a given ConfigurationSpace.\n    Can be used, for example, for grid search.\n\n    Args:\n    configuration_spac:\n        The Configuration space over which to create a grid of HyperParameter\n        Configuration values. It knows the types for all parameter values.\n\n    num_steps_dic:\n        A dict containing the number of points to divide the grid side formed by\n        Hyperparameters which are either of type UniformFloatHyperparameter or\n        type UniformIntegerHyperparameter. The keys in the dict should be the names\n        of the corresponding Hyperparameters and the values should be the number of\n        points to divide the grid side formed by the corresponding Hyperparameter in to.\n\n    Returns:\n        List containing Configurations. It is a cartesian product of tuples\n        of HyperParameter values.\n        Each tuple lists the possible values taken by the corresponding HyperParameter.\n        Within the cartesian product, in each element, the ordering of HyperParameters\n        is the same for the OrderedDict within the ConfigurationSpace.\n    \"\"\"\n\n    def _get_value_set(num_steps_dict: dict[str, int] | None, hp_name: str) -&gt; tuple:\n        param = configuration_space[hp_name]\n        if isinstance(param, (CategoricalHyperparameter)):\n            return cast(tuple, param.choices)\n\n        if isinstance(param, (OrdinalHyperparameter)):\n            return cast(tuple, param.sequence)\n\n        if isinstance(param, Constant):\n            return (param.value,)\n\n        if isinstance(param, UniformFloatHyperparameter):\n            if param.log:\n                lower, upper = np.log([param.lower, param.upper])\n            else:\n                lower, upper = param.lower, param.upper\n\n            if num_steps_dict is not None and param.name in num_steps_dict:\n                num_steps = num_steps_dict[param.name]\n                grid_points = np.linspace(lower, upper, num_steps)\n            else:\n                raise ValueError(\n                    \"num_steps_dict is None or doesn't contain the number of points\"\n                    f\" to divide {param.name} into. And its quantization factor \"\n                    \"is None. Please provide/set one of these values.\",\n                )\n\n            if param.log:\n                grid_points = np.exp(grid_points)\n\n            # Avoiding rounding off issues\n            if grid_points[0] &lt; param.lower:\n                grid_points[0] = param.lower\n            if grid_points[-1] &gt; param.upper:\n                grid_points[-1] = param.upper\n\n            return tuple(grid_points)\n\n        if isinstance(param, UniformIntegerHyperparameter):\n            if param.log:\n                lower, upper = np.log([param.lower, param.upper])\n            else:\n                lower, upper = param.lower, param.upper\n\n            if num_steps_dict is not None and param.name in num_steps_dict:\n                num_steps = num_steps_dict[param.name]\n                grid_points = np.linspace(lower, upper, num_steps)\n            else:\n                raise ValueError(\n                    \"num_steps_dict is None or doesn't contain the number of points \"\n                    f\"to divide {param.name} into. And its quantization factor \"\n                    \"is None. Please provide/set one of these values.\",\n                )\n\n            if param.log:\n                grid_points = np.exp(grid_points)\n            grid_points = np.round(grid_points).astype(int)\n\n            # Avoiding rounding off issues\n            if grid_points[0] &lt; param.lower:\n                grid_points[0] = param.lower\n            if grid_points[-1] &gt; param.upper:\n                grid_points[-1] = param.upper\n\n            return tuple(grid_points)\n\n        raise TypeError(f\"Unknown hyperparameter type {type(param)}\")\n\n    def _get_cartesian_product(\n        value_sets: list[tuple],\n        hp_names: list[str],\n    ) -&gt; list[dict[str, Any]]:\n        import itertools\n\n        if len(value_sets) == 0:\n            # Edge case\n            return []\n\n        grid = []\n        for element in itertools.product(*value_sets):\n            config_dict = dict(zip(hp_names, element))\n            grid.append(config_dict)\n\n        return grid\n\n    # Each tuple within is the grid values to be taken on by a Hyperparameter\n    value_sets = []\n    hp_names = []\n\n    # Get HP names and allowed grid values they can take for the HPs at the top\n    # level of ConfigSpace tree\n    for hp_name in configuration_space.unconditional_hyperparameters:\n        value_sets.append(_get_value_set(num_steps_dict, hp_name))\n        hp_names.append(hp_name)\n\n    # Create a Cartesian product of above allowed values for the HPs. Hold them in an\n    # \"unchecked\" deque because some of the conditionally dependent HPs may become\n    # active for some of the elements of the Cartesian product and in these cases\n    # creating a Configuration would throw an Error (see below).\n    # Creates a deque of Configuration dicts\n    unchecked_grid_pts = deque(_get_cartesian_product(value_sets, hp_names))\n    checked_grid_pts = []\n\n    while len(unchecked_grid_pts) &gt; 0:\n        try:\n            grid_point = Configuration(\n                configuration_space,\n                values=unchecked_grid_pts[0],\n            )\n            checked_grid_pts.append(grid_point)\n\n        # When creating a configuration that violates a forbidden clause, simply skip it\n        except ForbiddenValueError:\n            unchecked_grid_pts.popleft()\n            continue\n\n        except ActiveHyperparameterNotSetError:\n            value_sets = []\n            hp_names = []\n            new_active_hp_names = []\n\n            # \"for\" loop over currently active HP names\n            for hp_name in unchecked_grid_pts[0]:\n                value_sets.append((unchecked_grid_pts[0][hp_name],))\n                hp_names.append(hp_name)\n                # Checks if the conditionally dependent children of already active\n                # HPs are now active\n                # TODO: Shorten this\n                for new_hp_name in configuration_space._dag.nodes[hp_name].children:\n                    if (\n                        new_hp_name not in new_active_hp_names\n                        and new_hp_name not in unchecked_grid_pts[0]\n                    ):\n                        all_cond_ = True\n                        for cond in configuration_space.parent_conditions_of[\n                            new_hp_name\n                        ]:\n                            if not cond.satisfied_by_value(unchecked_grid_pts[0]):\n                                all_cond_ = False\n                        if all_cond_:\n                            new_active_hp_names.append(new_hp_name)\n\n            for hp_name in new_active_hp_names:\n                value_sets.append(_get_value_set(num_steps_dict, hp_name))\n                hp_names.append(hp_name)\n\n            # this check might not be needed, as there is always going to be a new\n            # active HP when in this except block?\n            if len(new_active_hp_names) &lt;= 0:\n                raise RuntimeError(\n                    \"Unexpected error: There should have been a newly activated\"\n                    \" hyperparameter for the current configuration values:\"\n                    f\" {unchecked_grid_pts[0]!s}. Please contact the developers with\"\n                    \" the code you ran and the stack trace.\",\n                ) from None\n\n            new_conditonal_grid = _get_cartesian_product(value_sets, hp_names)\n            unchecked_grid_pts += new_conditonal_grid\n        unchecked_grid_pts.popleft()\n\n    return checked_grid_pts\n</code></pre>"},{"location":"api/ConfigSpace/util/#ConfigSpace.util.get_one_exchange_neighbourhood","title":"get_one_exchange_neighbourhood","text":"<pre><code>get_one_exchange_neighbourhood(\n    configuration: Configuration,\n    seed: int | RandomState,\n    num_neighbors: int = 4,\n    stdev: float = 0.2,\n) -&gt; Iterator[Configuration]\n</code></pre> <p>Return all configurations in a one-exchange neighborhood.</p> <p>The method is implemented as defined by: Frank Hutter, Holger H. Hoos and Kevin Leyton-Brown Sequential Model-Based Optimization for General Algorithm Configuration In Proceedings of the conference on Learning and Intelligent Optimization(LION 5)</p> PARAMETER DESCRIPTION <code>configuration</code> <p>for this Configuration object <code>num_neighbors</code> neighbors are computed</p> <p> TYPE: <code>Configuration</code> </p> <code>seed</code> <p>Sets the random seed to a fixed value</p> <p> TYPE: <code>int | RandomState</code> </p> <code>num_neighbors</code> <p>number of configurations, which are sampled from the neighbourhood of the input configuration</p> <p> TYPE: <code>int</code> DEFAULT: <code>4</code> </p> <code>stdev</code> <p>The standard deviation is used to determine the neigbours of hyperparameters which are continuous/integer</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.2</code> </p> RETURNS DESCRIPTION <code>Iterator[Configuration]</code> <p>It contains configurations, with values being situated around the given configuration.</p> Source code in <code>src/ConfigSpace/util.py</code> <pre><code>def get_one_exchange_neighbourhood(\n    configuration: Configuration,\n    seed: int | np.random.RandomState,\n    num_neighbors: int = 4,\n    stdev: float = 0.2,\n) -&gt; Iterator[Configuration]:\n    \"\"\"Return all configurations in a one-exchange neighborhood.\n\n    The method is implemented as defined by:\n    Frank Hutter, Holger H. Hoos and Kevin Leyton-Brown\n    Sequential Model-Based Optimization for General Algorithm Configuration\n    In Proceedings of the conference on Learning and Intelligent\n    Optimization(LION 5)\n\n    Args:\n        configuration: for this Configuration object `num_neighbors` neighbors\n            are computed\n        seed: Sets the random seed to a fixed value\n        num_neighbors: number of configurations, which are sampled from\n            the neighbourhood of the input configuration\n        stdev: The standard deviation is used to determine the neigbours of\n            hyperparameters which are continuous/integer\n\n    Returns:\n         It contains configurations, with values being situated around\n         the given configuration.\n\n    \"\"\"\n    OVER_SAMPLE_CONTINUOUS_MULT = 5\n    space = configuration.config_space\n    config = configuration\n    arr = configuration._vector\n    dag = space._dag\n\n    # neighbor_sample_size: How many neighbors we should sample for a given\n    #   hyperparameter at once.\n    # max_iter_per_selection: How many times we loop trying to generate a valid\n    #   configuration with a given hyperparameter, every time it gets sampled. If\n    #   not a single valid configuration is generated in this many iterations, it's\n    #   marked as failed.\n    # std: The standard deviation to use for the neighborhood of a hyperparameter when\n    #   sampling neighbors.\n    # should_shuffle: Whether or not we should shuffle the neighbors of a hyperparameter\n    #   once generated\n    # generated: Whether or not we have already generated the neighbors for this\n    #   hyperparameter, set to false until sampled.\n    # should_regen: Whether or not we should regenerate more neighbors for this\n    #   hyperparameter at all.\n    # -&gt; dict[HP, (neighbor_sample_size, std, should_shuffle, generated, should_regen)]\n    sample_strategy: dict[str, tuple[int, int, float | None, bool, bool, bool]] = {}\n\n    # n_to_gen: Per hyperparameter, how many configurations we should generate with this\n    #   hyperparameter as the one where the values change.\n    # neighbors_generated_for_hp: The neighbors that were generated for this hp that can\n    #   be retrieved.\n    # -&gt; tuple[HP, hp_idx, n_to_gen, neighbors_generated_for_hp]\n    neighbors_to_generate: list[tuple[Hyperparameter, int, int, list[f64]]] = []\n\n    nan_hps = np.isnan(arr)\n    UFH = UniformFloatHyperparameter\n    UIH = UniformIntegerHyperparameter\n    n_randints_to_gen = 0\n    for hp_name, node in dag.nodes.items():\n        hp = node.hp\n        hp_idx = node.idx\n\n        # inactive hyperparameters skipped\n        # hps with a size of one can't be modified to a neighbor\n        # This catches Constants, single value categoricals and ordinals (ints?)\n        if hp.size == 1 or nan_hps[hp_idx]:\n            continue\n\n        if isinstance(hp, CategoricalHyperparameter):\n            neighbor_sample_size = hp.size - 1\n            # NOTE: We ignore argument `num_neighbors` for Categoricals,\n            # don't know why\n            n_to_gen = neighbor_sample_size\n            max_iter_per_selection = neighbor_sample_size\n            _std = None\n            should_shuffle = True\n            should_regen = False\n        elif isinstance(hp, OrdinalHyperparameter):\n            neighbor_sample_size = int(hp.get_num_neighbors(config[hp_name]))\n            # NOTE: We can only generate maximum 2 neighbors for Ordinals\n            # so we just generate all possible ones.\n            _std = None\n            n_to_gen = neighbor_sample_size\n            max_iter_per_selection = neighbor_sample_size\n            should_shuffle = True\n            should_regen = False\n        elif np.isinf(hp.size):  # All continuous ones\n            # We can oversample here as there are an infinite number of unique neighbors\n            # by oversampling, we can hopefully avoid regeneration of neighbors.\n            neighbor_sample_size = num_neighbors * OVER_SAMPLE_CONTINUOUS_MULT\n            n_to_gen = num_neighbors\n            # NOTE: Not sure it should be this high without increasing the std of\n            # neighborhood sampling.\n            max_iter_per_selection = max(neighbor_sample_size, 100)\n            _std = stdev if isinstance(hp, UFH) else None\n            should_shuffle = False\n            should_regen = True\n        else:  # All non-continuous ones\n            # We don't want to over sample a finite hyperparameter as by specifying\n            # a large number of neighbors, we end up sampling the entire hyperparameter\n            # range, not just it's immediate neighbors.\n            _possible_neighbors = int(hp.size - 1)\n            neighbor_sample_size = int(min(num_neighbors, _possible_neighbors))\n            n_to_gen = num_neighbors\n            # NOTE: Not sure it should be this high without increasing the std of\n            # neighborhood sampling.\n            max_iter_per_selection = neighbor_sample_size\n            _std = stdev if isinstance(hp, UIH) else None\n            should_shuffle = True\n            should_regen = _possible_neighbors &gt;= num_neighbors\n\n        n_forbiddens_on_hp = len(dag.forbidden_lookup.get(hp_name, []))\n        hueristic_multiplier = 1 + np.sqrt(n_forbiddens_on_hp)\n        n_randints_to_gen += int(n_to_gen * hueristic_multiplier)\n\n        generated = False\n        sample_strategy[hp_name] = (\n            neighbor_sample_size,\n            max_iter_per_selection,\n            _std,\n            should_shuffle,\n            generated,\n            should_regen,\n        )\n        neighbors_to_generate.append((hp, hp_idx, n_to_gen, []))\n\n    random = np.random.RandomState(seed) if isinstance(seed, int) else seed\n\n    arr = config.get_array()\n\n    assert not any(n_to_gen == 0 for _, _, n_to_gen, _ in neighbors_to_generate)\n\n    # Generate some random integers based on the number of neighbors\n    # we need to generate and number of forbiddens\n    n_hps = len(neighbors_to_generate)\n    integers = random.randint(n_hps, size=n_randints_to_gen).tolist()\n    _randint_idx = 0\n\n    # Keep looping until we have used all hyperparameters\n    n_hps_left_to_exhuast = n_hps\n    while n_hps_left_to_exhuast &gt; 0:\n        # Our random int's ran out, make more\n        if _randint_idx &gt;= n_randints_to_gen:\n            # If we got here, we don't need to generate so many more new ones\n            n_randints_to_gen = len(neighbors_to_generate) * n_hps * 2\n            integers = random.randint(n_hps, size=n_randints_to_gen).tolist()\n            _randint_idx = 0\n\n        chosen_hp_idx: int = integers[_randint_idx]\n        _randint_idx += 1\n\n        hp, hp_idx, n_left, neighbors = neighbors_to_generate[chosen_hp_idx]\n        hp_name = hp.name\n\n        if n_left == 0:\n            continue\n\n        neighbor_config: Configuration | None = None\n\n        (\n            neighbor_sample_size,\n            max_iter_per_selection,\n            _std,\n            _should_shuffle,\n            _generated,\n            _should_regen,\n        ) = sample_strategy[hp_name]\n\n        for _ in range(max_iter_per_selection):\n            # Generate neighbors if we don't have any for this hp.\n            if len(neighbors) == 0:\n                # All possible neighbors of the hp were generated before and were\n                # exhausted, no point in trying it again...\n                if _generated and not _should_regen:\n                    n_hps_left_to_exhuast -= 1\n                    neighbors_to_generate[chosen_hp_idx] = (hp, hp_idx, 0, neighbors)\n                    break\n\n                # We should never resample something that has already had all it's\n                # neighbors sampled.\n                vec = arr[hp_idx]\n                _neighbors = hp._neighborhood(\n                    vec,\n                    n=neighbor_sample_size,\n                    seed=random,\n                    std=_std,\n                )\n\n                # Inf sized hp's are already basically shuffled. This is more for\n                # finite hps which may give a linear ordering of neighbors...\n                if _should_shuffle:\n                    random.shuffle(_neighbors)\n\n                neighbors = _neighbors.tolist()\n                neighbors_to_generate[chosen_hp_idx] = (hp, hp_idx, n_left, neighbors)\n\n                # Update to say it's been `generated`\n                sample_strategy[hp_name] = (\n                    neighbor_sample_size,\n                    max_iter_per_selection,\n                    _std,\n                    _should_shuffle,\n                    True,  # generated\n                    _should_regen,\n                )\n\n            neighbor_vector_val = neighbors.pop()\n\n            new_arr = change_hp_value(\n                configuration_space=space,\n                configuration_array=arr.copy(),\n                hp_name=hp_name,\n                hp_value=neighbor_vector_val,\n                index=hp_idx,\n            )\n\n            is_valid = True\n            for forbidden in space._dag.forbidden_lookup.get(hp_name, []):\n                if forbidden.is_forbidden_vector(new_arr):\n                    is_valid = False\n                    break\n\n            if not is_valid:  # Next retry\n                continue\n\n            # If we manager to not have a forbidden, we can yield the configuration\n            # and mark there's one less configuration needed to generate for this hp\n            neighbor_config = Configuration(space, vector=new_arr)\n            one_less = n_left - 1\n            neighbors_to_generate[chosen_hp_idx] = (hp, hp_idx, one_less, neighbors)\n            if one_less == 0:\n                n_hps_left_to_exhuast -= 1\n\n            yield neighbor_config\n            break  # Break out of the outer for loop\n\n        else:\n            # Never broke out of the retry loop, so we mark the hp as failed, moving on\n            n_hps_left_to_exhuast -= 1\n            neighbors_to_generate[chosen_hp_idx] = (hp, hp_idx, 0, neighbors)\n</code></pre>"},{"location":"api/ConfigSpace/util/#ConfigSpace.util.get_random_neighbor","title":"get_random_neighbor","text":"<pre><code>get_random_neighbor(\n    configuration: Configuration, seed: int\n) -&gt; Configuration\n</code></pre> <p>Draw a random neighbor by changing one parameter of a configuration.</p> <ul> <li>If the parameter is categorical, it changes it to another value.</li> <li>If the parameter is ordinal, it changes it to the next higher or   lower value.</li> <li>If parameter is a float, draw a random sample</li> </ul> <p>If changing a parameter activates new parameters or deactivates previously active parameters, the configuration will be rejected. If more than 10000 configurations were rejected, this function raises a ValueError.</p> PARAMETER DESCRIPTION <code>configuration</code> <p>a configuration for which a random neigbour is calculated</p> <p> TYPE: <code>Configuration</code> </p> <code>seed</code> <p>Used to generate a random state.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Configuration</code> <p>The new neighbor</p> Source code in <code>src/ConfigSpace/util.py</code> <pre><code>def get_random_neighbor(configuration: Configuration, seed: int) -&gt; Configuration:\n    \"\"\"Draw a random neighbor by changing one parameter of a configuration.\n\n    - If the parameter is categorical, it changes it to another value.\n    - If the parameter is ordinal, it changes it to the next higher or\n      lower value.\n    - If parameter is a float, draw a random sample\n\n    If changing a parameter activates new parameters or deactivates\n    previously active parameters, the configuration will be rejected. If more\n    than 10000 configurations were rejected, this function raises a\n    ValueError.\n\n    Args:\n        configuration: a configuration for which a random neigbour is calculated\n        seed: Used to generate a random state.\n\n    Returns:\n        The new neighbor\n\n    \"\"\"\n    random = np.random.RandomState(seed)\n    rejected = True\n    values = copy.deepcopy(dict(configuration))\n    new_configuration = None\n\n    if configuration.config_space.estimate_size() &lt;= 1:\n        raise NoPossibleNeighborsError(\n            \"Cannot generate a random neighbor for a configuration space with\"\n            \" only one configuration.\"\n            f\"\\n{configuration.config_space}\",\n        )\n\n    while rejected:\n        # First, choose an active hyperparameter\n        active = False\n        iteration = 0\n        hp: Hyperparameter | None = None\n        value = None\n        while not active:\n            iteration += 1\n            rand_idx = (\n                random.randint(0, len(configuration)) if len(configuration) &gt; 1 else 0\n            )\n\n            value = configuration.get_array()[rand_idx]\n            if np.isfinite(value):\n                active = True\n\n                hp_name = configuration.config_space.at[rand_idx]\n                hp = configuration.config_space[hp_name]\n\n                # Only choose if there is a possibility of finding a neigboor\n                if hp.size &lt;= 1:\n                    active = False\n\n            if iteration &gt; 10000:\n                raise ValueError(\"Probably caught in an infinite loop.\")\n\n        assert hp is not None\n        assert value is not None\n\n        # Get a neighboor and adapt the rest of the configuration if necessary\n        neighbor = hp.to_value(vector=hp.neighbors_vectorized(value, n=1, seed=random))[\n            0\n        ]\n        previous_value = values[hp.name]\n        values[hp.name] = neighbor\n\n        try:\n            new_configuration = Configuration(configuration.config_space, values=values)\n            rejected = False\n        except ValueError:\n            values[hp.name] = previous_value\n\n    assert new_configuration is not None\n    return new_configuration\n</code></pre>"},{"location":"api/ConfigSpace/util/#ConfigSpace.util.impute_inactive_values","title":"impute_inactive_values","text":"<pre><code>impute_inactive_values(\n    configuration: Configuration,\n    strategy: str | float = \"default\",\n) -&gt; Configuration\n</code></pre> <p>Impute inactive parameters.</p> <p>Iterate through the hyperparameters of a <code>Configuration</code> and set the values of the inactive hyperparamters to their default values if the choosen <code>strategy</code> is 'default'. Otherwise <code>strategy</code> contains a float number. Set the hyperparameters' value to this number.</p> PARAMETER DESCRIPTION <code>configuration</code> <p>For this configuration inactive values will be imputed.</p> <p> TYPE: <code>Configuration</code> </p> <code>strategy</code> <p>The imputation strategy. Defaults to 'default' If 'default', replace inactive parameters by their default. If float, replace inactive parameters by the given float value, which should be able to be splitted apart by a tree-based model.</p> <p> TYPE: <code>str | float</code> DEFAULT: <code>'default'</code> </p> RETURNS DESCRIPTION <code>Configuration</code> <p>A new configuration with the imputed values. In this new configuration inactive values are included.</p> Source code in <code>src/ConfigSpace/util.py</code> <pre><code>def impute_inactive_values(\n    configuration: Configuration,\n    strategy: str | float = \"default\",\n) -&gt; Configuration:\n    \"\"\"Impute inactive parameters.\n\n    Iterate through the hyperparameters of a `Configuration` and set the\n    values of the inactive hyperparamters to their default values if the choosen\n    `strategy` is 'default'. Otherwise `strategy` contains a float number.\n    Set the hyperparameters' value to this number.\n\n\n    Args:\n        configuration: For this configuration inactive values will be imputed.\n        strategy:\n            The imputation strategy. Defaults to 'default'\n            If 'default', replace inactive parameters by their default.\n            If float, replace inactive parameters by the given float value,\n            which should be able to be splitted apart by a tree-based model.\n\n    Returns:\n        A new configuration with the imputed values. In this new configuration\n        inactive values are included.\n    \"\"\"\n    values = {}\n    for hp in configuration.config_space.values():\n        value = configuration.get(hp.name, NotSet)\n        if value is NotSet:\n            if strategy == \"default\":\n                new_value = hp.default_value\n\n            elif isinstance(strategy, float):\n                new_value = strategy\n\n            else:\n                raise ValueError(f\"Unknown imputation strategy {strategy}\")\n\n            value = new_value\n\n        values[hp.name] = value\n\n    return Configuration(\n        configuration.config_space,\n        values=values,\n        allow_inactive_with_values=True,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/api/distributions/","title":"Distributions","text":""},{"location":"api/ConfigSpace/api/distributions/#ConfigSpace.api.distributions","title":"ConfigSpace.api.distributions","text":""},{"location":"api/ConfigSpace/api/distributions/#ConfigSpace.api.distributions.Beta","title":"Beta  <code>dataclass</code>","text":"<pre><code>Beta(alpha: float, beta: float)\n</code></pre> <p>               Bases: <code>Distribution</code></p> <p>Represents a beta distribution.</p> ATTRIBUTE DESCRIPTION <code>alpha</code> <p>The alpha parameter of a beta distribution</p> <p> TYPE: <code>float</code> </p> <code>beta</code> <p>The beta parameter of a beta distribution</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/ConfigSpace/api/distributions/#ConfigSpace.api.distributions.Distribution","title":"Distribution  <code>dataclass</code>","text":"<pre><code>Distribution()\n</code></pre> <p>Base distribution type.</p>"},{"location":"api/ConfigSpace/api/distributions/#ConfigSpace.api.distributions.Normal","title":"Normal  <code>dataclass</code>","text":"<pre><code>Normal(mu: float, sigma: float)\n</code></pre> <p>               Bases: <code>Distribution</code></p> <p>Represents a normal distribution.</p> ATTRIBUTE DESCRIPTION <code>mu</code> <p>The mean of the distribution</p> <p> TYPE: <code>float</code> </p> <code>sigma</code> <p>The standard deviation of the float</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/ConfigSpace/api/distributions/#ConfigSpace.api.distributions.Uniform","title":"Uniform  <code>dataclass</code>","text":"<pre><code>Uniform()\n</code></pre> <p>               Bases: <code>Distribution</code></p> <p>A uniform distribution.</p>"},{"location":"api/ConfigSpace/api/types/categorical/","title":"Categorical","text":""},{"location":"api/ConfigSpace/api/types/categorical/#ConfigSpace.api.types.categorical","title":"ConfigSpace.api.types.categorical","text":""},{"location":"api/ConfigSpace/api/types/categorical/#ConfigSpace.api.types.categorical.Categorical","title":"Categorical","text":"<pre><code>Categorical(\n    name: str,\n    items: Sequence[T],\n    *,\n    default: T | _NotSet = NotSet,\n    weights: Sequence[float] | None = None,\n    ordered: bool = False,\n    meta: dict | None = None\n) -&gt; CategoricalHyperparameter | OrdinalHyperparameter\n</code></pre> <p>Creates a Categorical Hyperparameter.</p> <p>CategoricalHyperparameter's can be used to represent a discrete choice. Optionally, you can specify that these values are also ordered in some manner, e.g. <code>[\"small\", \"medium\", \"large\"]</code>.</p> <pre><code># A simple categorical hyperparameter\nc = Categorical(\"animals\", [\"cat\", \"dog\", \"mouse\"])\n\n# With a default\nc = Categorical(\"animals\", [\"cat\", \"dog\", \"mouse\"], default=\"mouse\")\n\n# Make them weighted\nc = Categorical(\"animals\", [\"cat\", \"dog\", \"mouse\"], weights=[0.1, 0.8, 3.14])\n\n# Specify it's an OrdinalHyperparameter (ordered categories)\n# ... note that you can't apply weights to an Ordinal\no = Categorical(\"size\", [\"small\", \"medium\", \"large\"], ordered=True)\n\n# Add some meta information for your own tracking\nc = Categorical(\"animals\", [\"cat\", \"dog\", \"mouse\"], meta={\"use\": \"Favourite Animal\"})\n</code></pre> <p>Note</p> <p><code>Categorical</code> is actually a function, please use the corresponding return types if doing an <code>isinstance(param, type)</code> check with either <code>CategoricalHyperparameter</code> and/or <code>OrdinalHyperparameter</code>.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the hyperparameter</p> <p> TYPE: <code>str</code> </p> <code>items</code> <p>A list of items to put in the category.</p> <p>Warning</p> <p>Can't have duplicate categories, use weights if required.</p> <p> TYPE: <code>Sequence[T]</code> </p> <code>default</code> <p>The default value of the categorical hyperparameter.</p> <p> TYPE: <code>T | _NotSet</code> DEFAULT: <code>NotSet</code> </p> <code>weights</code> <p>The weights to apply to each categorical. Each item will be sampled according to these weights.</p> <p> TYPE: <code>Sequence[float] | None</code> DEFAULT: <code>None</code> </p> <code>ordered</code> <p>Whether the categorical is ordered or not. If <code>True</code>, this will return an <code>OrdinalHyperparameter</code>, otherwise it remain a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>meta</code> <p>Any additional meta information you would like to store along with the hyperparamter.</p> <p> TYPE: <code>dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/ConfigSpace/api/types/categorical.py</code> <pre><code>def Categorical(\n    name: str,\n    items: Sequence[T],\n    *,\n    default: T | _NotSet = NotSet,\n    weights: Sequence[float] | None = None,\n    ordered: bool = False,\n    meta: dict | None = None,\n) -&gt; CategoricalHyperparameter | OrdinalHyperparameter:\n    \"\"\"Creates a Categorical Hyperparameter.\n\n    CategoricalHyperparameter's can be used to represent a discrete\n    choice. Optionally, you can specify that these values are also ordered in\n    some manner, e.g. `#!python [\"small\", \"medium\", \"large\"]`.\n\n    ```python\n    # A simple categorical hyperparameter\n    c = Categorical(\"animals\", [\"cat\", \"dog\", \"mouse\"])\n\n    # With a default\n    c = Categorical(\"animals\", [\"cat\", \"dog\", \"mouse\"], default=\"mouse\")\n\n    # Make them weighted\n    c = Categorical(\"animals\", [\"cat\", \"dog\", \"mouse\"], weights=[0.1, 0.8, 3.14])\n\n    # Specify it's an OrdinalHyperparameter (ordered categories)\n    # ... note that you can't apply weights to an Ordinal\n    o = Categorical(\"size\", [\"small\", \"medium\", \"large\"], ordered=True)\n\n    # Add some meta information for your own tracking\n    c = Categorical(\"animals\", [\"cat\", \"dog\", \"mouse\"], meta={\"use\": \"Favourite Animal\"})\n    ```\n\n    !!! note\n\n        `Categorical` is actually a function, please use the corresponding return types if\n        doing an `isinstance(param, type)` check with either\n        [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter]\n        and/or [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter].\n\n    Args:\n        name: The name of the hyperparameter\n        items:\n            A list of items to put in the category.\n\n            !!! warning\n\n                Can't have duplicate categories, use weights if required.\n\n        default: The default value of the categorical hyperparameter.\n        weights:\n            The weights to apply to each categorical. Each item will be sampled according\n            to these weights.\n        ordered:\n            Whether the categorical is ordered or not. If `True`, this will return an\n            [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter],\n            otherwise it remain a\n            [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n        meta:\n            Any additional meta information you would like to store along with the\n            hyperparamter.\n    \"\"\"  # noqa: E501\n    if ordered and weights is not None:\n        raise ValueError(\"Can't apply `weights` to `ordered` Categorical\")\n\n    if ordered:\n        return OrdinalHyperparameter(\n            name=name,\n            sequence=items,\n            default_value=default,\n            meta=meta,\n        )\n\n    return CategoricalHyperparameter(\n        name=name,\n        choices=items,\n        default_value=default,\n        weights=weights,\n        meta=meta,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/api/types/float/","title":"Float","text":""},{"location":"api/ConfigSpace/api/types/float/#ConfigSpace.api.types.float","title":"ConfigSpace.api.types.float","text":""},{"location":"api/ConfigSpace/api/types/float/#ConfigSpace.api.types.float.Float","title":"Float","text":"<pre><code>Float(\n    name: str,\n    bounds: tuple[float, float],\n    *,\n    distribution: Distribution | None = None,\n    default: float | None = None,\n    log: bool = False,\n    meta: dict | None = None\n) -&gt; (\n    UniformFloatHyperparameter\n    | NormalFloatHyperparameter\n    | BetaFloatHyperparameter\n)\n</code></pre> <p>Create a FloatHyperparameter.</p> <pre><code># Uniformly distributed\nFloat(\"a\", (1, 10))\nFloat(\"a\", (1, 10), distribution=Uniform())\n\n# Normally distributed at 2 with std 3\nFloat(\"b\", (0, 5), distribution=Normal(2, 3))\n\n# Beta distributed with alpha 1 and beta 2\nFloat(\"c\", (0, 3), distribution=Beta(1, 2))\n\n# Give it a default value\nFloat(\"a\", (1, 10), default=4.3)\n\n# Sample on a log scale\nFloat(\"a\", (1, 100), log=True)\n\n# Add meta info to the param\nFloat(\"a\", (1.0, 10), meta={\"use\": \"For counting chickens\"})\n</code></pre> <p>Note</p> <p><code>Float</code> is actually a function, please use the corresponding return types if doing an <code>isinstance(param, type)</code> check and not <code>Float</code>.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name to give to this hyperparameter</p> <p> TYPE: <code>str</code> </p> <code>bounds</code> <p>The bounds to give to the float.</p> <p> TYPE: <code>tuple[float, float]</code> </p> <code>distribution</code> <p>The distribution to use for the hyperparameter. See above</p> <p> TYPE: <code>Distribution | None</code> DEFAULT: <code>None</code> </p> <code>default</code> <p>The default value to give to the hyperparameter.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>log</code> <p>Whether to this parameter lives on a log scale</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>meta</code> <p>Any meta information you want to associate with this parameter</p> <p> TYPE: <code>dict | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>UniformFloatHyperparameter | NormalFloatHyperparameter | BetaFloatHyperparameter</code> <p>Returns the corresponding hyperparameter type</p> Source code in <code>src/ConfigSpace/api/types/float.py</code> <pre><code>def Float(\n    name: str,\n    bounds: tuple[float, float],\n    *,\n    distribution: Distribution | None = None,\n    default: float | None = None,\n    log: bool = False,\n    meta: dict | None = None,\n) -&gt; UniformFloatHyperparameter | NormalFloatHyperparameter | BetaFloatHyperparameter:\n    \"\"\"Create a FloatHyperparameter.\n\n    ```python\n    # Uniformly distributed\n    Float(\"a\", (1, 10))\n    Float(\"a\", (1, 10), distribution=Uniform())\n\n    # Normally distributed at 2 with std 3\n    Float(\"b\", (0, 5), distribution=Normal(2, 3))\n\n    # Beta distributed with alpha 1 and beta 2\n    Float(\"c\", (0, 3), distribution=Beta(1, 2))\n\n    # Give it a default value\n    Float(\"a\", (1, 10), default=4.3)\n\n    # Sample on a log scale\n    Float(\"a\", (1, 100), log=True)\n\n    # Add meta info to the param\n    Float(\"a\", (1.0, 10), meta={\"use\": \"For counting chickens\"})\n    ```\n\n    !!! note\n\n        `Float` is actually a function, please use the corresponding return types if\n        doing an `isinstance(param, type)` check and not `Float`.\n\n    Args:\n        name:\n            The name to give to this hyperparameter\n\n        bounds:\n            The bounds to give to the float.\n\n        distribution:\n            The distribution to use for the hyperparameter. See above\n\n        default:\n            The default value to give to the hyperparameter.\n\n        log:\n            Whether to this parameter lives on a log scale\n\n        meta:\n            Any meta information you want to associate with this parameter\n\n    Returns:\n        Returns the corresponding hyperparameter type\n    \"\"\"\n    if distribution is None:\n        distribution = Uniform()\n\n    lower, upper = bounds\n\n    if isinstance(distribution, Uniform):\n        return UniformFloatHyperparameter(\n            name=name,\n            lower=lower,\n            upper=upper,\n            default_value=default,\n            log=log,\n            meta=meta,\n        )\n\n    if isinstance(distribution, Normal):\n        return NormalFloatHyperparameter(\n            name=name,\n            lower=lower,\n            upper=upper,\n            default_value=default,\n            mu=distribution.mu,\n            sigma=distribution.sigma,\n            log=log,\n            meta=meta,\n        )\n\n    if isinstance(distribution, Beta):\n        return BetaFloatHyperparameter(\n            name=name,\n            lower=lower,\n            upper=upper,\n            alpha=distribution.alpha,\n            beta=distribution.beta,\n            default_value=default,\n            log=log,\n            meta=meta,\n        )\n\n    raise ValueError(f\"Unknown distribution type {type(distribution)}\")\n</code></pre>"},{"location":"api/ConfigSpace/api/types/integer/","title":"Integer","text":""},{"location":"api/ConfigSpace/api/types/integer/#ConfigSpace.api.types.integer","title":"ConfigSpace.api.types.integer","text":""},{"location":"api/ConfigSpace/api/types/integer/#ConfigSpace.api.types.integer.Integer","title":"Integer","text":"<pre><code>Integer(\n    name: str,\n    bounds: tuple[int, int],\n    *,\n    distribution: Distribution | None = None,\n    default: int | None = None,\n    log: bool = False,\n    meta: dict | None = None\n) -&gt; (\n    UniformIntegerHyperparameter\n    | NormalIntegerHyperparameter\n    | BetaIntegerHyperparameter\n)\n</code></pre> <p>Create an IntegerHyperparameter.</p> <pre><code># Uniformly distributed\nInteger(\"a\", (1, 10))\nInteger(\"a\", (1, 10), distribution=Uniform())\n\n# Normally distributed at 2 with std 3\nInteger(\"b\", (0, 5), distribution=Normal(2, 3))\n\n# Beta distributed with alpha 1 and beta 2\nInteger(\"c\", (0, 3), distribution=Beta(1, 2))\n\n# Give it a default value\nInteger(\"a\", (1, 10), default=4)\n\n# Sample on a log scale\nInteger(\"a\", (1, 100), log=True)\n\n# Add meta info to the param\nInteger(\"a\", (1, 10), meta={\"use\": \"For counting chickens\"})\n</code></pre> <p>Note</p> <p><code>Integer</code> is actually a function, please use the corresponding return types if doing an <code>isinstance(param, type)</code> check and not <code>Integer</code>.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name to give to this hyperparameter</p> <p> TYPE: <code>str</code> </p> <code>bounds</code> <p>The bounds to give to the integer.</p> <p> TYPE: <code>tuple[int, int]</code> </p> <code>distribution</code> <p>The distribution to use for the hyperparameter. See above</p> <p> TYPE: <code>Distribution | None</code> DEFAULT: <code>None</code> </p> <code>default</code> <p>The default value to give to the hyperparameter.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>log</code> <p>Whether to this parameter lives on a log scale</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>meta</code> <p>Any meta information you want to associate with this parameter</p> <p> TYPE: <code>dict | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>UniformIntegerHyperparameter | NormalIntegerHyperparameter | BetaIntegerHyperparameter</code> <p>The corresponding hyperparameter type</p> Source code in <code>src/ConfigSpace/api/types/integer.py</code> <pre><code>def Integer(\n    name: str,\n    bounds: tuple[int, int],\n    *,\n    distribution: Distribution | None = None,\n    default: int | None = None,\n    log: bool = False,\n    meta: dict | None = None,\n) -&gt; (\n    UniformIntegerHyperparameter\n    | NormalIntegerHyperparameter\n    | BetaIntegerHyperparameter\n):\n    \"\"\"Create an IntegerHyperparameter.\n\n    ```python\n    # Uniformly distributed\n    Integer(\"a\", (1, 10))\n    Integer(\"a\", (1, 10), distribution=Uniform())\n\n    # Normally distributed at 2 with std 3\n    Integer(\"b\", (0, 5), distribution=Normal(2, 3))\n\n    # Beta distributed with alpha 1 and beta 2\n    Integer(\"c\", (0, 3), distribution=Beta(1, 2))\n\n    # Give it a default value\n    Integer(\"a\", (1, 10), default=4)\n\n    # Sample on a log scale\n    Integer(\"a\", (1, 100), log=True)\n\n    # Add meta info to the param\n    Integer(\"a\", (1, 10), meta={\"use\": \"For counting chickens\"})\n    ```\n\n    !!! note\n\n        `Integer` is actually a function, please use the corresponding return types if\n        doing an `isinstance(param, type)` check and not `Integer`.\n\n    Args:\n        name:\n            The name to give to this hyperparameter\n\n        bounds:\n            The bounds to give to the integer.\n\n        distribution:\n            The distribution to use for the hyperparameter. See above\n\n        default:\n            The default value to give to the hyperparameter.\n\n        log:\n            Whether to this parameter lives on a log scale\n\n        meta:\n            Any meta information you want to associate with this parameter\n\n    Returns:\n        The corresponding hyperparameter type\n    \"\"\"\n    if distribution is None:\n        distribution = Uniform()\n\n    if bounds is None and isinstance(distribution, Uniform):\n        raise ValueError(\"`bounds` must be specifed for Uniform distribution\")\n\n    lower, upper = bounds\n\n    if isinstance(distribution, Uniform):\n        return UniformIntegerHyperparameter(\n            name=name,\n            lower=lower,\n            upper=upper,\n            log=log,\n            default_value=default,\n            meta=meta,\n        )\n\n    if isinstance(distribution, Normal):\n        return NormalIntegerHyperparameter(\n            name=name,\n            lower=lower,\n            upper=upper,\n            log=log,\n            default_value=default,\n            meta=meta,\n            mu=distribution.mu,\n            sigma=distribution.sigma,\n        )\n\n    if isinstance(distribution, Beta):\n        return BetaIntegerHyperparameter(\n            name=name,\n            lower=lower,\n            upper=upper,\n            log=log,\n            default_value=default,\n            meta=meta,\n            alpha=distribution.alpha,\n            beta=distribution.beta,\n        )\n\n    raise ValueError(f\"Unknown distribution type {type(distribution)}\")\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/","title":"Beta float","text":""},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float","title":"ConfigSpace.hyperparameters.beta_float","text":""},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter","title":"BetaFloatHyperparameter  <code>dataclass</code>","text":"<pre><code>BetaFloatHyperparameter(\n    name: str,\n    alpha: Number,\n    beta: Number,\n    lower: Number,\n    upper: Number,\n    default_value: Number | None = None,\n    log: bool = False,\n    meta: Mapping[Hashable, Any] | None = None,\n)\n</code></pre> <p>               Bases: <code>FloatHyperparameter</code></p> <p>A beta distributed float hyperparameter. The 'lower' and 'upper' parameters move the distribution from the <code>[0, 1]</code>-range and scale it appropriately, but the shape of the distribution is preserved as if it were in <code>[0, 1]</code>-range.</p> <p>Its values are sampled from a beta distribution <code>Beta(alpha, beta)</code>.</p> <pre><code>from ConfigSpace import BetaFloatHyperparameter\n\nb = BetaFloatHyperparameter('b', alpha=3, beta=2, lower=1, upper=4, log=False)\nprint(b)\n</code></pre> <pre><code>b, Type: BetaFloat, Alpha: 3.0, Beta: 2.0, Range: [1.0, 4.0], Default: 3.0\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>Name of the hyperparameter, with which it can be accessed</p> <p> TYPE: <code>str</code> </p> <code>alpha</code> <p>Alpha parameter of the normalized beta distribution</p> <p> TYPE: <code>Number</code> </p> <code>beta</code> <p>Beta parameter of the normalized beta distribution</p> <p> TYPE: <code>Number</code> </p> <code>lower</code> <p>Lower bound of a range of values from which the hyperparameter will be sampled. The Beta disribution gets scaled by the total range of the hyperparameter.</p> <p> TYPE: <code>Number</code> </p> <code>upper</code> <p>Upper bound of a range of values from which the hyperparameter will be sampled. The Beta disribution gets scaled by the total range of the hyperparameter.</p> <p> TYPE: <code>Number</code> </p> <code>default_value</code> <p>Sets the default value of a hyperparameter to a given value</p> <p> TYPE: <code>Number | None</code> DEFAULT: <code>None</code> </p> <code>log</code> <p>If <code>True</code> the values of the hyperparameter will be sampled on a logarithmic scale. Default to <code>False</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>meta</code> <p>Field for holding meta data provided by the user. Not used by the configuration space.</p> <p> TYPE: <code>Mapping[Hashable, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/ConfigSpace/hyperparameters/beta_float.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    alpha: Number,\n    beta: Number,\n    lower: Number,\n    upper: Number,\n    default_value: Number | None = None,\n    log: bool = False,\n    meta: Mapping[Hashable, Any] | None = None,\n) -&gt; None:\n    \"\"\"Initialize a beta distributed float hyperparameter.\n\n    Args:\n        name:\n            Name of the hyperparameter, with which it can be accessed\n        alpha:\n            Alpha parameter of the normalized beta distribution\n        beta:\n            Beta parameter of the normalized beta distribution\n        lower:\n            Lower bound of a range of values from which the hyperparameter will be\n            sampled. The Beta disribution gets scaled by the total range of the\n            hyperparameter.\n        upper:\n            Upper bound of a range of values from which the hyperparameter will be\n            sampled. The Beta disribution gets scaled by the total range of the\n            hyperparameter.\n        default_value:\n            Sets the default value of a hyperparameter to a given value\n        log:\n            If `True` the values of the hyperparameter will be sampled\n            on a logarithmic scale. Default to `False`\n        meta:\n            Field for holding meta data provided by the user.\n            Not used by the configuration space.\n    \"\"\"\n    if (alpha &lt; 1) or (beta &lt; 1):\n        raise ValueError(\n            \"Please provide values of alpha and beta larger than or equal to\"\n            \" 1 so that the probability density is finite.\",\n        )\n\n    self.alpha = float(np.round(alpha, ROUND_PLACES))\n    self.beta = float(np.round(beta, ROUND_PLACES))\n    self.lower = float(np.round(lower, ROUND_PLACES))\n    self.upper = float(np.round(upper, ROUND_PLACES))\n    self.log = bool(log)\n\n    try:\n        scaler = UnitScaler(f64(self.lower), f64(self.upper), log=log, dtype=f64)\n    except ValueError as e:\n        raise ValueError(f\"Hyperparameter '{name}' has illegal settings\") from e\n\n    if (self.alpha &gt; 1) or (self.beta &gt; 1):\n        normalized_mode = (self.alpha - 1) / (self.alpha + self.beta - 2)\n    else:\n        # If both alpha and beta are 1, we have a uniform distribution.\n        normalized_mode = 0.5\n\n    if default_value is None:\n        _default_value = scaler.to_value(np.array([normalized_mode]))[0]\n    else:\n        _default_value = default_value\n\n    # This nicely behaves in 0, 1 range\n    beta_rv = spbeta(self.alpha, self.beta)\n    vector_dist = ScipyContinuousDistribution(\n        rv=beta_rv,  # type: ignore\n        lower_vectorized=f64(0.0),\n        upper_vectorized=f64(1.0),\n        _max_density=beta_rv.pdf(normalized_mode),  # type: ignore\n    )\n\n    super().__init__(\n        name=name,\n        size=np.inf,\n        default_value=float(np.round(_default_value, ROUND_PLACES)),\n        meta=meta,\n        transformer=scaler,\n        vector_dist=vector_dist,\n        neighborhood=vector_dist.neighborhood,\n        neighborhood_size=np.inf,\n        value_cast=float,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.alpha","title":"alpha  <code>instance-attribute</code>","text":"<pre><code>alpha: float = float(round(alpha, ROUND_PLACES))\n</code></pre> <p>Alpha parameter of the normalized beta distribution.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.beta","title":"beta  <code>instance-attribute</code>","text":"<pre><code>beta: float = float(round(beta, ROUND_PLACES))\n</code></pre> <p>Beta parameter of the normalized beta distribution.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: float\n</code></pre> <p>The default value of this hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: bool = bool(log)\n</code></pre> <p>If <code>True</code> the values of the hyperparameter will be sampled on a log-scale.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: float = float(round(lower, ROUND_PLACES))\n</code></pre> <p>Lower bound of a range of values from which the hyperparameter represents.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None\n</code></pre> <p>Field for holding meta data provided by the user. Not used by ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: float = field(init=False)\n</code></pre> <p>Size of the hyperparameter. Always <code>np.inf</code> for continuous hyperparameters.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: float = float(round(upper, ROUND_PLACES))\n</code></pre> <p>Upper bound of a range of values from which the hyperparameter represents.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.legal_value","title":"legal_value","text":"<pre><code>legal_value(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; bool | Mask\n</code></pre> <p>Check if a value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>bool | Mask</code> <p><code>True</code> if the value is legal, <code>False</code> otherwise. If <code>value</code> is an array of values, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_value(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; bool | Mask:\n    \"\"\"Check if a value is legal for this hyperparameter.\n\n    Args:\n        value:\n            The value to check.\n\n    Returns:\n        `True` if the value is legal, `False` otherwise. If `value` is an\n        array of values, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.legal_value(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.legal_value(np.asarray(value))\n\n    return self._transformer.legal_value_single(value)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.pdf_values","title":"pdf_values","text":"<pre><code>pdf_values(\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of values.</p> PARAMETER DESCRIPTION <code>values</code> <p>The values to get the probability density of.</p> <p> TYPE: <code>Sequence[ValueT | DType] | Array[DType]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the values. Where values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_values(\n    self,\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of values.\n\n    Args:\n        values:\n            The values to get the probability density of.\n\n    Returns:\n        The probability density of the values. Where values are not legal,\n        the probability density is zero.\n    \"\"\"\n    if isinstance(values, np.ndarray) and values.ndim != 1:\n        raise ValueError(\"Method pdf expects a one-dimensional numpy array\")\n\n    vector = self.to_vector(values)\n    return self.pdf_vector(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.to_integer","title":"to_integer","text":"<pre><code>to_integer() -&gt; BetaIntegerHyperparameter\n</code></pre> <p>Converts the beta float hyperparameter to a beta integer hyperparameter.</p> <p>This happens by rounding the lower and upper bounds and the default value as required.</p> <p>Warning</p> <p><code>meta</code> information is not transferred to the new hyperparameter and must be transferred manually.</p> RETURNS DESCRIPTION <code>BetaIntegerHyperparameter</code> <p>A beta integer hyperparameter.</p> Source code in <code>src/ConfigSpace/hyperparameters/beta_float.py</code> <pre><code>def to_integer(self) -&gt; BetaIntegerHyperparameter:\n    \"\"\"Converts the beta float hyperparameter to a beta integer hyperparameter.\n\n    This happens by rounding the lower and upper bounds and the default value\n    as required.\n\n    !!! warning\n\n        `meta` information is not transferred to the new hyperparameter and\n        must be transferred manually.\n\n    Returns:\n        A beta integer hyperparameter.\n    \"\"\"\n    from ConfigSpace.hyperparameters.beta_integer import BetaIntegerHyperparameter\n\n    lower = int(np.ceil(self.lower))\n    upper = int(np.floor(self.upper))\n    default_value = int(np.rint(self.default_value))\n\n    return BetaIntegerHyperparameter(\n        name=self.name,\n        lower=lower,\n        upper=upper,\n        default_value=default_value,\n        log=self.log,\n        meta=None,\n        alpha=float(self.alpha),\n        beta=float(self.beta),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.to_uniform","title":"to_uniform","text":"<pre><code>to_uniform() -&gt; UniformFloatHyperparameter\n</code></pre> <p>Convert the hyperparameter to its uniform equivalent.</p> <p>This will remove any distribution associated with it's vectorized representation.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_uniform(self) -&gt; UniformFloatHyperparameter:\n    \"\"\"Convert the hyperparameter to its uniform equivalent.\n\n    This will remove any distribution associated with it's vectorized\n    representation.\n    \"\"\"\n    from ConfigSpace.hyperparameters.uniform_float import UniformFloatHyperparameter\n\n    return UniformFloatHyperparameter(\n        name=self.name,\n        lower=self.lower,\n        upper=self.upper,\n        default_value=self.default_value,\n        log=self.log,\n        meta=self.meta,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_float/#ConfigSpace.hyperparameters.beta_float.BetaFloatHyperparameter.to_vector","title":"to_vector","text":"<pre><code>to_vector(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Transform a value to a vectorized value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to transform.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The vectorized value.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_vector(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; f64 | Array[f64]:\n    \"\"\"Transform a value to a vectorized value.\n\n    Args:\n        value:\n            The value to transform.\n\n    Returns:\n        The vectorized value.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.to_vector(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.to_vector(np.asarray(value))\n\n    return self._transformer.to_vector(np.array([value]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/","title":"Beta integer","text":""},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer","title":"ConfigSpace.hyperparameters.beta_integer","text":""},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter","title":"BetaIntegerHyperparameter  <code>dataclass</code>","text":"<pre><code>BetaIntegerHyperparameter(\n    name: str,\n    alpha: Number,\n    beta: Number,\n    lower: Number,\n    upper: Number,\n    default_value: Number | None = None,\n    log: bool = False,\n    meta: Mapping[Hashable, Any] | None = None,\n)\n</code></pre> <p>               Bases: <code>IntegerHyperparameter</code></p> <p>A beta distributed integer hyperparameter. The 'lower' and 'upper' parameters move the distribution from the <code>[0, 1]</code>-range and scale it appropriately, but the shape of the distribution is preserved as if it were in <code>[0, 1]</code>-range.</p> <p>Its values are sampled from a beta distribution <code>Beta(alpha, beta)</code>.</p> <pre><code>from ConfigSpace import BetaIntegerHyperparameter\n\nb = BetaIntegerHyperparameter('b', alpha=3, beta=2, lower=1, upper=4, log=False)\nprint(b)\n</code></pre> <pre><code>b, Type: BetaInteger, Alpha: 3.0, Beta: 2.0, Range: [1, 4], Default: 3\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>Name of the hyperparameter with which it can be accessed.</p> <p> TYPE: <code>str</code> </p> <code>alpha</code> <p>Alpha parameter of the distribution, from which hyperparameter is sampled.</p> <p> TYPE: <code>Number</code> </p> <code>beta</code> <p>Beta parameter of the distribution, from which hyperparameter is sampled.</p> <p> TYPE: <code>Number</code> </p> <code>lower</code> <p>Lower bound of a range of values from which the hyperparameter will be sampled.</p> <p> TYPE: <code>Number</code> </p> <code>upper</code> <p>Upper bound of a range of values from which the hyperparameter will be sampled.</p> <p> TYPE: <code>Number</code> </p> <code>default_value</code> <p>Sets the default value of a hyperparameter to a given value.</p> <p> TYPE: <code>Number | None</code> DEFAULT: <code>None</code> </p> <code>log</code> <p>If <code>True</code> the values of the hyperparameter will be sampled on a logarithmic scale. Defaults to <code>False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>meta</code> <p>Field for holding meta data provided by the user. Not used by the configuration space.</p> <p> TYPE: <code>Mapping[Hashable, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/ConfigSpace/hyperparameters/beta_integer.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    alpha: Number,\n    beta: Number,\n    lower: Number,\n    upper: Number,\n    default_value: Number | None = None,\n    log: bool = False,\n    meta: Mapping[Hashable, Any] | None = None,\n) -&gt; None:\n    \"\"\"Initialize a beta distributed integer hyperparameter.\n\n    Args:\n        name:\n            Name of the hyperparameter with which it can be accessed.\n        alpha:\n            Alpha parameter of the distribution, from which hyperparameter is\n            sampled.\n        beta:\n            Beta parameter of the distribution, from which\n            hyperparameter is sampled.\n        lower:\n            Lower bound of a range of values from which the hyperparameter will be\n            sampled.\n        upper:\n            Upper bound of a range of values from which the hyperparameter will be\n            sampled.\n        default_value:\n            Sets the default value of a hyperparameter to a given value.\n        log:\n            If `True` the values of the hyperparameter will be sampled\n            on a logarithmic scale. Defaults to `False`.\n        meta:\n            Field for holding meta data provided by the user.\n            Not used by the configuration space.\n    \"\"\"\n    if (alpha &lt; 1) or (beta &lt; 1):\n        raise ValueError(\n            \"Please provide values of alpha and beta larger than or equal to\"\n            \"1 so that the probability density is finite.\",\n        )\n    self.alpha = float(alpha)\n    self.beta = float(beta)\n    self.lower = int(np.rint(lower))\n    self.upper = int(np.rint(upper))\n    self.log = bool(log)\n\n    try:\n        scaler = UnitScaler(i64(self.lower), i64(self.upper), log=log, dtype=i64)\n    except ValueError as e:\n        raise ValueError(f\"Hyperparameter '{name}' has illegal settings\") from e\n\n    if default_value is None:\n        if (self.alpha &gt; 1) or (self.beta &gt; 1):\n            vectorized_mode = (self.alpha - 1) / (self.alpha + self.beta - 2)\n        else:\n            # If both alpha and beta are 1, we have a uniform distribution.\n            vectorized_mode = 0.5\n\n        _default_value = np.rint(\n            scaler.to_value(np.array([vectorized_mode]))[0],\n        ).astype(i64)\n    else:\n        if not is_close_to_integer_single(default_value, atol=ATOL):\n            raise TypeError(\n                f\"`default_value` for hyperparameter '{name}' must be an integer.\"\n                f\" Got '{type(default_value).__name__}' for {default_value=}.\",\n            )\n\n        _default_value = np.rint(default_value).astype(i64)\n\n    size = int(self.upper - self.lower + 1)\n    vector_dist = DiscretizedContinuousScipyDistribution(\n        rv=spbeta(self.alpha, self.beta),  # type: ignore\n        steps=size,\n        lower_vectorized=f64(0.0),\n        upper_vectorized=f64(1.0),\n    )\n\n    super().__init__(\n        name=name,\n        size=size,\n        default_value=_default_value,\n        meta=meta,\n        transformer=scaler,\n        vector_dist=vector_dist,\n        neighborhood=vector_dist.neighborhood,\n        neighborhood_size=self._integer_neighborhood_size,\n        value_cast=int,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.alpha","title":"alpha  <code>instance-attribute</code>","text":"<pre><code>alpha: float = float(alpha)\n</code></pre> <p>Alpha parameter of the normalized beta distribution.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.beta","title":"beta  <code>instance-attribute</code>","text":"<pre><code>beta: float = float(beta)\n</code></pre> <p>Beta parameter of the normalized beta distribution.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: int\n</code></pre> <p>The default value of this hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: bool = bool(log)\n</code></pre> <p>If <code>True</code> the values of the hyperparameter will be sampled on a log-scale.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: int = int(rint(lower))\n</code></pre> <p>Lower bound of a range of values from which the hyperparameter represents.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None\n</code></pre> <p>Field for holding meta data provided by the user. Not used by ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre> <p>Size of the hyperparameter. This is the number of possible values the hyperparameter can take on within the specified range.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: int = int(rint(upper))\n</code></pre> <p>Upper bound of a range of values from which the hyperparameter represents.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.legal_value","title":"legal_value","text":"<pre><code>legal_value(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; bool | Mask\n</code></pre> <p>Check if a value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>bool | Mask</code> <p><code>True</code> if the value is legal, <code>False</code> otherwise. If <code>value</code> is an array of values, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_value(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; bool | Mask:\n    \"\"\"Check if a value is legal for this hyperparameter.\n\n    Args:\n        value:\n            The value to check.\n\n    Returns:\n        `True` if the value is legal, `False` otherwise. If `value` is an\n        array of values, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.legal_value(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.legal_value(np.asarray(value))\n\n    return self._transformer.legal_value_single(value)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.pdf_values","title":"pdf_values","text":"<pre><code>pdf_values(\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of values.</p> PARAMETER DESCRIPTION <code>values</code> <p>The values to get the probability density of.</p> <p> TYPE: <code>Sequence[ValueT | DType] | Array[DType]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the values. Where values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_values(\n    self,\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of values.\n\n    Args:\n        values:\n            The values to get the probability density of.\n\n    Returns:\n        The probability density of the values. Where values are not legal,\n        the probability density is zero.\n    \"\"\"\n    if isinstance(values, np.ndarray) and values.ndim != 1:\n        raise ValueError(\"Method pdf expects a one-dimensional numpy array\")\n\n    vector = self.to_vector(values)\n    return self.pdf_vector(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.to_float","title":"to_float","text":"<pre><code>to_float() -&gt; BetaFloatHyperparameter\n</code></pre> <p>Converts the beta integer hyperparameter to a beta float hyperparameter.</p> <p>Warning</p> <p><code>meta</code> information is not transferred to the new hyperparameter and must be transferred manually.</p> RETURNS DESCRIPTION <code>BetaFloatHyperparameter</code> <p>A beta integer hyperparameter.</p> Source code in <code>src/ConfigSpace/hyperparameters/beta_integer.py</code> <pre><code>def to_float(self) -&gt; BetaFloatHyperparameter:\n    \"\"\"Converts the beta integer hyperparameter to a beta float hyperparameter.\n\n    !!! warning\n\n        `meta` information is not transferred to the new hyperparameter and\n        must be transferred manually.\n\n    Returns:\n        A beta integer hyperparameter.\n    \"\"\"\n    from ConfigSpace.hyperparameters.beta_float import BetaFloatHyperparameter\n\n    return BetaFloatHyperparameter(\n        name=self.name,\n        lower=self.lower,\n        upper=self.upper,\n        default_value=self.default_value,\n        log=self.log,\n        meta=None,\n        alpha=self.alpha,\n        beta=self.beta,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.to_uniform","title":"to_uniform","text":"<pre><code>to_uniform() -&gt; UniformIntegerHyperparameter\n</code></pre> <p>Convert the hyperparameter to its uniform equivalent.</p> <p>This will remove any distribution associated with it's vectorized representation.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_uniform(self) -&gt; UniformIntegerHyperparameter:\n    \"\"\"Convert the hyperparameter to its uniform equivalent.\n\n    This will remove any distribution associated with it's vectorized\n    representation.\n    \"\"\"\n    from ConfigSpace.hyperparameters.uniform_integer import (\n        UniformIntegerHyperparameter,\n    )\n\n    return UniformIntegerHyperparameter(\n        name=self.name,\n        lower=self.lower,\n        upper=self.upper,\n        default_value=self.default_value,\n        log=self.log,\n        meta=self.meta,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/beta_integer/#ConfigSpace.hyperparameters.beta_integer.BetaIntegerHyperparameter.to_vector","title":"to_vector","text":"<pre><code>to_vector(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Transform a value to a vectorized value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to transform.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The vectorized value.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_vector(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; f64 | Array[f64]:\n    \"\"\"Transform a value to a vectorized value.\n\n    Args:\n        value:\n            The value to transform.\n\n    Returns:\n        The vectorized value.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.to_vector(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.to_vector(np.asarray(value))\n\n    return self._transformer.to_vector(np.array([value]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/","title":"Categorical","text":""},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical","title":"ConfigSpace.hyperparameters.categorical","text":""},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CACHE_ARANGE_CATEGORICAL_SIZE","title":"CACHE_ARANGE_CATEGORICAL_SIZE  <code>module-attribute</code>","text":"<pre><code>CACHE_ARANGE_CATEGORICAL_SIZE = 25\n</code></pre> <p>For sizes smaller than this, we cache the arange for faster neighbor generation.</p>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CACHE_NEIGHBORS_CATEGORICAL_SIZE","title":"CACHE_NEIGHBORS_CATEGORICAL_SIZE  <code>module-attribute</code>","text":"<pre><code>CACHE_NEIGHBORS_CATEGORICAL_SIZE = 5\n</code></pre> <p>For sizes smaller than this, we cache the possible neighbors for faster neighbor generation.</p>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter","title":"CategoricalHyperparameter  <code>dataclass</code>","text":"<pre><code>CategoricalHyperparameter(\n    name: str,\n    choices: Sequence[Any],\n    default_value: Any | _NotSet = NotSet,\n    meta: Mapping[Hashable, Any] | None = None,\n    weights: Sequence[float] | Array[number] | None = None,\n)\n</code></pre> <p>               Bases: <code>Hyperparameter[Any, Any]</code></p> <p>A hyperparameter that can take on one of a fixed set of values.</p> <p>It is assumed there is no inherent order between the choices. If you know an order exists, use the <code>OrdinalHyperparameter</code> instead.</p> <p>The values are sampled uniformly by default, but can be weighted using the <code>weights</code> parameter. The <code>weights</code> parameter is a list of floats, one for each choice, that determines the probability of each choice being sampled. The probabilities are normalized to sum to 1.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the hyperparameter, with which it can be accessed.</p> <p> TYPE: <code>str</code> </p> <code>choices</code> <p>The possible values the hyperparameter can take on.</p> <p> TYPE: <code>Sequence[Any]</code> </p> <code>default_value</code> <p>The default value of this hyperparameter. If <code>None</code>, the first choice is used.</p> <p> TYPE: <code>Any | _NotSet</code> DEFAULT: <code>NotSet</code> </p> <code>meta</code> <p>Field for holding meta data provided by the user. Not used by ConfigSpace.</p> <p> TYPE: <code>Mapping[Hashable, Any] | None</code> DEFAULT: <code>None</code> </p> <code>weights</code> <p>The weights of the choices. If <code>None</code>, the choices are sampled uniformly. If given, the probabilities are normalized to sum to 1. The length of the weights has to be the same as the length of the choices.</p> <p> TYPE: <code>Sequence[float] | Array[number] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/ConfigSpace/hyperparameters/categorical.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    choices: Sequence[Any],\n    default_value: Any | _NotSet = NotSet,\n    meta: Mapping[Hashable, Any] | None = None,\n    weights: Sequence[float] | Array[np.number] | None = None,\n) -&gt; None:\n    \"\"\"Initialize a categorical hyperparameter.\n\n    Args:\n        name:\n            Name of the hyperparameter, with which it can be accessed.\n        choices:\n            The possible values the hyperparameter can take on.\n        default_value:\n            The default value of this hyperparameter. If `None`, the first\n            choice is used.\n        meta:\n            Field for holding meta data provided by the user. Not used by\n            ConfigSpace.\n        weights:\n            The weights of the choices. If `None`, the choices are sampled\n            uniformly. If given, the probabilities are normalized to sum to 1.\n            The length of the weights has to be the same as the length of the\n            choices.\n    \"\"\"\n    if isinstance(choices, Set):\n        raise TypeError(\n            \"Using a set of choices is prohibited as it can result in \"\n            \"non-deterministic behavior. Please use a list or a tuple.\",\n        )\n\n    choices = tuple(choices)\n\n    # We first try the fast route if it's Hashable, otherwise we resort to doing\n    # an N^2 check.\n    try:\n        counter = Counter(choices)\n        for choice, count in counter.items():\n            if count &gt; 1:\n                raise ValueError(\n                    f\"Choices for categorical hyperparameters {name} contain\"\n                    f\" choice `{choice}` {count} times, while only a single\"\n                    \" occurence is allowed.\",\n                )\n    except TypeError:\n        for a, b in product(choices, choices):\n            if a is not b and a == b:\n                raise ValueError(  # noqa: B904\n                    f\"Choices for categorical hyperparameters {name} contain\"\n                    f\" choice `{a}` multiple times, while only a single occurence\"\n                    \" is allowed.\",\n                )\n\n    if isinstance(weights, set):\n        raise TypeError(\n            \"Using a set of weights is prohibited as it can result in \"\n            \"non-deterministic behavior. Please use a list or a tuple.\",\n        )\n\n    if isinstance(weights, Sequence):\n        if len(weights) != len(choices):\n            raise ValueError(\n                \"The list of weights and the list of choices are required to be\"\n                f\" of same length. Gave {len(weights)} weights and\"\n                f\" {len(choices)} choices.\",\n            )\n        if any(weight &lt; 0 for weight in weights):\n            raise ValueError(\n                f\"Negative weights are not allowed. Got {weights}.\",\n            )\n        if all(weight == 0 for weight in weights):\n            raise ValueError(\n                \"All weights are zero, at least one weight has to be strictly\"\n                \" positive.\",\n            )\n        tupled_weights = tuple(weights)\n    elif weights is not None:\n        raise TypeError(\n            f\"The weights have to be a list, tuple or None. Got {weights!r}.\",\n        )\n    else:\n        tupled_weights = None\n\n    if default_value is not NotSet and default_value not in choices:\n        raise ValueError(\n            \"The default value has to be one of the choices. \"\n            f\"Got {default_value!r} which is not in {choices}.\",\n        )\n\n    size = len(choices)\n    if weights is None:\n        probabilities: Array[f64] = np.full(size, fill_value=1 / size, dtype=f64)\n    else:\n        _weights: Array[f64] = np.asarray(weights, dtype=f64)\n        probabilities = _weights / np.sum(_weights)\n\n    if default_value is NotSet and weights is None:\n        default_value = choices[0]\n    elif default_value is NotSet:\n        highest_prob_index = np.argmax(probabilities)\n        default_value = choices[highest_prob_index]\n    elif default_value in choices:\n        pass\n    else:\n        raise ValueError(f\"Illegal default value {default_value}\")\n\n    # We only need to pass probabilties is they are non-uniform...\n    vector_dist: Distribution\n    if weights is not None:\n        vector_dist = WeightedIntegerDiscreteDistribution(\n            size=size,\n            probabilities=np.asarray(probabilities),\n        )\n    else:\n        vector_dist = UniformIntegerDistribution(size=size)\n\n    try:\n        # This can fail with a ValueError if the choices contain arbitrary objects\n        # that are list like.\n        seq_choices = np.asarray(choices)\n        if seq_choices.ndim != 1:\n            raise ValueError\n\n        # NOTE: Unfortunatly, numpy will promote number types to str\n        # if there are string types in the array, where we'd rather\n        # stick to object type in that case. Hence the manual...\n        if seq_choices.dtype.kind in {\"U\", \"S\"} and not all(\n            isinstance(choice, str) for choice in choices\n        ):\n            seq_choices = np.array(choices, dtype=object)\n\n    except ValueError:\n        seq_choices = list(choices)\n\n    # If the Hyperparameter recieves as a Sequence during legality checks or\n    # conversions, we need to inform it that one of the values is a Sequence itself,\n    # i.e. we should treat it as a single value and not a list of multiple values\n    self._contains_sequence_as_value = any(\n        isinstance(choice, Sequence) and not isinstance(choice, str)\n        for choice in choices\n    )\n\n    self.probabilities = probabilities\n    self.choices = choices\n    self.weights = tupled_weights\n\n    super().__init__(\n        name=name,\n        default_value=default_value,\n        vector_dist=vector_dist,\n        size=size,\n        transformer=TransformerSeq(seq=seq_choices),\n        neighborhood=NeighborhoodCat(size=size),\n        neighborhood_size=self._categorical_neighborhood_size,\n        meta=meta,\n        value_cast=None,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.LEGAL_VALUE_TYPES","title":"LEGAL_VALUE_TYPES  <code>class-attribute</code>","text":"<pre><code>LEGAL_VALUE_TYPES: tuple[type, ...] | Literal[\"all\"] = \"all\"\n</code></pre> <p>The types of values that are legal for this hyperparameter. If set to <code>\"all\"</code> any type is legal. Otherwise, a tuple of types can be provided.</p>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.choices","title":"choices  <code>instance-attribute</code>","text":"<pre><code>choices: Sequence[Any] = choices\n</code></pre> <p>The possible values the hyperparameter can take on.</p>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: Any\n</code></pre> <p>The default value of this hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None\n</code></pre> <p>Field for holding meta data provided by the user. Not used by ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre> <p>The number of possible values for the categorical hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.weights","title":"weights  <code>instance-attribute</code>","text":"<pre><code>weights: tuple[float, ...] | None = tupled_weights\n</code></pre> <p>The weights of the choices. If <code>None</code>, the choices are sampled uniformly.</p>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.to_uniform","title":"to_uniform","text":"<pre><code>to_uniform() -&gt; CategoricalHyperparameter\n</code></pre> <p>Converts this hyperparameter to have uniform weights.</p> Source code in <code>src/ConfigSpace/hyperparameters/categorical.py</code> <pre><code>def to_uniform(self) -&gt; CategoricalHyperparameter:\n    \"\"\"Converts this hyperparameter to have uniform weights.\"\"\"\n    return CategoricalHyperparameter(\n        name=self.name,\n        choices=self.choices,\n        weights=None,\n        default_value=self.default_value,\n        meta=self.meta,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.CategoricalHyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.NeighborhoodCat","title":"NeighborhoodCat  <code>dataclass</code>","text":"<pre><code>NeighborhoodCat(\n    size: int,\n    _cached_arange: Array[f64] | None = None,\n    _cached_neighbors: list[Array[f64]] | None = None,\n)\n</code></pre> <p>               Bases: <code>Neighborhood</code></p> <p>Neighborhood for categorical hyperparameters.</p> <p>Note</p> <p>For <code>CategoricalHyperparameter</code>, all values are considered equally distant from each other. Thus, the possible neighbors is all other values except the current one.</p>"},{"location":"api/ConfigSpace/hyperparameters/categorical/#ConfigSpace.hyperparameters.categorical.NeighborhoodCat.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre> <p>The number of possible values for the categorical hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/constant/","title":"Constant","text":""},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant","title":"ConfigSpace.hyperparameters.constant","text":""},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.CONSTANT_VECTOR_VALUE_NO","title":"CONSTANT_VECTOR_VALUE_NO  <code>module-attribute</code>","text":"<pre><code>CONSTANT_VECTOR_VALUE_NO = f64(0)\n</code></pre> <p>Vectorized value for constant when not set.</p>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.CONSTANT_VECTOR_VALUE_YES","title":"CONSTANT_VECTOR_VALUE_YES  <code>module-attribute</code>","text":"<pre><code>CONSTANT_VECTOR_VALUE_YES = f64(1)\n</code></pre> <p>Vectorized value for constant when set.</p>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant","title":"Constant  <code>dataclass</code>","text":"<pre><code>Constant(\n    name: str,\n    value: Any,\n    meta: Mapping[Hashable, Any] | None = None,\n)\n</code></pre> <p>               Bases: <code>Hyperparameter[Any, Any]</code></p> <p>Representing a constant hyperparameter in the configuration space.</p> <p>By sampling from the configuration space each time only a single, constant <code>value</code> will be drawn from this hyperparameter.</p> <p>By sampling from the configuration space each time only a single, constant <code>value</code> will be drawn from this hyperparameter.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the hyperparameter, with which it can be accessed</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>value to sample hyperparameter from</p> <p> TYPE: <code>Any</code> </p> <code>meta</code> <p>Field for holding meta data provided by the user. Not used by the configuration space.</p> <p> TYPE: <code>Mapping[Hashable, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/ConfigSpace/hyperparameters/constant.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    value: Any,\n    meta: Mapping[Hashable, Any] | None = None,\n) -&gt; None:\n    \"\"\"Representing a constant hyperparameter in the configuration space.\n\n    By sampling from the configuration space each time only a single,\n    constant `value` will be drawn from this hyperparameter.\n\n    Args:\n        name:\n            Name of the hyperparameter, with which it can be accessed\n        value:\n            value to sample hyperparameter from\n        meta:\n            Field for holding meta data provided by the user.\n            Not used by the configuration space.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        raise ValueError(\n            \"Constant hyperparameter does not support numpy arrays as values\",\n        )\n    self.value = value\n    self._contains_sequence_as_value = isinstance(\n        value,\n        Sequence,\n    ) and not isinstance(value, str)\n\n    super().__init__(\n        name=name,\n        default_value=value,\n        size=1,\n        meta=meta,\n        transformer=TransformerConstant(\n            value=value,\n            vector_value_yes=CONSTANT_VECTOR_VALUE_YES,\n            vector_value_no=CONSTANT_VECTOR_VALUE_NO,\n        ),\n        vector_dist=ConstantVectorDistribution(\n            vector_value=CONSTANT_VECTOR_VALUE_YES,\n        ),\n        neighborhood=_empty_neighborhood,\n        neighborhood_size=0,\n        value_cast=None,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.LEGAL_VALUE_TYPES","title":"LEGAL_VALUE_TYPES  <code>class-attribute</code>","text":"<pre><code>LEGAL_VALUE_TYPES: tuple[type, ...] | Literal[\"all\"] = \"all\"\n</code></pre> <p>The types of values that are legal for this hyperparameter. If set to <code>\"all\"</code> any type is legal. Otherwise, a tuple of types can be provided.</p>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: ValueT = default_value\n</code></pre> <p>The default value of this hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None\n</code></pre> <p>Field for holding meta data provided by the user. Not used by the ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre> <p>Size of the hyperparameter, which is always 1 for a constant hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Any = value\n</code></pre> <p>Value to sample hyperparameter from.</p>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/constant/#ConfigSpace.hyperparameters.constant.Constant.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/","title":"Distributions","text":""},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions","title":"ConfigSpace.hyperparameters.distributions","text":""},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.DEFAULT_VECTORIZED_NUMERIC_STD","title":"DEFAULT_VECTORIZED_NUMERIC_STD  <code>module-attribute</code>","text":"<pre><code>DEFAULT_VECTORIZED_NUMERIC_STD = 0.2\n</code></pre> <p>The default standard deviation for generating neighborhoods of vectorized values.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ConstantVectorDistribution","title":"ConstantVectorDistribution  <code>dataclass</code>","text":"<pre><code>ConstantVectorDistribution(vector_value: f64)\n</code></pre> <p>               Bases: <code>Distribution</code></p> <p>A distribution that always returns the same constant value.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ConstantVectorDistribution.lower_vectorized","title":"lower_vectorized  <code>instance-attribute</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>The lower bound of the vectorized space.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ConstantVectorDistribution.upper_vectorized","title":"upper_vectorized  <code>instance-attribute</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>The lower bound of the vectorized space.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ConstantVectorDistribution.vector_value","title":"vector_value  <code>instance-attribute</code>","text":"<pre><code>vector_value: f64\n</code></pre> <p>The constant vector value to return.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ConstantVectorDistribution.max_density","title":"max_density","text":"<pre><code>max_density() -&gt; float\n</code></pre> <p>Return the maximum density of the distribution.</p> <p>Always 1.0 as the density is always 1 at the constant value.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def max_density(self) -&gt; float:\n    \"\"\"Return the maximum density of the distribution.\n\n    Always 1.0 as the density is always 1 at the constant value.\n    \"\"\"\n    return 1.0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ConstantVectorDistribution.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Calculate the probability density function (pdf) of all elements in <code>vector</code>.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to calculate the pdf for.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The pdf of all elements in <code>vector</code>. If an element is not equal to the constant value, the pdf is <code>0</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Calculate the probability density function (pdf) of all elements in `vector`.\n\n    Args:\n        vector: The vectorized values to calculate the pdf for.\n\n    Returns:\n        The pdf of all elements in `vector`. If an element is not equal to the\n        constant value, the pdf is `0`.\n    \"\"\"\n    return (vector == self.vector_value).astype(f64)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ConstantVectorDistribution.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    n: int, *, seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample <code>n</code> values from the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def sample_vector(\n    self,\n    n: int,\n    *,\n    seed: RandomState | None = None,  # noqa: ARG002\n) -&gt; Array[f64]:\n    \"\"\"Sample `n` values from the distribution.\"\"\"\n    return np.full((n,), self.vector_value, dtype=f64)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.DiscretizedContinuousScipyDistribution","title":"DiscretizedContinuousScipyDistribution  <code>dataclass</code>","text":"<pre><code>DiscretizedContinuousScipyDistribution(\n    steps: int,\n    rv: rv_continuous_frozen,\n    lower_vectorized: f64,\n    upper_vectorized: f64,\n    log_scale: bool = False,\n    transformer: Transformer[DType] | None = None,\n    _max_density: float | None = None,\n    _pdf_norm: float | None = None,\n    original_value_scale: tuple[DType, DType] | None = None,\n)\n</code></pre> <p>               Bases: <code>Distribution</code>, <code>Generic[DType]</code></p> <p>A wrapper to create discrete samples from a continuous scipy distribution.</p> <p>This class allows us to take pre-existing scipy distributions which are defined over a continuous space, and transform them into discrete intervals.</p> <p>This can also handle adapt a distribution, such that the discrete bins can be distributed on a log scale over the distributrion.</p> <p>Note</p> <p>If providing <code>log=True</code>, you must also provide the <code>Transformer</code> which will be used to transform from vectorized space to the value space.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.DiscretizedContinuousScipyDistribution.log_scale","title":"log_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_scale: bool = False\n</code></pre> <p>Whether the distribution is on a log scale.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.DiscretizedContinuousScipyDistribution.lower_vectorized","title":"lower_vectorized  <code>instance-attribute</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>The lower bound of the vectorized space.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.DiscretizedContinuousScipyDistribution.original_value_scale","title":"original_value_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>original_value_scale: tuple[DType, DType] | None = None\n</code></pre> <p>The original value scale of the transformer.</p> <p>This is used on log-scale transformation.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.DiscretizedContinuousScipyDistribution.rv","title":"rv  <code>instance-attribute</code>","text":"<pre><code>rv: rv_continuous_frozen\n</code></pre> <p>The continuous scipy distribution to discretize.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.DiscretizedContinuousScipyDistribution.steps","title":"steps  <code>instance-attribute</code>","text":"<pre><code>steps: int\n</code></pre> <p>The number of steps to discretize the distribution into.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.DiscretizedContinuousScipyDistribution.transformer","title":"transformer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transformer: Transformer[DType] | None = None\n</code></pre> <p>The transformer to use for log-scaled distributions.</p> <p>Only required if <code>log_scale=True</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.DiscretizedContinuousScipyDistribution.upper_vectorized","title":"upper_vectorized  <code>instance-attribute</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>The upper bound of the vectorized space.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.DiscretizedContinuousScipyDistribution.max_density","title":"max_density","text":"<pre><code>max_density() -&gt; float\n</code></pre> <p>Return the maximum density of the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def max_density(self) -&gt; float:\n    \"\"\"Return the maximum density of the distribution.\"\"\"\n    if self._max_density is not None:\n        return self._max_density\n\n    _max, _sum = self._max_density_and_normalization_constant()\n    self._max_density = _max\n    self._pdf_norm = _sum\n    return _max\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.DiscretizedContinuousScipyDistribution.neighborhood","title":"neighborhood","text":"<pre><code>neighborhood(\n    vector: f64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None,\n    n_retries: int = NEIGHBOR_GENERATOR_N_RETRIES,\n    sample_multiplier: int = NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER\n) -&gt; Array[f64]\n</code></pre> <p>Create a neighborhood of <code>n</code> neighbors around <code>vector</code> with a normal distribution.</p> <p>The neighborhood is created by sampling from a normal distribution centered around <code>vector</code> with a standard deviation of <code>std</code>. The samples are then quantized to the range <code>[lower, upper]</code> with <code>bins</code> bins. The number of samples is <code>n</code>.</p> <p>Warning</p> <p>If there are not enough unique neighbors to sample from, the function will return less than <code>n</code> neighbors.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The center of the neighborhood.</p> <p> TYPE: <code>f64</code> </p> <code>n</code> <p>The number of neighbors to generate.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the normal distribution. If <code>None</code> will use <code>DEFAULT_VECTORIZED_NUMERIC_STD</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random seed to use.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> <code>n_retries</code> <p>The number of retries to attempt to generate unique neighbors. Each retry increases the standard deviation of the normal distribution to prevent rejection sampling from failing.</p> <p> TYPE: <code>int</code> DEFAULT: <code>NEIGHBOR_GENERATOR_N_RETRIES</code> </p> <code>sample_multiplier</code> <p>A multiplier which multiplies by <code>n</code> to determine the number of samples to generate for try. By oversampling, we prevent having to repeated calls to both sampling and unique checking.</p> <p>However, oversampling makes a tradeoff when the <code>std</code> is not high enough to generate <code>n</code> unique neighbors, effectively sampling more of the same duplicates.</p> <p>Tuning this may be beneficial in unique circumstances, however we advise leaving this as a default.</p> <p> TYPE: <code>int</code> DEFAULT: <code>NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>An array of <code>n</code> neighbors around <code>vector</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def neighborhood(\n    self,\n    vector: f64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None,\n    n_retries: int = NEIGHBOR_GENERATOR_N_RETRIES,\n    sample_multiplier: int = NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER,\n) -&gt; Array[f64]:\n    \"\"\"Create a neighborhood of `n` neighbors around `vector` with a normal distribution.\n\n    The neighborhood is created by sampling from a normal distribution centered\n    around `vector` with a standard deviation of `std`. The samples are then\n    quantized to the range `[lower, upper]` with `bins` bins. The number of samples\n    is `n`.\n\n    !!! warning\n\n        If there are not enough unique neighbors to sample from, the function will\n        return less than `n` neighbors.\n\n    Args:\n        vector: The center of the neighborhood.\n        n: The number of neighbors to generate.\n        std: The standard deviation of the normal distribution. If `None` will use\n            [`DEFAULT_VECTORIZED_NUMERIC_STD`][ConfigSpace.hyperparameters.distributions.DEFAULT_VECTORIZED_NUMERIC_STD].\n        seed: The random seed to use.\n        n_retries:\n            The number of retries to attempt to generate unique neighbors.\n            Each retry increases the standard deviation of the normal distribution\n            to prevent rejection sampling from failing.\n        sample_multiplier:\n            A multiplier which multiplies by `n` to determine the number of samples\n            to generate for try. By oversampling, we prevent having to repeated\n            calls to both sampling and unique checking.\n\n            However, oversampling makes a tradeoff when the `std` is not high\n            enough to generate `n` unique neighbors,\n            effectively sampling more of the same duplicates.\n\n            Tuning this may be beneficial in unique circumstances, however we advise\n            leaving this as a default.\n\n    Returns:\n        An array of `n` neighbors around `vector`.\n    \"\"\"  # noqa: E501\n    if std is None:\n        std = DEFAULT_VECTORIZED_NUMERIC_STD\n\n    assert n &lt; 1000000, \"Can only generate less than 1 million neighbors.\"\n    seed = np.random.RandomState() if seed is None else seed\n    lower, upper = self.lower_vectorized, self.upper_vectorized\n    steps = self.steps\n\n    qvector = self._quantize(np.array([vector]))[0]\n\n    # In the easiest case, the amount of neighbors we need is more than the amount\n    # possible, in this case, we can skip our sampling and just generate all\n    # neighbors, excluding the current value\n    n_available = steps - 1\n    if n &gt;= n_available:\n        if self.log_scale:\n            assert self.transformer is not None\n            assert self.original_value_scale is not None\n            orig_low, orig_high = self.original_value_scale\n            qvector_orig: DType = self.transformer.to_value(np.array([qvector]))[0]\n\n            # Now we can calculate the stepsize between the original values\n            # and hence see where qhigh and qlow lie in the original space to\n            # calculate how many intermediate steps we need.\n            stepsize = (orig_high - orig_low) / (self.steps - 1)\n\n            # Edge case for when qcenter is the lower bound\n            steps_to_take = int((qvector_orig - orig_low) / stepsize) + 1\n            if steps_to_take == 1:\n                bottom = np.array([])\n            else:\n                bottom_orig = np.linspace(\n                    orig_low,  # type: ignore\n                    qvector_orig,  # type: ignore\n                    steps_to_take - 1,\n                    endpoint=False,\n                    dtype=f64,\n                )\n                bottom = self.transformer.to_vector(bottom_orig)\n\n            top_orig = np.linspace(\n                qvector_orig + stepsize,\n                orig_high,  # type: ignore\n                steps - steps_to_take,\n                dtype=f64,\n            )\n\n            top = self.transformer.to_vector(top_orig)\n        else:\n            stepsize = (upper - lower) / (self.steps - 1)\n\n            # Edge case for when qcenter is the lower bound\n            steps_to_take = int((qvector - lower) / stepsize) + 1\n            if steps_to_take == 1:\n                bottom = np.array([])\n            else:\n                bottom = np.linspace(lower, qvector, steps_to_take, endpoint=False)\n\n            top = np.linspace(qvector + stepsize, upper, steps - steps_to_take)\n\n        return np.concatenate((bottom, top))\n\n    # Otherwise, we use a repeated sampling strategy where we slowly increase the\n    # std of a normal, centered on `center`, slowly expanding `std` such that\n    # rejection won't fail.\n\n    # We set up a buffer that can hold the number of neighbors we need, plus some\n    # extra excess from sampling, preventing us from having to reallocate memory.\n    # We also include the initial value in the buffer, as we will remove it later.\n    SAMPLE_SIZE = n * sample_multiplier\n    BUFFER_SIZE = n * (sample_multiplier + 1)\n    neighbors: Array[f64] = np.empty(BUFFER_SIZE + 1, dtype=f64)\n    neighbors[0] = qvector\n    offset = 1  # Indexes into current progress of filling buffer\n\n    # We extend the range of stds to try to find neighbors\n    if (\n        std == DEFAULT_VECTORIZED_NUMERIC_STD\n        and n_retries == NEIGHBOR_GENERATOR_N_RETRIES\n    ):\n        stds = _CACHED_LINSPACE\n    else:\n        stds = np.linspace(std, 1.0, n_retries + 1, endpoint=True)\n\n    range_size = upper - lower\n    for _std in stds:\n        # Generate candidates in vectorized space\n        candidates = seed.normal(qvector, _std * range_size, size=SAMPLE_SIZE)\n        valid_candidates = candidates[(candidates &gt;= lower) &amp; (candidates &lt;= upper)]\n\n        # Transform to quantized space\n        candidates_quantized = self._quantize(valid_candidates)\n\n        uniq = np.unique(candidates_quantized)\n        new_uniq = np.setdiff1d(uniq, neighbors[:offset], assume_unique=True)\n\n        n_new_unique = len(new_uniq)\n        neighbors[offset : offset + n_new_unique] = new_uniq\n        offset += n_new_unique\n\n        # We have enough neighbors, we can stop\n        if offset - 1 &gt;= n:\n            # Ensure we don't include the initial value point\n            return neighbors[1 : n + 1]\n\n    raise ValueError(\n        f\"Failed to find enough neighbors with {n_retries} retries.\"\n        f\" Given {n=} neighbors to generate, we only found {offset - 1}.\"\n        f\" The normal's for sampling neighbors were Normal({vector}, {list(stds)})\"\n        f\" which were meant to find neighbors of {vector}. in the range\"\n        f\" ({self.lower_vectorized}, {self.upper_vectorized}).\",\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.DiscretizedContinuousScipyDistribution.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Calculate the probability density function (pdf) of all elements in <code>vector</code>.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to calculate the pdf for.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The pdf of all elements in <code>vector</code>. If an element is outside the bounds defined by <code>lower_vectorized</code> and <code>upper_vectorized</code>, the pdf is <code>0</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Calculate the probability density function (pdf) of all elements in `vector`.\n\n    Args:\n        vector: The vectorized values to calculate the pdf for.\n\n    Returns:\n        The pdf of all elements in `vector`. If an element is outside the bounds\n        defined by `lower_vectorized` and `upper_vectorized`, the pdf is `0`.\n    \"\"\"\n    valid_entries = np.where(\n        (vector &gt;= self.lower_vectorized) &amp; (vector &lt;= self.upper_vectorized),\n        vector,\n        np.nan,\n    )\n    pdf = self.rv.pdf(valid_entries) / self._pdf_normalization_constant()\n\n    # By definition, we don't allow NaNs in the pdf\n    return np.nan_to_num(pdf, nan=0)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.DiscretizedContinuousScipyDistribution.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    n: int, *, seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample <code>n</code> values from the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def sample_vector(\n    self,\n    n: int,\n    *,\n    seed: RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample `n` values from the distribution.\"\"\"\n    return self._quantize(x=self.rv.rvs(size=n, random_state=seed))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.Distribution","title":"Distribution","text":"<p>               Bases: <code>Protocol</code></p> <p>A protocol for distributions.</p> <p>A distribution is defined by some vectorized space and allows us to draw samples from it, calculate the probability density function (pdf) and provide a maximum density.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.Distribution.lower_vectorized","title":"lower_vectorized  <code>instance-attribute</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>The lower bound of the vectorized space.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.Distribution.upper_vectorized","title":"upper_vectorized  <code>instance-attribute</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>The lower bound of the vectorized space.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.Distribution.max_density","title":"max_density","text":"<pre><code>max_density() -&gt; float\n</code></pre> <p>Return the maximum density of the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def max_density(self) -&gt; float:\n    \"\"\"Return the maximum density of the distribution.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.Distribution.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Calculate the probability density function (pdf) of all elements in <code>vector</code>.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to calculate the pdf for.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The pdf of all elements in <code>vector</code>. If an element is outside the bounds defined by <code>lower_vectorized</code> and <code>upper_vectorized</code>, the pdf should be 0.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Calculate the probability density function (pdf) of all elements in `vector`.\n\n    Args:\n        vector: The vectorized values to calculate the pdf for.\n\n    Returns:\n        The pdf of all elements in `vector`. If an element is outside the bounds\n        defined by `lower_vectorized` and `upper_vectorized`, the pdf should be 0.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.Distribution.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    n: int, *, seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample <code>n</code> values from the distribution.</p> <p>Samples generated do not have to be unique.</p> <p>Note</p> <p>Generated samples must be within the bounds defined by <code>lower_vectorized</code> and <code>upper_vectorized</code>.</p> PARAMETER DESCRIPTION <code>n</code> <p>The number of samples to generate.</p> <p> TYPE: <code>int</code> </p> <code>seed</code> <p>The random seed to use.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>An array of <code>n</code> samples, not guaranteed to be unique.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def sample_vector(\n    self,\n    n: int,\n    *,\n    seed: RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample `n` values from the distribution.\n\n    Samples generated do not have to be unique.\n\n    !!! note\n        Generated samples must be within the bounds defined by `lower_vectorized`\n        and `upper_vectorized`.\n\n    Args:\n        n: The number of samples to generate.\n        seed: The random seed to use.\n\n    Returns:\n        An array of `n` samples, **not** guaranteed to be unique.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyContinuousDistribution","title":"ScipyContinuousDistribution  <code>dataclass</code>","text":"<pre><code>ScipyContinuousDistribution(\n    rv: rv_continuous_frozen,\n    lower_vectorized: f64,\n    upper_vectorized: f64,\n    _max_density: float,\n    _pdf_norm: float = 1,\n)\n</code></pre> <p>               Bases: <code>Distribution</code></p> <p>A wrapper to create continuous samples from a scipy continuous distribution.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyContinuousDistribution.lower_vectorized","title":"lower_vectorized  <code>instance-attribute</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>The lower bound of the vectorized space.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyContinuousDistribution.rv","title":"rv  <code>instance-attribute</code>","text":"<pre><code>rv: rv_continuous_frozen\n</code></pre> <p>The continuous scipy distribution to use.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyContinuousDistribution.upper_vectorized","title":"upper_vectorized  <code>instance-attribute</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>The upper bound of the vectorized space.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyContinuousDistribution.max_density","title":"max_density","text":"<pre><code>max_density() -&gt; float\n</code></pre> <p>Return the maximum density of the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def max_density(self) -&gt; float:\n    \"\"\"Return the maximum density of the distribution.\"\"\"\n    return float(self._max_density)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyContinuousDistribution.neighborhood","title":"neighborhood","text":"<pre><code>neighborhood(\n    vector: f64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None,\n    n_retries: int = NEIGHBOR_GENERATOR_N_RETRIES,\n    sample_multiplier: int = NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER\n) -&gt; Array[f64]\n</code></pre> <p>Please see <code>continuous_neighborhood</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def neighborhood(\n    self,\n    vector: f64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None,\n    n_retries: int = NEIGHBOR_GENERATOR_N_RETRIES,\n    sample_multiplier: int = NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER,\n) -&gt; Array[f64]:\n    \"\"\"Please see [`continuous_neighborhood`][ConfigSpace.hyperparameters.distributions.continuous_neighborhood].\"\"\"  # noqa: E501\n    return continuous_neighborhood(\n        vector,\n        n,\n        std=std,\n        seed=seed,\n        n_retries=n_retries,\n        sample_multiplier=sample_multiplier,\n        lower=self.lower_vectorized,\n        upper=self.upper_vectorized,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyContinuousDistribution.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Calculate the probability density function (pdf) of all elements in <code>vector</code>.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to calculate the pdf for.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The pdf of all elements in <code>vector</code>. If an element is outside the bounds defined by <code>lower_vectorized</code> and <code>upper_vectorized</code>, the pdf is <code>0</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Calculate the probability density function (pdf) of all elements in `vector`.\n\n    Args:\n        vector: The vectorized values to calculate the pdf for.\n\n    Returns:\n        The pdf of all elements in `vector`. If an element is outside the bounds\n        defined by `lower_vectorized` and `upper_vectorized`, the pdf is `0`.\n    \"\"\"\n    pdf = self.rv.pdf(vector) / self._pdf_norm\n\n    # By definition, we don't allow NaNs in the pdf\n    return np.nan_to_num(pdf, nan=0)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyContinuousDistribution.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    n: int, *, seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample <code>n</code> values from the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def sample_vector(\n    self,\n    n: int,\n    *,\n    seed: RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample `n` values from the distribution.\"\"\"\n    return self.rv.rvs(size=n, random_state=seed).astype(f64)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyDiscreteDistribution","title":"ScipyDiscreteDistribution  <code>dataclass</code>","text":"<pre><code>ScipyDiscreteDistribution(\n    rv: rv_discrete_frozen,\n    _max_density: float,\n    lower_vectorized: f64,\n    upper_vectorized: f64,\n)\n</code></pre> <p>               Bases: <code>Distribution</code></p> <p>A wrapper to create discrete samples from a scipy discrete distribution.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyDiscreteDistribution.lower_vectorized","title":"lower_vectorized  <code>instance-attribute</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>The lower bound of the vectorized space.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyDiscreteDistribution.rv","title":"rv  <code>instance-attribute</code>","text":"<pre><code>rv: rv_discrete_frozen\n</code></pre> <p>The discrete scipy distribution to use.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyDiscreteDistribution.upper_vectorized","title":"upper_vectorized  <code>instance-attribute</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>The upper bound of the vectorized space.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyDiscreteDistribution.max_density","title":"max_density","text":"<pre><code>max_density() -&gt; float\n</code></pre> <p>Return the maximum density of the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def max_density(self) -&gt; float:\n    \"\"\"Return the maximum density of the distribution.\"\"\"\n    return float(self._max_density)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyDiscreteDistribution.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Calculate the probability density function (pdf) of all elements in <code>vector</code>.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to calculate the pdf for.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The pdf of all elements in <code>vector</code>. If an element is outside the bounds defined by <code>lower_vectorized</code> and <code>upper_vectorized</code>, the pdf is <code>0</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Calculate the probability density function (pdf) of all elements in `vector`.\n\n    Args:\n        vector: The vectorized values to calculate the pdf for.\n\n    Returns:\n        The pdf of all elements in `vector`. If an element is outside the bounds\n        defined by `lower_vectorized` and `upper_vectorized`, the pdf is `0`.\n    \"\"\"\n    pdf = self.rv.pmf(vector)\n    return np.nan_to_num(pdf, nan=0)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.ScipyDiscreteDistribution.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    n: int, *, seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample <code>n</code> values from the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def sample_vector(\n    self,\n    n: int,\n    *,\n    seed: RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample `n` values from the distribution.\"\"\"\n    return self.rv.rvs(size=n, random_state=seed).astype(f64)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerDistribution","title":"UniformIntegerDistribution  <code>dataclass</code>","text":"<pre><code>UniformIntegerDistribution(size: int)\n</code></pre> <p>               Bases: <code>Distribution</code></p> <p>A uniform distribution over the integers in the range <code>[0, size - 1]</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerDistribution.lower_vectorized","title":"lower_vectorized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lower_vectorized: f64 = field(init=False)\n</code></pre> <p>The lower bound of the vectorized space. In this case always 0.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerDistribution.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre> <p>The number of steps to discretize the distribution into.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerDistribution.upper_vectorized","title":"upper_vectorized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>upper_vectorized: f64 = field(init=False)\n</code></pre> <p>The upper bound of the vectorized space. In this case <code>size - 1</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerDistribution.max_density","title":"max_density","text":"<pre><code>max_density() -&gt; float\n</code></pre> <p>Return the maximum density of the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def max_density(self) -&gt; float:\n    \"\"\"Return the maximum density of the distribution.\"\"\"\n    return 1 / self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerDistribution.neighborhood","title":"neighborhood","text":"<pre><code>neighborhood(\n    vector: f64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None,\n    n_retries: int = NEIGHBOR_GENERATOR_N_RETRIES,\n    sample_multiplier: int = NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER\n) -&gt; Array[f64]\n</code></pre> <p>Create a neighborhood of <code>n</code> neighbors around <code>vector</code> with a normal distribution.</p> <p>The neighborhood is created by sampling from a normal distribution centered around <code>vector</code> with a standard deviation of <code>std</code>. The samples are then quantized to the range <code>[lower, upper]</code> with <code>bins</code> bins. The number of samples is <code>n</code>.</p> <p>Warning</p> <p>If there are not enough unique neighbors to sample from, the function will return less than <code>n</code> neighbors.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The center of the neighborhood.</p> <p> TYPE: <code>f64</code> </p> <code>n</code> <p>The number of neighbors to generate.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the normal distribution. If <code>None</code> will use <code>DEFAULT_VECTORIZED_NUMERIC_STD</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random seed to use.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> <code>n_retries</code> <p>The number of retries to attempt to generate unique neighbors. Each retry increases the standard deviation of the normal distribution to prevent rejection sampling from failing.</p> <p> TYPE: <code>int</code> DEFAULT: <code>NEIGHBOR_GENERATOR_N_RETRIES</code> </p> <code>sample_multiplier</code> <p>A multiplier which multiplies by <code>n</code> to determine the number of samples to generate for try. By oversampling, we prevent having to repeated calls to both sampling and unique checking.</p> <p>However, oversampling makes a tradeoff when the <code>std</code> is not high enough to generate <code>n</code> unique neighbors, effectively sampling more of the same duplicates.</p> <p>Tuning this may be beneficial in unique circumstances, however we advise leaving this as a default.</p> <p> TYPE: <code>int</code> DEFAULT: <code>NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>An array of <code>n</code> neighbors around <code>vector</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def neighborhood(\n    self,\n    vector: f64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None,\n    n_retries: int = NEIGHBOR_GENERATOR_N_RETRIES,\n    sample_multiplier: int = NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER,\n) -&gt; Array[f64]:\n    \"\"\"Create a neighborhood of `n` neighbors around `vector` with a normal distribution.\n\n    The neighborhood is created by sampling from a normal distribution centered around\n    `vector` with a standard deviation of `std`. The samples are then quantized to the\n    range `[lower, upper]` with `bins` bins. The number of samples is `n`.\n\n    !!! warning\n\n        If there are not enough unique neighbors to sample from, the function will\n        return less than `n` neighbors.\n\n    Args:\n        vector: The center of the neighborhood.\n        n: The number of neighbors to generate.\n        std: The standard deviation of the normal distribution. If `None` will use\n            [`DEFAULT_VECTORIZED_NUMERIC_STD`][ConfigSpace.hyperparameters.distributions.DEFAULT_VECTORIZED_NUMERIC_STD].\n        seed: The random seed to use.\n        n_retries:\n            The number of retries to attempt to generate unique neighbors.\n            Each retry increases the standard deviation of the normal distribution to prevent\n            rejection sampling from failing.\n        sample_multiplier:\n            A multiplier which multiplies by `n` to determine the number of samples to\n            generate for try. By oversampling, we prevent having to repeated calls to\n            both sampling and unique checking.\n\n            However, oversampling makes a tradeoff when the `std` is not high enough to\n            generate `n` unique neighbors, effectively sampling more of the same duplicates.\n\n            Tuning this may be beneficial in unique circumstances, however we advise leaving\n            this as a default.\n\n    Returns:\n        An array of `n` neighbors around `vector`.\n    \"\"\"  # noqa: E501\n    # Different than other neighborhoods as it's unnormalized and\n    # the quantization is directly integers.\n    if std is None:\n        std = DEFAULT_VECTORIZED_NUMERIC_STD\n\n    assert n &lt; 1000000, \"Can only generate less than 1 million neighbors.\"\n    seed = np.random.RandomState() if seed is None else seed\n    lower, upper = self.lower_vectorized, self.upper_vectorized\n    steps = self.size\n\n    qvector = np.rint(vector).astype(i64)\n\n    # In the easiest case, the amount of neighbors we need is more than the amount\n    # possible, in this case, we can skip our sampling and just generate all\n    # neighbors, excluding the current value\n    n_available = steps - 1\n    if n &gt;= n_available:\n        if qvector == 0:\n            return np.arange(1, steps, dtype=f64)\n        if qvector == steps - 1:\n            return np.arange(0, steps - 1, dtype=f64)\n\n        bottom = np.arange(0, qvector)\n        top = np.arange(qvector + 1, steps)\n        return np.concatenate((bottom, top)).astype(f64)\n\n    # Otherwise, we use a repeated sampling strategy where we slowly increase the\n    # std of a normal, centered on `center`, slowly expanding `std` such that\n    # rejection won't fail.\n\n    # We set up a buffer that can hold the number of neighbors we need, plus some\n    # extra excess from sampling, preventing us from having to reallocate memory.\n    # We also include the initial value in the buffer, as we will remove it later.\n    SAMPLE_SIZE = n * sample_multiplier\n    BUFFER_SIZE = n * (sample_multiplier + 1)\n    neighbors: Array[f64] = np.empty(BUFFER_SIZE + 1, dtype=f64)\n    neighbors[0] = qvector\n    offset = 1  # Indexes into current progress of filling buffer\n\n    # We extend the range of stds to try to find neighbors\n    if (\n        std == DEFAULT_VECTORIZED_NUMERIC_STD\n        and n_retries == NEIGHBOR_GENERATOR_N_RETRIES\n    ):\n        stds = _CACHED_LINSPACE\n    else:\n        stds = np.linspace(std, 1.0, n_retries + 1, endpoint=True)\n\n    range_size = upper - lower\n    for _std in stds:\n        # Generate candidates in vectorized space\n        candidates = seed.normal(qvector, _std * range_size, size=SAMPLE_SIZE)\n        valid_candidates = candidates[(candidates &gt;= lower) &amp; (candidates &lt;= upper)]\n\n        # Transform to quantized space\n        candidates_quantized = quantize(\n            valid_candidates,\n            bounds=(lower, upper),\n            bins=steps,\n        )\n\n        uniq = np.unique(candidates_quantized)\n        new_uniq = np.setdiff1d(uniq, neighbors[:offset], assume_unique=True)\n\n        n_new_unique = len(new_uniq)\n        neighbors[offset : offset + n_new_unique] = new_uniq\n        offset += n_new_unique\n\n        # We have enough neighbors, we can stop\n        if offset - 1 &gt;= n:\n            # Ensure we don't include the initial value point\n            return neighbors[1 : n + 1]\n\n    raise ValueError(\n        f\"Failed to find enough neighbors with {n_retries} retries.\"\n        f\" Given {n=} neighbors to generate, we only found {offset - 1}.\"\n        f\" The normal's for sampling neighbors were Normal({vector}, {list(stds)})\"\n        f\" which were meant to find neighbors of {vector}. in the range\"\n        f\" ({self.lower_vectorized}, {self.upper_vectorized}).\",\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerDistribution.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Calculate the probability density function (pdf) of all elements in <code>vector</code>.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to calculate the pdf for.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The pdf of all elements in <code>vector</code>. If an element is outside the bounds defined by <code>(0, size - 1)</code> the pdf is 0. If the element is not close to an integer, the pdf is 0.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Calculate the probability density function (pdf) of all elements in `vector`.\n\n    Args:\n        vector: The vectorized values to calculate the pdf for.\n\n    Returns:\n        The pdf of all elements in `vector`. If an element is outside the bounds\n        defined by `(0, size - 1)` the pdf is 0. If the element is not close to\n        an integer, the pdf is 0.\n    \"\"\"\n    # By definition, we don't allow NaNs in the pdf\n    valid_mask = (\n        (vector &gt;= self.lower_vectorized)\n        &amp; (vector &lt;= self.upper_vectorized)\n        &amp; is_close_to_integer(vector, atol=ATOL)\n    )\n    return np.where(valid_mask, self.max_density(), 0)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerDistribution.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    n: int, *, seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample <code>n</code> values from the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def sample_vector(\n    self,\n    n: int,\n    *,\n    seed: RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample `n` values from the distribution.\"\"\"\n    seed = np.random.RandomState() if seed is None else seed\n    ints = seed.randint(low=0, high=self.size, size=n, dtype=i64)\n    return ints.astype(f64)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerNormalizedDistribution","title":"UniformIntegerNormalizedDistribution  <code>dataclass</code>","text":"<pre><code>UniformIntegerNormalizedDistribution(size: int)\n</code></pre> <p>               Bases: <code>Distribution</code></p> <p>A uniform over (0, 1) that is quantized to provide <code>size</code> different bins.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerNormalizedDistribution.lower_vectorized","title":"lower_vectorized  <code>instance-attribute</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>The lower bound of the vectorized space.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerNormalizedDistribution.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre> <p>The number of steps to discretize the distribution into.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerNormalizedDistribution.upper_vectorized","title":"upper_vectorized  <code>instance-attribute</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>The lower bound of the vectorized space.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerNormalizedDistribution.max_density","title":"max_density","text":"<pre><code>max_density() -&gt; float\n</code></pre> <p>Return the maximum density of the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def max_density(self) -&gt; float:\n    \"\"\"Return the maximum density of the distribution.\"\"\"\n    return 1 / self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerNormalizedDistribution.neighborhood","title":"neighborhood","text":"<pre><code>neighborhood(\n    vector: f64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None,\n    n_retries: int = NEIGHBOR_GENERATOR_N_RETRIES,\n    sample_multiplier: int = NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER\n) -&gt; Array[f64]\n</code></pre> <p>Please see <code>quantized_neighborhood</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def neighborhood(\n    self,\n    vector: f64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None,\n    n_retries: int = NEIGHBOR_GENERATOR_N_RETRIES,\n    sample_multiplier: int = NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER,\n) -&gt; Array[f64]:\n    \"\"\"Please see [`quantized_neighborhood`][ConfigSpace.hyperparameters.distributions.quantized_neighborhood].\"\"\"  # noqa: E501\n    return quantized_neighborhood(\n        vector,\n        n,\n        std=std,\n        seed=seed,\n        n_retries=n_retries,\n        sample_multiplier=sample_multiplier,\n        lower=self.lower_vectorized,\n        upper=self.upper_vectorized,\n        bins=self.size,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerNormalizedDistribution.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Calculate the probability density function (pdf) of all elements in <code>vector</code>.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to calculate the pdf for.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The pdf of all elements in <code>vector</code>. If an element is outside the bounds of <code>(0, 1)</code>, or does not fall onto one of the quantized bins, the <code>pdf</code> is <code>0</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Calculate the probability density function (pdf) of all elements in `vector`.\n\n    Args:\n        vector: The vectorized values to calculate the pdf for.\n\n    Returns:\n        The pdf of all elements in `vector`. If an element is outside the bounds\n        of `(0, 1)`, or does not fall onto one of the quantized bins,\n        the `pdf` is `0`.\n    \"\"\"\n    valid_mask = (\n        (vector &gt;= self.lower_vectorized)\n        &amp; (vector &lt;= self.upper_vectorized)\n        &amp; is_close_to_integer(vector * (self.size - 1), atol=ATOL)\n    )\n    return np.where(valid_mask, self.max_density(), 0)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UniformIntegerNormalizedDistribution.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    n: int, *, seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample <code>n</code> values from the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def sample_vector(\n    self,\n    n: int,\n    *,\n    seed: RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample `n` values from the distribution.\"\"\"\n    seed = np.random.RandomState() if seed is None else seed\n    ints = seed.randint(low=0, high=self.size, size=n, dtype=i64)\n    return np.true_divide(ints, (self.size - 1), dtype=f64)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UnitUniformContinuousDistribution","title":"UnitUniformContinuousDistribution  <code>dataclass</code>","text":"<pre><code>UnitUniformContinuousDistribution(pdf_max_density: float)\n</code></pre> <p>               Bases: <code>Distribution</code></p> <p>A uniform distribution over the unit interval (0, 1).</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UnitUniformContinuousDistribution.lower_vectorized","title":"lower_vectorized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lower_vectorized: f64 = field(init=False)\n</code></pre> <p>The lower bound of the vectorized space. In this case always 0.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UnitUniformContinuousDistribution.pdf_max_density","title":"pdf_max_density  <code>instance-attribute</code>","text":"<pre><code>pdf_max_density: float\n</code></pre> <p>The maximum density of the distribution provided by the consumer of this</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UnitUniformContinuousDistribution.upper_vectorized","title":"upper_vectorized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>upper_vectorized: f64 = field(init=False)\n</code></pre> <p>The upper bound of the vectorized space. In this case always 1.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UnitUniformContinuousDistribution.max_density","title":"max_density","text":"<pre><code>max_density() -&gt; float\n</code></pre> <p>Return the maximum density of the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def max_density(self) -&gt; float:\n    \"\"\"Return the maximum density of the distribution.\"\"\"\n    return self.pdf_max_density\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UnitUniformContinuousDistribution.neighborhood","title":"neighborhood","text":"<pre><code>neighborhood(\n    vector: f64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None,\n    n_retries: int = NEIGHBOR_GENERATOR_N_RETRIES,\n    sample_multiplier: int = NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER\n) -&gt; Array[f64]\n</code></pre> <p>Please see <code>continuous_neighborhood</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def neighborhood(\n    self,\n    vector: f64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None,\n    n_retries: int = NEIGHBOR_GENERATOR_N_RETRIES,\n    sample_multiplier: int = NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER,\n) -&gt; Array[f64]:\n    \"\"\"Please see [`continuous_neighborhood`][ConfigSpace.hyperparameters.distributions.continuous_neighborhood].\"\"\"  # noqa: E501\n    return continuous_neighborhood(\n        vector,\n        n,\n        std=std,\n        seed=seed,\n        n_retries=n_retries,\n        sample_multiplier=sample_multiplier,\n        lower=self.lower_vectorized,\n        upper=self.upper_vectorized,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UnitUniformContinuousDistribution.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Calculate the probability density function (pdf) of all elements in <code>vector</code>.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to calculate the pdf for.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The pdf of all elements in <code>vector</code>. If an element is outside the bounds defined by <code>(0, 1)</code> the pdf is 0.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    # By definition, we don't allow NaNs in the pdf\n    \"\"\"Calculate the probability density function (pdf) of all elements in `vector`.\n\n    Args:\n        vector: The vectorized values to calculate the pdf for.\n\n    Returns:\n        The pdf of all elements in `vector`. If an element is outside the bounds\n        defined by `(0, 1)` the pdf is 0.\n    \"\"\"\n    return np.where(\n        (vector &gt;= self.lower_vectorized) &amp; (vector &lt;= self.upper_vectorized),\n        self.pdf_max_density,\n        0,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.UnitUniformContinuousDistribution.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    n: int, *, seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample <code>n</code> values from the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def sample_vector(\n    self,\n    n: int,\n    *,\n    seed: RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample `n` values from the distribution.\"\"\"\n    seed = np.random.RandomState() if seed is None else seed\n    return seed.uniform(self.lower_vectorized, self.upper_vectorized, size=n)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.WeightedIntegerDiscreteDistribution","title":"WeightedIntegerDiscreteDistribution  <code>dataclass</code>","text":"<pre><code>WeightedIntegerDiscreteDistribution(\n    size: int, probabilities: Array[f64]\n)\n</code></pre> <p>               Bases: <code>Distribution</code></p> <p>A discrete distribution over integers with weights to each.</p> <p>This can be primarily used for defining a weighted distribution over a set of choices, like a <code>Categorical</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.WeightedIntegerDiscreteDistribution.lower_vectorized","title":"lower_vectorized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lower_vectorized: f64 = field(init=False)\n</code></pre> <p>The lower bound of the vectorized space. In this case always 0.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.WeightedIntegerDiscreteDistribution.probabilities","title":"probabilities  <code>instance-attribute</code>","text":"<pre><code>probabilities: Array[f64]\n</code></pre> <p>The probabilities of each integer in the range <code>[0, size - 1]</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.WeightedIntegerDiscreteDistribution.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre> <p>The number of steps to discretize the distribution into.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.WeightedIntegerDiscreteDistribution.upper_vectorized","title":"upper_vectorized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>upper_vectorized: f64 = field(init=False)\n</code></pre> <p>The upper bound of the vectorized space. In this case <code>size - 1</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.WeightedIntegerDiscreteDistribution.max_density","title":"max_density","text":"<pre><code>max_density() -&gt; float\n</code></pre> <p>Return the maximum density of the distribution.</p> <p>In this case, it will be the maximum probability provided.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def max_density(self) -&gt; float:\n    \"\"\"Return the maximum density of the distribution.\n\n    In this case, it will be the maximum probability provided.\n    \"\"\"\n    return float(self._max_density)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.WeightedIntegerDiscreteDistribution.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Calculate the probability density function (pdf) of all elements in <code>vector</code>.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to calculate the pdf for.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The pdf of all elements in <code>vector</code>. If an element is outside the bounds defined by <code>(0, size - 1)</code> the pdf is 0. If the element is not close to an integer, the pdf is 0.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Calculate the probability density function (pdf) of all elements in `vector`.\n\n    Args:\n        vector: The vectorized values to calculate the pdf for.\n\n    Returns:\n        The pdf of all elements in `vector`. If an element is outside the bounds\n        defined by `(0, size - 1)` the pdf is 0. If the element is not close to\n        an integer, the pdf is 0.\n    \"\"\"\n    # By definition, we don't allow NaNs in the pdf\n    valid_mask = (\n        (vector &gt;= self.lower_vectorized)\n        &amp; (vector &lt;= self.upper_vectorized)\n        &amp; is_close_to_integer(vector, atol=ATOL)\n    )\n\n    # Bring it all into range to index by\n    nan_filled: Array[f64] = np.nan_to_num(vector, nan=0)\n    xx: Array[i64] = np.clip(nan_filled, 0, self.size - 1).astype(np.intp)\n    pdf = self.probabilities[xx]\n    return np.where(valid_mask, pdf, 0)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.WeightedIntegerDiscreteDistribution.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    n: int, *, seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample <code>n</code> values from the distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def sample_vector(\n    self,\n    n: int,\n    *,\n    seed: RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample `n` values from the distribution.\"\"\"\n    seed = np.random.RandomState() if seed is None else seed\n    return seed.choice(\n        self.size,\n        size=n,\n        p=self.probabilities,\n        replace=True,\n    )  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.continuous_neighborhood","title":"continuous_neighborhood","text":"<pre><code>continuous_neighborhood(\n    vector: f64,\n    n: int,\n    *,\n    lower: f64,\n    upper: f64,\n    std: float | None = None,\n    seed: RandomState | None = None,\n    n_retries: int = NEIGHBOR_GENERATOR_N_RETRIES,\n    sample_multiplier: int = NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER\n) -&gt; Array[f64]\n</code></pre> <p>Create a neighborhood of <code>n</code> neighbors around <code>vector</code> with a normal distribution.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The center of the neighborhood.</p> <p> TYPE: <code>f64</code> </p> <code>n</code> <p>The number of neighbors to generate.</p> <p> TYPE: <code>int</code> </p> <code>lower</code> <p>The lower bound of the neighborhood range.</p> <p> TYPE: <code>f64</code> </p> <code>upper</code> <p>The upper bound of the neighborhood range.</p> <p> TYPE: <code>f64</code> </p> <code>std</code> <p>The standard deviation of the normal distribution. If <code>None</code> will use <code>DEFAULT_VECTORIZED_NUMERIC_STD</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random seed to use.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> <code>n_retries</code> <p>The number of retries to attempt to generate unique neighbors. Each retry increases the standard deviation of the normal distribution to prevent rejection sampling from failing.</p> <p> TYPE: <code>int</code> DEFAULT: <code>NEIGHBOR_GENERATOR_N_RETRIES</code> </p> <code>sample_multiplier</code> <p>A multiplier which multiplies by <code>n</code> to determine the number of samples to generate for try. By oversampling, we prevent having to repeated calls to sampling. This prevents having to do more rounds of sampling when too many samples are out of bounds, useful for when the <code>vector</code> is near the bounds.</p> <p>Tuning this may be beneficial in unique circumstances, however we advise leaving this as a default.</p> <p> TYPE: <code>int</code> DEFAULT: <code>NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>An array of <code>n</code> neighbors around <code>vector</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def continuous_neighborhood(\n    vector: f64,\n    n: int,\n    *,\n    lower: f64,\n    upper: f64,\n    std: float | None = None,\n    seed: RandomState | None = None,\n    n_retries: int = NEIGHBOR_GENERATOR_N_RETRIES,\n    sample_multiplier: int = NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER,\n) -&gt; Array[f64]:\n    \"\"\"Create a neighborhood of `n` neighbors around `vector` with a normal distribution.\n\n    Args:\n        vector: The center of the neighborhood.\n        n: The number of neighbors to generate.\n        lower: The lower bound of the neighborhood range.\n        upper: The upper bound of the neighborhood range.\n        std: The standard deviation of the normal distribution. If `None` will use\n            [`DEFAULT_VECTORIZED_NUMERIC_STD`][ConfigSpace.hyperparameters.distributions.DEFAULT_VECTORIZED_NUMERIC_STD].\n        seed: The random seed to use.\n        n_retries:\n            The number of retries to attempt to generate unique neighbors.\n            Each retry increases the standard deviation of the normal distribution to\n            prevent rejection sampling from failing.\n        sample_multiplier:\n            A multiplier which multiplies by `n` to determine the number of samples to\n            generate for try. By oversampling, we prevent having to repeated calls to\n            sampling. This prevents having to do more rounds of sampling when too many\n            samples are out of bounds, useful for when the `vector` is near the bounds.\n\n            Tuning this may be beneficial in unique circumstances, however we advise\n            leaving this as a default.\n\n    Returns:\n        An array of `n` neighbors around `vector`.\n    \"\"\"  # noqa: E501\n    if std is None:\n        std = DEFAULT_VECTORIZED_NUMERIC_STD\n\n    seed = np.random.RandomState() if seed is None else seed\n\n    SAMPLE_SIZE = n * sample_multiplier\n    BUFFER_SIZE = n + n * sample_multiplier\n    neighbors: Array[f64] = np.empty(BUFFER_SIZE, dtype=f64)\n    offset = 0\n\n    # We extend the range of stds to try to find neighbors\n    if (\n        std == DEFAULT_VECTORIZED_NUMERIC_STD\n        and n_retries == NEIGHBOR_GENERATOR_N_RETRIES\n    ):\n        stds = _CACHED_LINSPACE\n    else:\n        stds = np.linspace(std, 1.0, n_retries + 1, endpoint=True)\n\n    # Generate batches of n * BUFFER_MULTIPLIER candidates, filling the above\n    # buffer until we have enough valid candidates.\n    # We should not overflow as the buffer\n    range_size = upper - lower\n\n    for _std in stds:\n        candidates = seed.normal(vector, _std * range_size, size=(SAMPLE_SIZE,))\n\n        # Select all those which are not at the lower boundary\n        valid_mask = np.logical_and(candidates &gt;= lower, candidates &lt;= upper)\n        valid_candidates = candidates[valid_mask]\n        n_candidates = len(valid_candidates)\n        neighbors[offset : offset + n_candidates] = valid_candidates\n        offset += n_candidates\n\n        # We have enough neighbors, we can stop and return the vectorized values\n        if offset &gt;= n:\n            return neighbors[:n]\n\n    raise ValueError(\n        f\"Failed to find enough neighbors with {n_retries} retries.\"\n        f\" Given {n} neighbors, we only found {offset}.\"\n        f\" The `Normals` for sampling neighbors were\"\n        f\" Normal(mu={vector}, sigma={list(stds)})\"\n        f\" which were meant to find vectorized neighbors of the vector {vector},\"\n        \" which was expected to be in the range\"\n        f\" ({lower}, {lower}).\",\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/distributions/#ConfigSpace.hyperparameters.distributions.quantized_neighborhood","title":"quantized_neighborhood","text":"<pre><code>quantized_neighborhood(\n    vector: f64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None,\n    n_retries: int = NEIGHBOR_GENERATOR_N_RETRIES,\n    sample_multiplier: int = NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER,\n    lower: f64,\n    upper: f64,\n    bins: int\n) -&gt; Array[f64]\n</code></pre> <p>Create a neighborhood of <code>n</code> neighbors around <code>vector</code> with a normal distribution.</p> <p>The neighborhood is created by sampling from a normal distribution centered around <code>vector</code> with a standard deviation of <code>std</code>. The samples are then quantized to the range <code>[lower, upper]</code> with <code>bins</code> bins. The number of samples is <code>n</code>.</p> <p>Warning</p> <p>If there are not enough unique neighbors to sample from, the function will return less than <code>n</code> neighbors.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The center of the neighborhood.</p> <p> TYPE: <code>f64</code> </p> <code>n</code> <p>The number of neighbors to generate.</p> <p> TYPE: <code>int</code> </p> <code>lower</code> <p>The lower bound of the quantized range.</p> <p> TYPE: <code>f64</code> </p> <code>upper</code> <p>The upper bound of the quantized range.</p> <p> TYPE: <code>f64</code> </p> <code>bins</code> <p>The number of bins to quantize the samples into.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the normal distribution. If <code>None</code> will use <code>DEFAULT_VECTORIZED_NUMERIC_STD</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random seed to use.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> <code>n_retries</code> <p>The number of retries to attempt to generate unique neighbors. Each retry increases the standard deviation of the normal distribution to prevent rejection sampling from failing.</p> <p> TYPE: <code>int</code> DEFAULT: <code>NEIGHBOR_GENERATOR_N_RETRIES</code> </p> <code>sample_multiplier</code> <p>A multiplier which multiplies by <code>n</code> to determine the number of samples to generate for try. By oversampling, we prevent having to repeated calls to both sampling and unique checking.</p> <p>However, oversampling makes a tradeoff when the <code>std</code> is not high enough to generate <code>n</code> unique neighbors, effectively sampling more of the same duplicates.</p> <p>Tuning this may be beneficial in unique circumstances, however we advise leaving this as a default.</p> <p> TYPE: <code>int</code> DEFAULT: <code>NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>An array of <code>n</code> neighbors around <code>vector</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/distributions.py</code> <pre><code>def quantized_neighborhood(\n    vector: f64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None,\n    n_retries: int = NEIGHBOR_GENERATOR_N_RETRIES,\n    sample_multiplier: int = NEIGHBOR_GENERATOR_SAMPLE_MULTIPLIER,\n    lower: f64,\n    upper: f64,\n    bins: int,\n) -&gt; Array[f64]:\n    \"\"\"Create a neighborhood of `n` neighbors around `vector` with a normal distribution.\n\n    The neighborhood is created by sampling from a normal distribution centered around\n    `vector` with a standard deviation of `std`. The samples are then quantized to the\n    range `[lower, upper]` with `bins` bins. The number of samples is `n`.\n\n    !!! warning\n\n        If there are not enough unique neighbors to sample from, the function will\n        return less than `n` neighbors.\n\n    Args:\n        vector: The center of the neighborhood.\n        n: The number of neighbors to generate.\n        lower: The lower bound of the quantized range.\n        upper: The upper bound of the quantized range.\n        bins: The number of bins to quantize the samples into.\n        std: The standard deviation of the normal distribution. If `None` will use\n            [`DEFAULT_VECTORIZED_NUMERIC_STD`][ConfigSpace.hyperparameters.distributions.DEFAULT_VECTORIZED_NUMERIC_STD].\n        seed: The random seed to use.\n        n_retries:\n            The number of retries to attempt to generate unique neighbors.\n            Each retry increases the standard deviation of the normal distribution to prevent\n            rejection sampling from failing.\n        sample_multiplier:\n            A multiplier which multiplies by `n` to determine the number of samples to\n            generate for try. By oversampling, we prevent having to repeated calls to\n            both sampling and unique checking.\n\n            However, oversampling makes a tradeoff when the `std` is not high enough to\n            generate `n` unique neighbors, effectively sampling more of the same duplicates.\n\n            Tuning this may be beneficial in unique circumstances, however we advise leaving\n            this as a default.\n\n    Returns:\n        An array of `n` neighbors around `vector`.\n    \"\"\"  # noqa: E501\n    if std is None:\n        std = DEFAULT_VECTORIZED_NUMERIC_STD\n\n    assert n &lt; 1000000, \"Can only generate less than 1 million neighbors.\"\n    seed = np.random.RandomState() if seed is None else seed\n\n    qvector = quantize(vector, bounds=(lower, upper), bins=bins)\n\n    # In the easiest case, the amount of neighbors we need is more than the amount\n    # possible, in this case, we can skip our sampling and just generate all\n    # neighbors, excluding the current value\n    n_available = bins - 1\n    if n &gt;= n_available:\n        if qvector == 0:\n            return np.arange(1, bins) / (bins - 1)\n        if qvector == bins - 1:\n            return np.arange(0, bins - 1) / (bins - 1)\n\n        qint = i64(np.rint(vector * (bins - 1)))\n\n        _range: Array[f64] = np.arange(0, bins, dtype=np.float64)\n        bot = _range[:qint]\n        top = _range[qint + 1 :]\n        return np.concatenate((bot, top)) / (bins - 1)  # type: ignore\n\n    # Otherwise, we use a repeated sampling strategy where we slowly increase the\n    # std of a normal, centered on `center`, slowly expanding `std` such that\n    # rejection won't fail.\n\n    # We set up a buffer that can hold the number of neighbors we need, plus some\n    # extra excess from sampling, preventing us from having to reallocate memory.\n    # We also include the initial value in the buffer, as we will remove it later.\n    # OPTIM: If you really need to optimize this more, one could consider using `bins`\n    # as the more bins there are, the less need there is over sample for uniques\n    SAMPLE_SIZE = n * sample_multiplier\n    BUFFER_SIZE = n * (sample_multiplier + 1)\n    neighbors: Array[f64] = np.empty(BUFFER_SIZE + 1, dtype=f64)\n    neighbors[0] = qvector\n    offset = 1  # Indexes into current progress of filling buffer\n\n    # We extend the range of stds to try to find neighbors\n    if (\n        std == DEFAULT_VECTORIZED_NUMERIC_STD\n        and n_retries == NEIGHBOR_GENERATOR_N_RETRIES\n    ):\n        stds = _CACHED_LINSPACE\n    else:\n        stds = np.linspace(std, 1.0, n_retries + 1, endpoint=True)\n\n    range_size = upper - lower\n    for _std in stds:\n        # Generate candidates in vectorized space\n        candidates = seed.normal(qvector, _std * range_size, size=SAMPLE_SIZE)\n        valid_candidates = candidates[(candidates &gt;= lower) &amp; (candidates &lt;= upper)]\n\n        # Transform to quantized space\n        candidates_quantized = quantize(\n            valid_candidates,\n            bounds=(lower, upper),\n            bins=bins,\n        )\n\n        uniq = np.unique(candidates_quantized)\n        new_uniq = np.setdiff1d(uniq, neighbors[:offset], assume_unique=True)\n\n        n_new_unique = len(new_uniq)\n        neighbors[offset : offset + n_new_unique] = new_uniq\n        offset += n_new_unique\n\n        # We have enough neighbors, we can stop\n        if offset - 1 &gt;= n:\n            # Ensure we don't include the initial value point\n            return neighbors[1 : n + 1]\n\n    raise ValueError(\n        f\"Failed to find enough neighbors with {n_retries} retries.\"\n        f\" Given {n=} neighbors to generate, we only found {offset - 1}.\"\n        f\" The normal's for sampling neighbors were Normal({vector}, {list(stds)})\"\n        f\" which were meant to find neighbors of {vector}. in the range\"\n        f\" ({lower}, {upper}).\",\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/","title":"Float hyperparameter","text":""},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter","title":"ConfigSpace.hyperparameters.float_hyperparameter","text":""},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter","title":"FloatHyperparameter  <code>dataclass</code>","text":"<pre><code>FloatHyperparameter()\n</code></pre> <p>               Bases: <code>NumericalHyperparameter[float, f64]</code></p> <p>Base class for float hyperparameters in the configuration space.</p>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.ORDERABLE","title":"ORDERABLE  <code>class-attribute</code>","text":"<pre><code>ORDERABLE: bool = False\n</code></pre> <p>If the hyperparameter values have an order. This is used for conditionals and forbiddens relying on relationships.</p>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: ValueT = default_value\n</code></pre> <p>The default value of this hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: bool\n</code></pre> <p>If <code>True</code> the hyperparameter is sampled on a logarithmic scale.</p>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: NumberT\n</code></pre> <p>Lower bound of the hyperparameter in value space.</p>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None = meta\n</code></pre> <p>Field for holding meta data provided by the user. Not used by the ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int | float = size\n</code></pre> <p>Size of the hyperparameter. For integer and choice hyperparameters this is the number of possible values the hyperparameter can take on within the specified range. For continuous hyperparameters this is usually <code>np.inf</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: NumberT\n</code></pre> <p>Upper bound of the hyperparameter in value space.</p>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.legal_value","title":"legal_value","text":"<pre><code>legal_value(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; bool | Mask\n</code></pre> <p>Check if a value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>bool | Mask</code> <p><code>True</code> if the value is legal, <code>False</code> otherwise. If <code>value</code> is an array of values, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_value(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; bool | Mask:\n    \"\"\"Check if a value is legal for this hyperparameter.\n\n    Args:\n        value:\n            The value to check.\n\n    Returns:\n        `True` if the value is legal, `False` otherwise. If `value` is an\n        array of values, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.legal_value(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.legal_value(np.asarray(value))\n\n    return self._transformer.legal_value_single(value)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.pdf_values","title":"pdf_values","text":"<pre><code>pdf_values(\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of values.</p> PARAMETER DESCRIPTION <code>values</code> <p>The values to get the probability density of.</p> <p> TYPE: <code>Sequence[ValueT | DType] | Array[DType]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the values. Where values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_values(\n    self,\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of values.\n\n    Args:\n        values:\n            The values to get the probability density of.\n\n    Returns:\n        The probability density of the values. Where values are not legal,\n        the probability density is zero.\n    \"\"\"\n    if isinstance(values, np.ndarray) and values.ndim != 1:\n        raise ValueError(\"Method pdf expects a one-dimensional numpy array\")\n\n    vector = self.to_vector(values)\n    return self.pdf_vector(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.to_uniform","title":"to_uniform","text":"<pre><code>to_uniform() -&gt; UniformFloatHyperparameter\n</code></pre> <p>Convert the hyperparameter to its uniform equivalent.</p> <p>This will remove any distribution associated with it's vectorized representation.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_uniform(self) -&gt; UniformFloatHyperparameter:\n    \"\"\"Convert the hyperparameter to its uniform equivalent.\n\n    This will remove any distribution associated with it's vectorized\n    representation.\n    \"\"\"\n    from ConfigSpace.hyperparameters.uniform_float import UniformFloatHyperparameter\n\n    return UniformFloatHyperparameter(\n        name=self.name,\n        lower=self.lower,\n        upper=self.upper,\n        default_value=self.default_value,\n        log=self.log,\n        meta=self.meta,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/float_hyperparameter/#ConfigSpace.hyperparameters.float_hyperparameter.FloatHyperparameter.to_vector","title":"to_vector","text":"<pre><code>to_vector(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Transform a value to a vectorized value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to transform.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The vectorized value.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_vector(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; f64 | Array[f64]:\n    \"\"\"Transform a value to a vectorized value.\n\n    Args:\n        value:\n            The value to transform.\n\n    Returns:\n        The vectorized value.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.to_vector(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.to_vector(np.asarray(value))\n\n    return self._transformer.to_vector(np.array([value]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/","title":"Hp components","text":""},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components","title":"ConfigSpace.hyperparameters.hp_components","text":""},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.Neighborhood","title":"Neighborhood","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for a neighborhood function.</p> <p>This protocol defines how to get the neighborhood of a value in a vectorized representation. This is used for the <code>neighborhood=</code> argument in the <code>ConfigSpace.hyperparameters.Hyperparameter</code> class, letting the hyperparameter know how to get the neighborhood of a vectorized value.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.Neighborhood.__call__","title":"__call__","text":"<pre><code>__call__(\n    vector: f64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Get the neighborhood of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to get the neighborhood of.</p> <p> TYPE: <code>f64</code> </p> <code>n</code> <p>The number of neighbors to get.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The seed for the random number generator.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/ConfigSpace/hyperparameters/hp_components.py</code> <pre><code>def __call__(\n    self,\n    vector: f64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Get the neighborhood of a vectorized value.\n\n    Args:\n        vector: The vectorized value to get the neighborhood of.\n        n: The number of neighbors to get.\n        std: The standard deviation of the neighborhood.\n        seed: The seed for the random number generator.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.Transformer","title":"Transformer","text":"<p>               Bases: <code>Protocol[DType]</code></p> <p>Protocol for a transformer.</p> <p>This protocol defines how to move from vectorized representation to value representation and vice versa. It also defines how to check if a value or vector is legal.</p> <p>With this it also include [<code>.lower_vectorized</code>][<code>ConfigSpace.hp_components.Transformer.lower_vectorized</code>] and [<code>.upper_vectorized</code>][<code>ConfigSpace.hp_components.Transformer.upper_vectorized</code>] which defines the upper and lower bounds of the vectorized representation.</p> <p>Note</p> <p>All vectorized representations should be of type <code>np.float64</code>, even if they are integer values. This helps with calculations and being able to store configurations in a single array.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.Transformer.lower_vectorized","title":"lower_vectorized  <code>instance-attribute</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the vectorized representation.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.Transformer.upper_vectorized","title":"upper_vectorized  <code>instance-attribute</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the vectorized representation.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.Transformer.legal_value","title":"legal_value","text":"<pre><code>legal_value(value: Array[DType]) -&gt; Mask\n</code></pre> <p>Returns a boolean mask of which values are legal.</p> Source code in <code>src/ConfigSpace/hyperparameters/hp_components.py</code> <pre><code>def legal_value(self, value: Array[DType]) -&gt; Mask:\n    \"\"\"Returns a boolean mask of which values are legal.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.Transformer.legal_value_single","title":"legal_value_single","text":"<pre><code>legal_value_single(value: number) -&gt; bool\n</code></pre> <p>Check if a single value is legal.</p> <p>This is used as an optimization instead of having to wrap a single value into an array and then unpack it.</p> Source code in <code>src/ConfigSpace/hyperparameters/hp_components.py</code> <pre><code>def legal_value_single(self, value: np.number) -&gt; bool:\n    \"\"\"Check if a single value is legal.\n\n    This is used as an optimization instead of having to wrap\n    a single value into an array and then unpack it.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.Transformer.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Array[f64]) -&gt; Mask\n</code></pre> <p>Returns a boolean mask of which vectors are legal.</p> Source code in <code>src/ConfigSpace/hyperparameters/hp_components.py</code> <pre><code>def legal_vector(self, vector: Array[f64]) -&gt; Mask:\n    \"\"\"Returns a boolean mask of which vectors are legal.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.Transformer.legal_vector_single","title":"legal_vector_single","text":"<pre><code>legal_vector_single(vector: number) -&gt; bool\n</code></pre> <p>Check if a single vector value is legal.</p> <p>This is used as an optimization instead of having to wrap a single vector value into an array and then unpack it.</p> Source code in <code>src/ConfigSpace/hyperparameters/hp_components.py</code> <pre><code>def legal_vector_single(self, vector: np.number) -&gt; bool:\n    \"\"\"Check if a single vector value is legal.\n\n    This is used as an optimization instead of having to wrap\n    a single vector value into an array and then unpack it.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.Transformer.to_value","title":"to_value","text":"<pre><code>to_value(vector: Array[f64]) -&gt; Array[DType]\n</code></pre> <p>Transform a vector representation into its value representation.</p> Source code in <code>src/ConfigSpace/hyperparameters/hp_components.py</code> <pre><code>def to_value(self, vector: Array[f64]) -&gt; Array[DType]:\n    \"\"\"Transform a vector representation into its value representation.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.Transformer.to_vector","title":"to_vector","text":"<pre><code>to_vector(value: Array[DType]) -&gt; Array[f64]\n</code></pre> <p>Transform a value representation into its vector representation.</p> Source code in <code>src/ConfigSpace/hyperparameters/hp_components.py</code> <pre><code>def to_vector(self, value: Array[DType]) -&gt; Array[f64]:\n    \"\"\"Transform a value representation into its vector representation.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.TransformerConstant","title":"TransformerConstant  <code>dataclass</code>","text":"<pre><code>TransformerConstant(\n    value: Any, vector_value_yes: f64, vector_value_no: f64\n)\n</code></pre> <p>               Bases: <code>Transformer[Any]</code></p> <p>Implementation of a transformer for a constant value.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.TransformerConstant.lower_vectorized","title":"lower_vectorized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lower_vectorized: f64 = field(init=False)\n</code></pre> <p>Lower bound of the vectorized representation.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.TransformerConstant.upper_vectorized","title":"upper_vectorized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>upper_vectorized: f64 = field(init=False)\n</code></pre> <p>Upper bound of the vectorized representation.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.TransformerConstant.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Any\n</code></pre> <p>The constant value.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.TransformerConstant.vector_value_no","title":"vector_value_no  <code>instance-attribute</code>","text":"<pre><code>vector_value_no: f64\n</code></pre> <p>The vectorized value for anything but the constant value.</p> <p>This is the value that represents anything but the constant value and is asserted to be less than the <code>vector_value_yes</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.TransformerConstant.vector_value_yes","title":"vector_value_yes  <code>instance-attribute</code>","text":"<pre><code>vector_value_yes: f64\n</code></pre> <p>The vectorized value for the constant value.</p> <p>This is the value that represents the constant value and is asserted to be greater than the <code>vector_value_no</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.TransformerSeq","title":"TransformerSeq  <code>dataclass</code>","text":"<pre><code>TransformerSeq(seq: Array[Any] | list[Any])\n</code></pre> <p>               Bases: <code>Transformer[Any]</code></p> <p>Implmentation of a transformer for a sequence of values.</p> <p>This uses an integer range from 0 to <code>len(seq) - 1</code> to represent the sequence of values in vectorized space.</p> <p>This is useful primarily for categorical and ordinal hyperparameters.</p> PARAMETER DESCRIPTION <code>seq</code> <p>The sequence of values to transform.</p> <p> TYPE: <code>Array[Any] | list[Any]</code> </p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.TransformerSeq.lower_vectorized","title":"lower_vectorized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lower_vectorized: f64 = field(init=False)\n</code></pre> <p>Lower bound of the vectorized representation.</p> <p>Always 0.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.TransformerSeq.seq","title":"seq  <code>instance-attribute</code>","text":"<pre><code>seq: Array[Any] | list[Any]\n</code></pre> <p>The original sequence of values.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.TransformerSeq.upper_vectorized","title":"upper_vectorized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>upper_vectorized: f64 = field(init=False)\n</code></pre> <p>Upper bound of the vectorized representation.</p> <p>Always <code>len(seq) - 1</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.UnitScaler","title":"UnitScaler  <code>dataclass</code>","text":"<pre><code>UnitScaler(\n    lower_value: DType,\n    upper_value: DType,\n    dtype: type[DType],\n    log: bool = False,\n)\n</code></pre> <p>               Bases: <code>Transformer[DType]</code></p> <p>Implementation of a transformer from a vectorized continuous range <code>(0, 1)</code> to another specified range in value space.</p> PARAMETER DESCRIPTION <code>lower_value</code> <p>Lower bound of the range.</p> <p> TYPE: <code>DType</code> </p> <code>upper_value</code> <p>Upper bound of the range.</p> <p> TYPE: <code>DType</code> </p> <code>dtype</code> <p>The type of the values in the range.</p> <p> TYPE: <code>type[DType]</code> </p> <code>log</code> <p>Whether to use a log scale or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.UnitScaler.dtype","title":"dtype  <code>instance-attribute</code>","text":"<pre><code>dtype: type[DType]\n</code></pre> <p>What type we should return when transforming to value space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.UnitScaler.log","title":"log  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log: bool = False\n</code></pre> <p>Whether to use a log scale or not.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.UnitScaler.lower_value","title":"lower_value  <code>instance-attribute</code>","text":"<pre><code>lower_value: DType\n</code></pre> <p>Lower bound of the value range.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.UnitScaler.lower_vectorized","title":"lower_vectorized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lower_vectorized: f64 = field(init=False)\n</code></pre> <p>Lower bound of the vectorized representation.</p> <p>Always 0.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.UnitScaler.upper_value","title":"upper_value  <code>instance-attribute</code>","text":"<pre><code>upper_value: DType\n</code></pre> <p>Upper bound of the value range.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.UnitScaler.upper_vectorized","title":"upper_vectorized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>upper_vectorized: f64 = field(init=False)\n</code></pre> <p>Lower bound of the vectorized representation.</p> <p>Always 1.</p>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.UnitScaler.to_value","title":"to_value","text":"<pre><code>to_value(vector: Array[f64]) -&gt; Array[DType]\n</code></pre> <p>Transform a value from the unit interval to the range.</p> Source code in <code>src/ConfigSpace/hyperparameters/hp_components.py</code> <pre><code>@override\ndef to_value(self, vector: Array[f64]) -&gt; Array[DType]:\n    \"\"\"Transform a value from the unit interval to the range.\"\"\"\n    unchecked_values = self._unsafe_to_value(vector)\n    if np.issubdtype(self.dtype, np.integer):\n        return unchecked_values.round().astype(self.dtype)\n\n    return np.clip(  # type: ignore\n        unchecked_values,\n        self._lower_value_f64,\n        self._upper_value_f64,\n        dtype=self.dtype,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.UnitScaler.vectorize_size","title":"vectorize_size","text":"<pre><code>vectorize_size(size: f64) -&gt; f64\n</code></pre> <p>Vectorize to the correct scale but is not necessarily in the range.</p> <p>Mainly useful for scaling things like <code>std</code> in value space to it's equivalent in vector space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hp_components.py</code> <pre><code>def vectorize_size(self, size: f64) -&gt; f64:\n    \"\"\"Vectorize to the correct scale but is not necessarily in the range.\n\n    Mainly useful for scaling things like `std` in value space to it's equivalent\n    in vector space.\n    \"\"\"\n    if self.log:\n        return np.abs(  # type: ignore\n            np.log(self._lower_value_f64 + size)\n            / (np.log(self._upper_value_f64) - np.log(self._lower_value_f64)),\n        )\n\n    return f64(size / self._size)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hp_components/#ConfigSpace.hyperparameters.hp_components.ordinal_neighborhood","title":"ordinal_neighborhood","text":"<pre><code>ordinal_neighborhood(\n    vector: f64,\n    n: int,\n    *,\n    size: int,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Get the neighborhood of a vectorized ordinal value.</p> <p>This is used for the <code>neighborhood=</code> argument in the <code>ConfigSpace.hyperparameters.OrdinalHyperparameter</code></p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to get the neighborhood of.</p> <p>Warning</p> <p>This is assumed to be an integer in the range <code>[0, size - 1]</code>.</p> <p> TYPE: <code>f64</code> </p> <code>n</code> <p>The number of neighbors to get.</p> <p> TYPE: <code>int</code> </p> <code>size</code> <p>The size of the sequence.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The seed for the random number generator.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The neighborhood of the vectorized value.</p> Source code in <code>src/ConfigSpace/hyperparameters/hp_components.py</code> <pre><code>def ordinal_neighborhood(\n    vector: f64,\n    n: int,\n    *,\n    size: int,\n    std: float | None = None,  # noqa: ARG001\n    seed: RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Get the neighborhood of a vectorized ordinal value.\n\n    This is used for the `neighborhood=` argument in the\n    [`ConfigSpace.hyperparameters.OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n\n    Args:\n        vector: The vectorized value to get the neighborhood of.\n\n            !!! warning\n\n                This is assumed to be an integer in the range `[0, size - 1]`.\n\n        n: The number of neighbors to get.\n        size: The size of the sequence.\n        std: The standard deviation of the neighborhood.\n        seed: The seed for the random number generator.\n\n    Returns:\n        The neighborhood of the vectorized value.\n    \"\"\"\n    end_index = size - 1\n    assert 0 &lt;= vector &lt;= end_index\n\n    # No neighbors if it's the only element\n    if size == 1:\n        return np.array([], dtype=f64)\n\n    # We have at least 2 elements,\n    # in this case it's only neighbor is the one beside it\n    # which is itself +1\n    if vector == 0:\n        return np.array([1.0], dtype=f64)\n\n    # Also only one neighbor for the other end\n    if np.rint(vector) == end_index:\n        return np.array([end_index - 1], dtype=f64)\n\n    # We have at least 3 elements and the value is not at the ends\n    neighbors: Array[f64] = np.rint([vector - 1, vector + 1], dtype=f64)\n    if n &gt;= 2:\n        return neighbors\n\n    seed = np.random.RandomState() if seed is None else seed\n    return np.array([seed.choice(neighbors)], dtype=f64)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/","title":"Hyperparameter","text":""},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter","title":"ConfigSpace.hyperparameters.hyperparameter","text":""},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumberT","title":"NumberT  <code>module-attribute</code>","text":"<pre><code>NumberT = TypeVar('NumberT', int, float)\n</code></pre> <p>Some number type that represents a single value in value space for a numerical hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter","title":"FloatHyperparameter  <code>dataclass</code>","text":"<pre><code>FloatHyperparameter()\n</code></pre> <p>               Bases: <code>NumericalHyperparameter[float, f64]</code></p> <p>Base class for float hyperparameters in the configuration space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.ORDERABLE","title":"ORDERABLE  <code>class-attribute</code>","text":"<pre><code>ORDERABLE: bool = False\n</code></pre> <p>If the hyperparameter values have an order. This is used for conditionals and forbiddens relying on relationships.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: ValueT = default_value\n</code></pre> <p>The default value of this hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: bool\n</code></pre> <p>If <code>True</code> the hyperparameter is sampled on a logarithmic scale.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: NumberT\n</code></pre> <p>Lower bound of the hyperparameter in value space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None = meta\n</code></pre> <p>Field for holding meta data provided by the user. Not used by the ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int | float = size\n</code></pre> <p>Size of the hyperparameter. For integer and choice hyperparameters this is the number of possible values the hyperparameter can take on within the specified range. For continuous hyperparameters this is usually <code>np.inf</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: NumberT\n</code></pre> <p>Upper bound of the hyperparameter in value space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.legal_value","title":"legal_value","text":"<pre><code>legal_value(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; bool | Mask\n</code></pre> <p>Check if a value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>bool | Mask</code> <p><code>True</code> if the value is legal, <code>False</code> otherwise. If <code>value</code> is an array of values, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_value(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; bool | Mask:\n    \"\"\"Check if a value is legal for this hyperparameter.\n\n    Args:\n        value:\n            The value to check.\n\n    Returns:\n        `True` if the value is legal, `False` otherwise. If `value` is an\n        array of values, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.legal_value(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.legal_value(np.asarray(value))\n\n    return self._transformer.legal_value_single(value)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.pdf_values","title":"pdf_values","text":"<pre><code>pdf_values(\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of values.</p> PARAMETER DESCRIPTION <code>values</code> <p>The values to get the probability density of.</p> <p> TYPE: <code>Sequence[ValueT | DType] | Array[DType]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the values. Where values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_values(\n    self,\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of values.\n\n    Args:\n        values:\n            The values to get the probability density of.\n\n    Returns:\n        The probability density of the values. Where values are not legal,\n        the probability density is zero.\n    \"\"\"\n    if isinstance(values, np.ndarray) and values.ndim != 1:\n        raise ValueError(\"Method pdf expects a one-dimensional numpy array\")\n\n    vector = self.to_vector(values)\n    return self.pdf_vector(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.to_uniform","title":"to_uniform","text":"<pre><code>to_uniform() -&gt; UniformFloatHyperparameter\n</code></pre> <p>Convert the hyperparameter to its uniform equivalent.</p> <p>This will remove any distribution associated with it's vectorized representation.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_uniform(self) -&gt; UniformFloatHyperparameter:\n    \"\"\"Convert the hyperparameter to its uniform equivalent.\n\n    This will remove any distribution associated with it's vectorized\n    representation.\n    \"\"\"\n    from ConfigSpace.hyperparameters.uniform_float import UniformFloatHyperparameter\n\n    return UniformFloatHyperparameter(\n        name=self.name,\n        lower=self.lower,\n        upper=self.upper,\n        default_value=self.default_value,\n        log=self.log,\n        meta=self.meta,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.FloatHyperparameter.to_vector","title":"to_vector","text":"<pre><code>to_vector(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Transform a value to a vectorized value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to transform.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The vectorized value.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_vector(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; f64 | Array[f64]:\n    \"\"\"Transform a value to a vectorized value.\n\n    Args:\n        value:\n            The value to transform.\n\n    Returns:\n        The vectorized value.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.to_vector(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.to_vector(np.asarray(value))\n\n    return self._transformer.to_vector(np.array([value]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter","title":"Hyperparameter  <code>dataclass</code>","text":"<pre><code>Hyperparameter(\n    name: str,\n    default_value: ValueT,\n    vector_dist: Distribution,\n    transformer: Transformer[DType],\n    neighborhood: Neighborhood,\n    size: int | float,\n    neighborhood_size: (\n        float\n        | int\n        | Callable[[DType | ValueT | None], int | float]\n    ),\n    value_cast: Callable[[DType], ValueT] | None,\n    meta: Mapping[Hashable, Any] | None = None,\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[ValueT, DType]</code></p> <p>Base class for all hyperparameters in the configuration space.</p> <p>Please see the reference page for more.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the hyperparameter, with which it can be accessed.</p> <p> TYPE: <code>str</code> </p> <code>default_value</code> <p>The default value of this hyperparameter.</p> <p> TYPE: <code>ValueT</code> </p> <code>vector_dist</code> <p>The distribution of the hyperparameter in vector space.</p> <p> TYPE: <code>Distribution</code> </p> <code>transformer</code> <p>The transformer to convert between value and vector space.</p> <p> TYPE: <code>Transformer[DType]</code> </p> <code>neighborhood</code> <p>The function to sample neighbors from the hyperparameter.</p> <p> TYPE: <code>Neighborhood</code> </p> <code>size</code> <p>Size of the hyperparameter. For integer and choice hyperparameters this is the number of possible values the hyperparameter can take on within the specified range. For continuous hyperparameters this is usually <code>np.inf</code>.</p> <p> TYPE: <code>int | float</code> </p> <code>neighborhood_size</code> <p>The number of neighbors to sample from the hyperparameter. This can be a fixed number or a function that takes the current value and returns the number of neighbors to sample.</p> <p> TYPE: <code>float | int | Callable[[DType | ValueT | None], int | float]</code> </p> <code>value_cast</code> <p>A function to cast the value to a different type. This is useful for ensuring when removing from a nunmpy array of hyperparameter values, that the type is preserved.</p> <p> TYPE: <code>Callable[[DType], ValueT] | None</code> </p> <code>meta</code> <p>Field for holding meta data provided by the user. Not used by the ConfigSpace.</p> <p> TYPE: <code>Mapping[Hashable, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    default_value: ValueT,\n    vector_dist: Distribution,\n    transformer: Transformer[DType],\n    neighborhood: Neighborhood,\n    size: int | float,\n    neighborhood_size: float | int | Callable[[DType | ValueT | None], int | float],\n    value_cast: Callable[[DType], ValueT] | None,\n    meta: Mapping[Hashable, Any] | None = None,\n) -&gt; None:\n    \"\"\"Initialize a hyperparameter.\n\n    Args:\n        name:\n            Name of the hyperparameter, with which it can be accessed.\n        default_value:\n            The default value of this hyperparameter.\n        vector_dist:\n            The distribution of the hyperparameter in vector space.\n        transformer:\n            The transformer to convert between value and vector space.\n        neighborhood:\n            The function to sample neighbors from the hyperparameter.\n        size:\n            Size of the hyperparameter. For integer and choice hyperparameters\n            this is the number of possible values the hyperparameter can take on\n            within the specified range. For continuous hyperparameters this is\n            usually `np.inf`.\n        neighborhood_size:\n            The number of neighbors to sample from the hyperparameter. This can\n            be a fixed number or a function that takes the current value and\n            returns the number of neighbors to sample.\n        value_cast:\n            A function to cast the value to a different type. This is useful\n            for ensuring when removing from a nunmpy array of hyperparameter values,\n            that the type is preserved.\n        meta:\n            Field for holding meta data provided by the user. Not used by the\n            ConfigSpace.\n    \"\"\"\n    if not isinstance(name, str):\n        raise TypeError(\n            f\"Name must be a string, got {name} ({type(name)})\",\n        )\n\n    self.name = name\n    self.default_value = default_value\n    self.meta = meta\n    self.size = size\n\n    self._vector_dist = vector_dist\n    self._transformer = transformer\n    self._neighborhood = neighborhood\n    self._neighborhood_size = neighborhood_size  # type: ignore\n    self._value_cast = value_cast\n\n    if not self.legal_value(self.default_value):\n        raise ValueError(\n            f\"Illegal default value {self.default_value} for\"\n            f\" hyperparamter '{self.name}'.\",\n        )\n\n    self._normalized_default_value = self.to_vector(self.default_value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.LEGAL_VALUE_TYPES","title":"LEGAL_VALUE_TYPES  <code>class-attribute</code>","text":"<pre><code>LEGAL_VALUE_TYPES: tuple[type, ...] | Literal[\"all\"] = \"all\"\n</code></pre> <p>The types of values that are legal for this hyperparameter. If set to <code>\"all\"</code> any type is legal. Otherwise, a tuple of types can be provided.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.ORDERABLE","title":"ORDERABLE  <code>class-attribute</code>","text":"<pre><code>ORDERABLE: bool = False\n</code></pre> <p>If the hyperparameter values have an order. This is used for conditionals and forbiddens relying on relationships.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: ValueT = default_value\n</code></pre> <p>The default value of this hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None = meta\n</code></pre> <p>Field for holding meta data provided by the user. Not used by the ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int | float = size\n</code></pre> <p>Size of the hyperparameter. For integer and choice hyperparameters this is the number of possible values the hyperparameter can take on within the specified range. For continuous hyperparameters this is usually <code>np.inf</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.legal_value","title":"legal_value","text":"<pre><code>legal_value(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; bool | Mask\n</code></pre> <p>Check if a value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>bool | Mask</code> <p><code>True</code> if the value is legal, <code>False</code> otherwise. If <code>value</code> is an array of values, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_value(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; bool | Mask:\n    \"\"\"Check if a value is legal for this hyperparameter.\n\n    Args:\n        value:\n            The value to check.\n\n    Returns:\n        `True` if the value is legal, `False` otherwise. If `value` is an\n        array of values, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.legal_value(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.legal_value(np.asarray(value))\n\n    return self._transformer.legal_value_single(value)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.pdf_values","title":"pdf_values","text":"<pre><code>pdf_values(\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of values.</p> PARAMETER DESCRIPTION <code>values</code> <p>The values to get the probability density of.</p> <p> TYPE: <code>Sequence[ValueT | DType] | Array[DType]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the values. Where values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_values(\n    self,\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of values.\n\n    Args:\n        values:\n            The values to get the probability density of.\n\n    Returns:\n        The probability density of the values. Where values are not legal,\n        the probability density is zero.\n    \"\"\"\n    if isinstance(values, np.ndarray) and values.ndim != 1:\n        raise ValueError(\"Method pdf expects a one-dimensional numpy array\")\n\n    vector = self.to_vector(values)\n    return self.pdf_vector(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.Hyperparameter.to_vector","title":"to_vector","text":"<pre><code>to_vector(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Transform a value to a vectorized value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to transform.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The vectorized value.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_vector(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; f64 | Array[f64]:\n    \"\"\"Transform a value to a vectorized value.\n\n    Args:\n        value:\n            The value to transform.\n\n    Returns:\n        The vectorized value.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.to_vector(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.to_vector(np.asarray(value))\n\n    return self._transformer.to_vector(np.array([value]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter","title":"IntegerHyperparameter  <code>dataclass</code>","text":"<pre><code>IntegerHyperparameter()\n</code></pre> <p>               Bases: <code>NumericalHyperparameter[int, i64]</code></p> <p>Base class for integer hyperparameters in the configuration space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.ORDERABLE","title":"ORDERABLE  <code>class-attribute</code>","text":"<pre><code>ORDERABLE: bool = False\n</code></pre> <p>If the hyperparameter values have an order. This is used for conditionals and forbiddens relying on relationships.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: ValueT = default_value\n</code></pre> <p>The default value of this hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: bool\n</code></pre> <p>If <code>True</code> the hyperparameter is sampled on a logarithmic scale.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: NumberT\n</code></pre> <p>Lower bound of the hyperparameter in value space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None = meta\n</code></pre> <p>Field for holding meta data provided by the user. Not used by the ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int | float = size\n</code></pre> <p>Size of the hyperparameter. For integer and choice hyperparameters this is the number of possible values the hyperparameter can take on within the specified range. For continuous hyperparameters this is usually <code>np.inf</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: NumberT\n</code></pre> <p>Upper bound of the hyperparameter in value space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.legal_value","title":"legal_value","text":"<pre><code>legal_value(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; bool | Mask\n</code></pre> <p>Check if a value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>bool | Mask</code> <p><code>True</code> if the value is legal, <code>False</code> otherwise. If <code>value</code> is an array of values, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_value(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; bool | Mask:\n    \"\"\"Check if a value is legal for this hyperparameter.\n\n    Args:\n        value:\n            The value to check.\n\n    Returns:\n        `True` if the value is legal, `False` otherwise. If `value` is an\n        array of values, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.legal_value(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.legal_value(np.asarray(value))\n\n    return self._transformer.legal_value_single(value)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.pdf_values","title":"pdf_values","text":"<pre><code>pdf_values(\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of values.</p> PARAMETER DESCRIPTION <code>values</code> <p>The values to get the probability density of.</p> <p> TYPE: <code>Sequence[ValueT | DType] | Array[DType]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the values. Where values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_values(\n    self,\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of values.\n\n    Args:\n        values:\n            The values to get the probability density of.\n\n    Returns:\n        The probability density of the values. Where values are not legal,\n        the probability density is zero.\n    \"\"\"\n    if isinstance(values, np.ndarray) and values.ndim != 1:\n        raise ValueError(\"Method pdf expects a one-dimensional numpy array\")\n\n    vector = self.to_vector(values)\n    return self.pdf_vector(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.to_uniform","title":"to_uniform","text":"<pre><code>to_uniform() -&gt; UniformIntegerHyperparameter\n</code></pre> <p>Convert the hyperparameter to its uniform equivalent.</p> <p>This will remove any distribution associated with it's vectorized representation.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_uniform(self) -&gt; UniformIntegerHyperparameter:\n    \"\"\"Convert the hyperparameter to its uniform equivalent.\n\n    This will remove any distribution associated with it's vectorized\n    representation.\n    \"\"\"\n    from ConfigSpace.hyperparameters.uniform_integer import (\n        UniformIntegerHyperparameter,\n    )\n\n    return UniformIntegerHyperparameter(\n        name=self.name,\n        lower=self.lower,\n        upper=self.upper,\n        default_value=self.default_value,\n        log=self.log,\n        meta=self.meta,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.IntegerHyperparameter.to_vector","title":"to_vector","text":"<pre><code>to_vector(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Transform a value to a vectorized value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to transform.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The vectorized value.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_vector(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; f64 | Array[f64]:\n    \"\"\"Transform a value to a vectorized value.\n\n    Args:\n        value:\n            The value to transform.\n\n    Returns:\n        The vectorized value.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.to_vector(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.to_vector(np.asarray(value))\n\n    return self._transformer.to_vector(np.array([value]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter","title":"NumericalHyperparameter  <code>dataclass</code>","text":"<pre><code>NumericalHyperparameter()\n</code></pre> <p>               Bases: <code>Hyperparameter[NumberT, DType]</code></p> <p>Base class for numerical hyperparameters in the configuration space.</p> <p>Should likely not be used directly and instead inherit from <code>IntegerHyperparameter</code> or <code>FloatHyperparameter</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.ORDERABLE","title":"ORDERABLE  <code>class-attribute</code>","text":"<pre><code>ORDERABLE: bool = False\n</code></pre> <p>If the hyperparameter values have an order. This is used for conditionals and forbiddens relying on relationships.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: ValueT = default_value\n</code></pre> <p>The default value of this hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: bool\n</code></pre> <p>If <code>True</code> the hyperparameter is sampled on a logarithmic scale.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: NumberT\n</code></pre> <p>Lower bound of the hyperparameter in value space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None = meta\n</code></pre> <p>Field for holding meta data provided by the user. Not used by the ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int | float = size\n</code></pre> <p>Size of the hyperparameter. For integer and choice hyperparameters this is the number of possible values the hyperparameter can take on within the specified range. For continuous hyperparameters this is usually <code>np.inf</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: NumberT\n</code></pre> <p>Upper bound of the hyperparameter in value space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.legal_value","title":"legal_value","text":"<pre><code>legal_value(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; bool | Mask\n</code></pre> <p>Check if a value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>bool | Mask</code> <p><code>True</code> if the value is legal, <code>False</code> otherwise. If <code>value</code> is an array of values, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_value(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; bool | Mask:\n    \"\"\"Check if a value is legal for this hyperparameter.\n\n    Args:\n        value:\n            The value to check.\n\n    Returns:\n        `True` if the value is legal, `False` otherwise. If `value` is an\n        array of values, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.legal_value(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.legal_value(np.asarray(value))\n\n    return self._transformer.legal_value_single(value)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.pdf_values","title":"pdf_values","text":"<pre><code>pdf_values(\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of values.</p> PARAMETER DESCRIPTION <code>values</code> <p>The values to get the probability density of.</p> <p> TYPE: <code>Sequence[ValueT | DType] | Array[DType]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the values. Where values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_values(\n    self,\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of values.\n\n    Args:\n        values:\n            The values to get the probability density of.\n\n    Returns:\n        The probability density of the values. Where values are not legal,\n        the probability density is zero.\n    \"\"\"\n    if isinstance(values, np.ndarray) and values.ndim != 1:\n        raise ValueError(\"Method pdf expects a one-dimensional numpy array\")\n\n    vector = self.to_vector(values)\n    return self.pdf_vector(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.to_uniform","title":"to_uniform  <code>abstractmethod</code>","text":"<pre><code>to_uniform() -&gt; (\n    UniformFloatHyperparameter\n    | UniformIntegerHyperparameter\n)\n</code></pre> <p>Convert the hyperparameter to its uniform equivalent.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@abstractmethod\ndef to_uniform(\n    self,\n) -&gt; UniformFloatHyperparameter | UniformIntegerHyperparameter:\n    \"\"\"Convert the hyperparameter to its uniform equivalent.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/hyperparameter/#ConfigSpace.hyperparameters.hyperparameter.NumericalHyperparameter.to_vector","title":"to_vector","text":"<pre><code>to_vector(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Transform a value to a vectorized value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to transform.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The vectorized value.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_vector(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; f64 | Array[f64]:\n    \"\"\"Transform a value to a vectorized value.\n\n    Args:\n        value:\n            The value to transform.\n\n    Returns:\n        The vectorized value.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.to_vector(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.to_vector(np.asarray(value))\n\n    return self._transformer.to_vector(np.array([value]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/","title":"Integer hyperparameter","text":""},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter","title":"ConfigSpace.hyperparameters.integer_hyperparameter","text":""},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter","title":"IntegerHyperparameter  <code>dataclass</code>","text":"<pre><code>IntegerHyperparameter()\n</code></pre> <p>               Bases: <code>NumericalHyperparameter[int, i64]</code></p> <p>Base class for integer hyperparameters in the configuration space.</p>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.ORDERABLE","title":"ORDERABLE  <code>class-attribute</code>","text":"<pre><code>ORDERABLE: bool = False\n</code></pre> <p>If the hyperparameter values have an order. This is used for conditionals and forbiddens relying on relationships.</p>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: ValueT = default_value\n</code></pre> <p>The default value of this hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: bool\n</code></pre> <p>If <code>True</code> the hyperparameter is sampled on a logarithmic scale.</p>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: NumberT\n</code></pre> <p>Lower bound of the hyperparameter in value space.</p>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None = meta\n</code></pre> <p>Field for holding meta data provided by the user. Not used by the ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int | float = size\n</code></pre> <p>Size of the hyperparameter. For integer and choice hyperparameters this is the number of possible values the hyperparameter can take on within the specified range. For continuous hyperparameters this is usually <code>np.inf</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: NumberT\n</code></pre> <p>Upper bound of the hyperparameter in value space.</p>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.legal_value","title":"legal_value","text":"<pre><code>legal_value(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; bool | Mask\n</code></pre> <p>Check if a value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>bool | Mask</code> <p><code>True</code> if the value is legal, <code>False</code> otherwise. If <code>value</code> is an array of values, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_value(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; bool | Mask:\n    \"\"\"Check if a value is legal for this hyperparameter.\n\n    Args:\n        value:\n            The value to check.\n\n    Returns:\n        `True` if the value is legal, `False` otherwise. If `value` is an\n        array of values, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.legal_value(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.legal_value(np.asarray(value))\n\n    return self._transformer.legal_value_single(value)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.pdf_values","title":"pdf_values","text":"<pre><code>pdf_values(\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of values.</p> PARAMETER DESCRIPTION <code>values</code> <p>The values to get the probability density of.</p> <p> TYPE: <code>Sequence[ValueT | DType] | Array[DType]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the values. Where values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_values(\n    self,\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of values.\n\n    Args:\n        values:\n            The values to get the probability density of.\n\n    Returns:\n        The probability density of the values. Where values are not legal,\n        the probability density is zero.\n    \"\"\"\n    if isinstance(values, np.ndarray) and values.ndim != 1:\n        raise ValueError(\"Method pdf expects a one-dimensional numpy array\")\n\n    vector = self.to_vector(values)\n    return self.pdf_vector(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.to_uniform","title":"to_uniform","text":"<pre><code>to_uniform() -&gt; UniformIntegerHyperparameter\n</code></pre> <p>Convert the hyperparameter to its uniform equivalent.</p> <p>This will remove any distribution associated with it's vectorized representation.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_uniform(self) -&gt; UniformIntegerHyperparameter:\n    \"\"\"Convert the hyperparameter to its uniform equivalent.\n\n    This will remove any distribution associated with it's vectorized\n    representation.\n    \"\"\"\n    from ConfigSpace.hyperparameters.uniform_integer import (\n        UniformIntegerHyperparameter,\n    )\n\n    return UniformIntegerHyperparameter(\n        name=self.name,\n        lower=self.lower,\n        upper=self.upper,\n        default_value=self.default_value,\n        log=self.log,\n        meta=self.meta,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/integer_hyperparameter/#ConfigSpace.hyperparameters.integer_hyperparameter.IntegerHyperparameter.to_vector","title":"to_vector","text":"<pre><code>to_vector(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Transform a value to a vectorized value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to transform.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The vectorized value.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_vector(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; f64 | Array[f64]:\n    \"\"\"Transform a value to a vectorized value.\n\n    Args:\n        value:\n            The value to transform.\n\n    Returns:\n        The vectorized value.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.to_vector(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.to_vector(np.asarray(value))\n\n    return self._transformer.to_vector(np.array([value]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/","title":"Normal float","text":""},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float","title":"ConfigSpace.hyperparameters.normal_float","text":""},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter","title":"NormalFloatHyperparameter  <code>dataclass</code>","text":"<pre><code>NormalFloatHyperparameter(\n    name: str,\n    mu: Number,\n    sigma: Number,\n    lower: Number,\n    upper: Number,\n    default_value: Number | None = None,\n    log: bool = False,\n    meta: Mapping[Hashable, Any] | None = None,\n)\n</code></pre> <p>               Bases: <code>FloatHyperparameter</code></p> <p>A normally distributed float hyperparameter.</p> <p>The 'mu' and 'sigma' parameters define the mean and standard deviation of the normal distribution. The 'lower' and 'upper' parameters move the distribution from the <code>[0, 1]</code>-range and scale it appropriately, but the shape of the distribution is preserved as if it were in <code>[0, 1]</code>-range.</p> <p>Its values are sampled from a normal distribution <code>N(mu, sigma)</code>.</p> <pre><code>from ConfigSpace import NormalFloatHyperparameter\n\nn = NormalFloatHyperparameter('n', mu=5.5, sigma=2, lower=0, upper=11, log=False)\nprint(n)\n</code></pre> <pre><code>n, Type: NormalFloat, Mu: 5.5, Sigma: 2.0, Range: [0.0, 11.0], Default: 5.5\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>Name of the hyperparameter, with which it can be accessed</p> <p> TYPE: <code>str</code> </p> <code>mu</code> <p>Mean of the normal distribution</p> <p> TYPE: <code>Number</code> </p> <code>sigma</code> <p>Standard deviation of the normal distribution</p> <p> TYPE: <code>Number</code> </p> <code>lower</code> <p>Lower bound of of values from which the hyperparameter represents</p> <p> TYPE: <code>Number</code> </p> <code>upper</code> <p>Upper bound of of values from which the hyperparameter represents</p> <p> TYPE: <code>Number</code> </p> <code>default_value</code> <p>The default value of this hyperparameter</p> <p> TYPE: <code>Number | None</code> DEFAULT: <code>None</code> </p> <code>log</code> <p>If <code>True</code> the values will be sampled on a log-scale</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>meta</code> <p>Field for meta data provided by the user. Not used by ConfigSpace.</p> <p> TYPE: <code>Mapping[Hashable, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/ConfigSpace/hyperparameters/normal_float.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    mu: Number,\n    sigma: Number,\n    lower: Number,\n    upper: Number,\n    default_value: Number | None = None,\n    log: bool = False,\n    meta: Mapping[Hashable, Any] | None = None,\n) -&gt; None:\n    \"\"\"A normally distributed float hyperparameter.\n\n    Args:\n        name:\n            Name of the hyperparameter, with which it can be accessed\n        mu:\n            Mean of the normal distribution\n        sigma:\n            Standard deviation of the normal distribution\n        lower:\n            Lower bound of of values from which the hyperparameter represents\n        upper:\n            Upper bound of of values from which the hyperparameter represents\n        default_value:\n            The default value of this hyperparameter\n        log:\n            If `True` the values will be sampled on a log-scale\n        meta:\n            Field for meta data provided by the user. Not used by ConfigSpace.\n    \"\"\"\n    if mu &lt;= 0 and log:\n        raise ValueError(\n            f\"Hyperparameter '{name}' has illegal settings: \"\n            f\"mu={mu} must be positive for log-scale.\",\n        )\n\n    self.lower = float(np.round(lower, ROUND_PLACES))\n    self.upper = float(np.round(upper, ROUND_PLACES))\n    self.mu = float(np.round(mu, ROUND_PLACES))\n    self.sigma = float(np.round(sigma, ROUND_PLACES))\n    self.log = bool(log)\n\n    try:\n        scaler = UnitScaler(f64(self.lower), f64(self.upper), log=log, dtype=f64)\n    except ValueError as e:\n        raise ValueError(f\"Hyperparameter '{name}' has illegal settings\") from e\n\n    if default_value is None:\n        _default_value = np.clip(self.mu, self.lower, self.upper)\n    else:\n        _default_value = default_value\n\n    _default_value = float(np.round(_default_value, ROUND_PLACES))\n\n    vectorized_mu = scaler.to_vector(np.array([self.mu]))[0]\n    vectorized_sigma = scaler.vectorize_size(f64(self.sigma))\n\n    vec_truncnorm_dist = truncnorm(  # type: ignore\n        a=(0.0 - vectorized_mu) / vectorized_sigma,\n        b=(1.0 - vectorized_mu) / vectorized_sigma,\n        loc=vectorized_mu,\n        scale=vectorized_sigma,\n    )\n    assert isinstance(vec_truncnorm_dist, rv_continuous_frozen)\n\n    max_density_point = np.clip(vectorized_mu, 0.0, 1.0)\n    vect_dist = ScipyContinuousDistribution(\n        rv=vec_truncnorm_dist,\n        lower_vectorized=f64(0.0),\n        upper_vectorized=f64(1.0),\n        _max_density=vec_truncnorm_dist.pdf(max_density_point),\n    )\n    super().__init__(\n        name=name,\n        size=np.inf,\n        default_value=_default_value,\n        meta=meta,\n        transformer=scaler,\n        vector_dist=vect_dist,\n        neighborhood=vect_dist.neighborhood,\n        neighborhood_size=np.inf,\n        value_cast=float,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: float\n</code></pre> <p>The default value of this hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: bool = bool(log)\n</code></pre> <p>If <code>True</code> the values of the hyperparameter will be sampled on a log-scale.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: float = float(round(lower, ROUND_PLACES))\n</code></pre> <p>Lower bound of a range of values from which the hyperparameter represents.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None\n</code></pre> <p>Field for holding meta data provided by the user. Not used by the ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: float = float(round(mu, ROUND_PLACES))\n</code></pre> <p>Mean of the normal distribution.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.sigma","title":"sigma  <code>instance-attribute</code>","text":"<pre><code>sigma: float = float(round(sigma, ROUND_PLACES))\n</code></pre> <p>Standard deviation of the normal distribution.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: float = field(init=False)\n</code></pre> <p>Size of the hyperparameter, which is always infinity for a normal float.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: float = float(round(upper, ROUND_PLACES))\n</code></pre> <p>Upper bound of a range of values from which the hyperparameter represents.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.legal_value","title":"legal_value","text":"<pre><code>legal_value(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; bool | Mask\n</code></pre> <p>Check if a value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>bool | Mask</code> <p><code>True</code> if the value is legal, <code>False</code> otherwise. If <code>value</code> is an array of values, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_value(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; bool | Mask:\n    \"\"\"Check if a value is legal for this hyperparameter.\n\n    Args:\n        value:\n            The value to check.\n\n    Returns:\n        `True` if the value is legal, `False` otherwise. If `value` is an\n        array of values, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.legal_value(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.legal_value(np.asarray(value))\n\n    return self._transformer.legal_value_single(value)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.pdf_values","title":"pdf_values","text":"<pre><code>pdf_values(\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of values.</p> PARAMETER DESCRIPTION <code>values</code> <p>The values to get the probability density of.</p> <p> TYPE: <code>Sequence[ValueT | DType] | Array[DType]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the values. Where values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_values(\n    self,\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of values.\n\n    Args:\n        values:\n            The values to get the probability density of.\n\n    Returns:\n        The probability density of the values. Where values are not legal,\n        the probability density is zero.\n    \"\"\"\n    if isinstance(values, np.ndarray) and values.ndim != 1:\n        raise ValueError(\"Method pdf expects a one-dimensional numpy array\")\n\n    vector = self.to_vector(values)\n    return self.pdf_vector(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.to_integer","title":"to_integer","text":"<pre><code>to_integer() -&gt; NormalIntegerHyperparameter\n</code></pre> <p>Convert this hyperparameter to a normal integer hyperparameter.</p> <p>This is done by rounding the lower and upper bounds and the default value as required.</p> RETURNS DESCRIPTION <code>NormalIntegerHyperparameter</code> <p>A normal integer hyperparameter.</p> Source code in <code>src/ConfigSpace/hyperparameters/normal_float.py</code> <pre><code>def to_integer(self) -&gt; NormalIntegerHyperparameter:\n    \"\"\"Convert this hyperparameter to a normal integer hyperparameter.\n\n    This is done by rounding the lower and upper bounds and the default value\n    as required.\n\n    Returns:\n        A normal integer hyperparameter.\n    \"\"\"\n    from ConfigSpace.hyperparameters.normal_integer import (\n        NormalIntegerHyperparameter,\n    )\n\n    return NormalIntegerHyperparameter(\n        name=self.name,\n        mu=self.mu,\n        sigma=self.sigma,\n        lower=np.ceil(self.lower),\n        upper=np.floor(self.upper),\n        default_value=np.rint(self.default_value),\n        log=self.log,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.to_uniform","title":"to_uniform","text":"<pre><code>to_uniform() -&gt; UniformFloatHyperparameter\n</code></pre> <p>Convert the hyperparameter to its uniform equivalent.</p> <p>This will remove any distribution associated with it's vectorized representation.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_uniform(self) -&gt; UniformFloatHyperparameter:\n    \"\"\"Convert the hyperparameter to its uniform equivalent.\n\n    This will remove any distribution associated with it's vectorized\n    representation.\n    \"\"\"\n    from ConfigSpace.hyperparameters.uniform_float import UniformFloatHyperparameter\n\n    return UniformFloatHyperparameter(\n        name=self.name,\n        lower=self.lower,\n        upper=self.upper,\n        default_value=self.default_value,\n        log=self.log,\n        meta=self.meta,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_float/#ConfigSpace.hyperparameters.normal_float.NormalFloatHyperparameter.to_vector","title":"to_vector","text":"<pre><code>to_vector(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Transform a value to a vectorized value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to transform.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The vectorized value.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_vector(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; f64 | Array[f64]:\n    \"\"\"Transform a value to a vectorized value.\n\n    Args:\n        value:\n            The value to transform.\n\n    Returns:\n        The vectorized value.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.to_vector(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.to_vector(np.asarray(value))\n\n    return self._transformer.to_vector(np.array([value]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/","title":"Normal integer","text":""},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer","title":"ConfigSpace.hyperparameters.normal_integer","text":""},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter","title":"NormalIntegerHyperparameter  <code>dataclass</code>","text":"<pre><code>NormalIntegerHyperparameter(\n    name: str,\n    mu: Number,\n    sigma: Number,\n    lower: Number,\n    upper: Number,\n    default_value: Number | None = None,\n    log: bool = False,\n    meta: Mapping[Hashable, Any] | None = None,\n)\n</code></pre> <p>               Bases: <code>IntegerHyperparameter</code></p> <p>A normally distributed integer hyperparameter.</p> <p>The 'mu' and 'sigma' parameters define the mean and standard deviation of the normal distribution. The 'lower' and 'upper' parameters move the distribution from the <code>[0, 1]</code>-range and scale it appropriately, but the shape of the distribution is preserved as if it were in <code>[0, 1]</code>-range.</p> <p>Its values are sampled from a normal distribution <code>N(mu, sigma)</code>.</p> <p>```python exec=\"True\" result=\"python\" source=\"material-block\" from ConfigSpace import NormalIntegerHyperparameter</p> <p>n = NormalIntegerHyperparameter('n', mu=150, sigma=20, lower=100, upper=200) print(n)</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the hyperparameter, with which it can be accessed</p> <p> TYPE: <code>str</code> </p> <code>mu</code> <p>Mean of the normal distribution</p> <p> TYPE: <code>Number</code> </p> <code>sigma</code> <p>Standard deviation of the normal distribution</p> <p> TYPE: <code>Number</code> </p> <code>lower</code> <p>Lower bound of of values from which the hyperparameter represents</p> <p> TYPE: <code>Number</code> </p> <code>upper</code> <p>Upper bound of of values from which the hyperparameter represents</p> <p> TYPE: <code>Number</code> </p> <code>default_value</code> <p>The default value of this hyperparameter</p> <p> TYPE: <code>Number | None</code> DEFAULT: <code>None</code> </p> <code>log</code> <p>If <code>True</code> the values will be sampled on a log-scale</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>meta</code> <p>Field for holding meta data provided by the user. Not used by ConfigSpace.</p> <p> TYPE: <code>Mapping[Hashable, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/ConfigSpace/hyperparameters/normal_integer.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    mu: Number,\n    sigma: Number,\n    lower: Number,\n    upper: Number,\n    default_value: Number | None = None,\n    log: bool = False,\n    meta: Mapping[Hashable, Any] | None = None,\n) -&gt; None:\n    \"\"\"A normally distributed integer hyperparameter.\n\n    Args:\n        name:\n            Name of the hyperparameter, with which it can be accessed\n        mu:\n            Mean of the normal distribution\n        sigma:\n            Standard deviation of the normal distribution\n        lower:\n            Lower bound of of values from which the hyperparameter represents\n        upper:\n            Upper bound of of values from which the hyperparameter represents\n        default_value:\n            The default value of this hyperparameter\n        log:\n            If `True` the values will be sampled on a log-scale\n        meta:\n            Field for holding meta data provided by the user. Not used by\n            ConfigSpace.\n    \"\"\"\n    if mu &lt;= 0 and log:\n        raise ValueError(\n            f\"Hyperparameter '{name}' has illegal settings: \"\n            f\"mu={mu} must be positive for log-scale.\",\n        )\n\n    self.mu = float(mu)\n    self.sigma = float(sigma)\n    self.lower = int(np.rint(lower))\n    self.upper = int(np.rint(upper))\n    self.log = bool(log)\n\n    try:\n        scaler = UnitScaler(\n            i64(self.lower),\n            i64(self.upper),\n            log=self.log,\n            dtype=i64,\n        )\n    except ValueError as e:\n        raise ValueError(f\"Hyperparameter '{name}' has illegal settings\") from e\n\n    if default_value is None:\n        _default_value = int(np.rint(np.clip(self.mu, self.lower, self.upper)))\n    else:\n        if not is_close_to_integer(f64(default_value), atol=ATOL):\n            raise TypeError(\n                f\"`default_value` for hyperparameter '{name}' must be an integer.\"\n                f\" Got '{type(default_value).__name__}' for {default_value=}.\",\n            )\n\n        _default_value = int(np.rint(default_value))\n\n    size = self.upper - self.lower + 1\n\n    vectorized_mu = scaler.to_vector(np.array([self.mu]))[0]\n    vectorized_sigma = scaler.vectorize_size(f64(self.sigma))\n\n    vec_truncnorm_dist = truncnorm(  # type: ignore\n        a=(0.0 - vectorized_mu) / vectorized_sigma,\n        b=(1.0 - vectorized_mu) / vectorized_sigma,\n        loc=vectorized_mu,\n        scale=vectorized_sigma,\n    )\n\n    vector_dist = DiscretizedContinuousScipyDistribution(\n        rv=vec_truncnorm_dist,  # type: ignore\n        steps=int(size),\n        lower_vectorized=f64(0.0),\n        upper_vectorized=f64(1.0),\n    )\n    super().__init__(\n        name=name,\n        size=int(size),\n        default_value=_default_value,\n        meta=meta,\n        transformer=scaler,\n        vector_dist=vector_dist,\n        neighborhood=vector_dist.neighborhood,\n        neighborhood_size=self._integer_neighborhood_size,\n        value_cast=int,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: int\n</code></pre> <p>The default value of this hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: bool = bool(log)\n</code></pre> <p>If <code>True</code> the values of the hyperparameter will be sampled on a log-scale.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: int = int(rint(lower))\n</code></pre> <p>Lower bound of a range of values from which the hyperparameter represents.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None\n</code></pre> <p>Field for holding meta data provided by the user. Not used by the ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: float = float(mu)\n</code></pre> <p>Mean of the normal distribution.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.sigma","title":"sigma  <code>instance-attribute</code>","text":"<pre><code>sigma: float = float(sigma)\n</code></pre> <p>Standard deviation of the normal distribution.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: int = field(init=False)\n</code></pre> <p>Size of the hyperparameter, which is the count of ints between <code>upper</code> and <code>lower</code>, inclusive.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: int = int(rint(upper))\n</code></pre> <p>Upper bound of a range of values from which the hyperparameter represents.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.legal_value","title":"legal_value","text":"<pre><code>legal_value(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; bool | Mask\n</code></pre> <p>Check if a value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>bool | Mask</code> <p><code>True</code> if the value is legal, <code>False</code> otherwise. If <code>value</code> is an array of values, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_value(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; bool | Mask:\n    \"\"\"Check if a value is legal for this hyperparameter.\n\n    Args:\n        value:\n            The value to check.\n\n    Returns:\n        `True` if the value is legal, `False` otherwise. If `value` is an\n        array of values, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.legal_value(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.legal_value(np.asarray(value))\n\n    return self._transformer.legal_value_single(value)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.pdf_values","title":"pdf_values","text":"<pre><code>pdf_values(\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of values.</p> PARAMETER DESCRIPTION <code>values</code> <p>The values to get the probability density of.</p> <p> TYPE: <code>Sequence[ValueT | DType] | Array[DType]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the values. Where values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_values(\n    self,\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of values.\n\n    Args:\n        values:\n            The values to get the probability density of.\n\n    Returns:\n        The probability density of the values. Where values are not legal,\n        the probability density is zero.\n    \"\"\"\n    if isinstance(values, np.ndarray) and values.ndim != 1:\n        raise ValueError(\"Method pdf expects a one-dimensional numpy array\")\n\n    vector = self.to_vector(values)\n    return self.pdf_vector(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.to_float","title":"to_float","text":"<pre><code>to_float() -&gt; NormalFloatHyperparameter\n</code></pre> <p>Convert this hyperparameter to a normal float hyperparameter.</p> Source code in <code>src/ConfigSpace/hyperparameters/normal_integer.py</code> <pre><code>def to_float(self) -&gt; NormalFloatHyperparameter:\n    \"\"\"Convert this hyperparameter to a normal float hyperparameter.\"\"\"\n    from ConfigSpace.hyperparameters.normal_float import NormalFloatHyperparameter\n\n    return NormalFloatHyperparameter(\n        name=self.name,\n        mu=self.mu,\n        sigma=self.sigma,\n        lower=self.lower,\n        upper=self.upper,\n        default_value=self.default_value,\n        log=self.log,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.to_uniform","title":"to_uniform","text":"<pre><code>to_uniform() -&gt; UniformIntegerHyperparameter\n</code></pre> <p>Convert the hyperparameter to its uniform equivalent.</p> <p>This will remove any distribution associated with it's vectorized representation.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_uniform(self) -&gt; UniformIntegerHyperparameter:\n    \"\"\"Convert the hyperparameter to its uniform equivalent.\n\n    This will remove any distribution associated with it's vectorized\n    representation.\n    \"\"\"\n    from ConfigSpace.hyperparameters.uniform_integer import (\n        UniformIntegerHyperparameter,\n    )\n\n    return UniformIntegerHyperparameter(\n        name=self.name,\n        lower=self.lower,\n        upper=self.upper,\n        default_value=self.default_value,\n        log=self.log,\n        meta=self.meta,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/normal_integer/#ConfigSpace.hyperparameters.normal_integer.NormalIntegerHyperparameter.to_vector","title":"to_vector","text":"<pre><code>to_vector(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Transform a value to a vectorized value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to transform.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The vectorized value.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_vector(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; f64 | Array[f64]:\n    \"\"\"Transform a value to a vectorized value.\n\n    Args:\n        value:\n            The value to transform.\n\n    Returns:\n        The vectorized value.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.to_vector(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.to_vector(np.asarray(value))\n\n    return self._transformer.to_vector(np.array([value]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/","title":"Numerical hyperparameter","text":""},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter","title":"ConfigSpace.hyperparameters.numerical_hyperparameter","text":""},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter","title":"NumericalHyperparameter  <code>dataclass</code>","text":"<pre><code>NumericalHyperparameter()\n</code></pre> <p>               Bases: <code>Hyperparameter[NumberT, DType]</code></p> <p>Base class for numerical hyperparameters in the configuration space.</p> <p>Should likely not be used directly and instead inherit from <code>IntegerHyperparameter</code> or <code>FloatHyperparameter</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.ORDERABLE","title":"ORDERABLE  <code>class-attribute</code>","text":"<pre><code>ORDERABLE: bool = False\n</code></pre> <p>If the hyperparameter values have an order. This is used for conditionals and forbiddens relying on relationships.</p>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: ValueT = default_value\n</code></pre> <p>The default value of this hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: bool\n</code></pre> <p>If <code>True</code> the hyperparameter is sampled on a logarithmic scale.</p>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: NumberT\n</code></pre> <p>Lower bound of the hyperparameter in value space.</p>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None = meta\n</code></pre> <p>Field for holding meta data provided by the user. Not used by the ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int | float = size\n</code></pre> <p>Size of the hyperparameter. For integer and choice hyperparameters this is the number of possible values the hyperparameter can take on within the specified range. For continuous hyperparameters this is usually <code>np.inf</code>.</p>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: NumberT\n</code></pre> <p>Upper bound of the hyperparameter in value space.</p>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.legal_value","title":"legal_value","text":"<pre><code>legal_value(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; bool | Mask\n</code></pre> <p>Check if a value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>bool | Mask</code> <p><code>True</code> if the value is legal, <code>False</code> otherwise. If <code>value</code> is an array of values, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_value(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; bool | Mask:\n    \"\"\"Check if a value is legal for this hyperparameter.\n\n    Args:\n        value:\n            The value to check.\n\n    Returns:\n        `True` if the value is legal, `False` otherwise. If `value` is an\n        array of values, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.legal_value(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.legal_value(np.asarray(value))\n\n    return self._transformer.legal_value_single(value)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.pdf_values","title":"pdf_values","text":"<pre><code>pdf_values(\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of values.</p> PARAMETER DESCRIPTION <code>values</code> <p>The values to get the probability density of.</p> <p> TYPE: <code>Sequence[ValueT | DType] | Array[DType]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the values. Where values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_values(\n    self,\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of values.\n\n    Args:\n        values:\n            The values to get the probability density of.\n\n    Returns:\n        The probability density of the values. Where values are not legal,\n        the probability density is zero.\n    \"\"\"\n    if isinstance(values, np.ndarray) and values.ndim != 1:\n        raise ValueError(\"Method pdf expects a one-dimensional numpy array\")\n\n    vector = self.to_vector(values)\n    return self.pdf_vector(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.to_uniform","title":"to_uniform  <code>abstractmethod</code>","text":"<pre><code>to_uniform() -&gt; (\n    UniformFloatHyperparameter\n    | UniformIntegerHyperparameter\n)\n</code></pre> <p>Convert the hyperparameter to its uniform equivalent.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@abstractmethod\ndef to_uniform(\n    self,\n) -&gt; UniformFloatHyperparameter | UniformIntegerHyperparameter:\n    \"\"\"Convert the hyperparameter to its uniform equivalent.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/numerical_hyperparameter/#ConfigSpace.hyperparameters.numerical_hyperparameter.NumericalHyperparameter.to_vector","title":"to_vector","text":"<pre><code>to_vector(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Transform a value to a vectorized value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to transform.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The vectorized value.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_vector(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; f64 | Array[f64]:\n    \"\"\"Transform a value to a vectorized value.\n\n    Args:\n        value:\n            The value to transform.\n\n    Returns:\n        The vectorized value.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.to_vector(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.to_vector(np.asarray(value))\n\n    return self._transformer.to_vector(np.array([value]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/","title":"Ordinal","text":""},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal","title":"ConfigSpace.hyperparameters.ordinal","text":""},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter","title":"OrdinalHyperparameter  <code>dataclass</code>","text":"<pre><code>OrdinalHyperparameter(\n    name: str,\n    sequence: Sequence[Any],\n    default_value: Any | _NotSet = NotSet,\n    meta: Mapping[Hashable, Any] | None = None,\n)\n</code></pre> <p>               Bases: <code>Hyperparameter[Any, Any]</code></p> <p>Representing an ordinal hyperparameter in the configuration space.</p> <p>An ordinal hyperparameter is a hyperparameter that can take on one of a fixed number of arbitrary values. The values are ordered and the order is defined by the sequence in which they are passed to the hyperparameter.</p> <pre><code>from ConfigSpace import OrdinalHyperparameter\n\nhp = OrdinalHyperparameter('hp', sequence=['small', 'medium', 'large'], default_value='medium')\nprint(hp)\n</code></pre> <pre><code>hp, Type: Ordinal, Sequence: {small, medium, large}, Default: medium\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>Name of the hyperparameter, with which it can be accessed</p> <p> TYPE: <code>str</code> </p> <code>sequence</code> <p>Sequence of values the hyperparameter can take on</p> <p> TYPE: <code>Sequence[Any]</code> </p> <code>default_value</code> <p>Default value of the hyperparameter</p> <p> TYPE: <code>Any | _NotSet</code> DEFAULT: <code>NotSet</code> </p> <code>meta</code> <p>Field for holding meta data provided by the user</p> <p> TYPE: <code>Mapping[Hashable, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/ConfigSpace/hyperparameters/ordinal.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    sequence: Sequence[Any],\n    default_value: Any | _NotSet = NotSet,\n    meta: Mapping[Hashable, Any] | None = None,\n) -&gt; None:\n    \"\"\"Initialize an ordinal hyperparameter.\n\n    Args:\n        name:\n            Name of the hyperparameter, with which it can be accessed\n        sequence:\n            Sequence of values the hyperparameter can take on\n        default_value:\n            Default value of the hyperparameter\n        meta:\n            Field for holding meta data provided by the user\n    \"\"\"\n    # TODO: Maybe give some way to not check this, i.e. for large sequences\n    # of int...\n    if any(i != sequence.index(x) for i, x in enumerate(sequence)):\n        raise ValueError(\n            \"The sequence has to be a list of unique elements as defined\"\n            \" by object equality.\"\n            f\"Got {sequence} which does not fulfill this requirement.\",\n        )\n\n    size = len(sequence)\n    if default_value is NotSet:\n        default_value = sequence[0]\n    elif default_value not in sequence:\n        raise ValueError(\n            \"The default value has to be one of the ordinal values. \"\n            f\"Got {default_value!r} which is not in {sequence}.\",\n        )\n\n    try:\n        # This can fail with a ValueError if the choices contain arbitrary objects\n        # that are list like.\n        seq_choices = np.asarray(sequence)\n        if seq_choices.ndim != 1:\n            raise ValueError\n\n        # NOTE: Unfortunatly, numpy will promote number types to str\n        # if there are string types in the array, where we'd rather\n        # stick to object type in that case. Hence the manual...\n        if seq_choices.dtype.kind in {\"U\", \"S\"} and not all(\n            isinstance(item, str) for item in sequence\n        ):\n            seq_choices = np.array(sequence, dtype=object)\n\n    except ValueError:\n        seq_choices = list(sequence)\n\n    self.sequence = tuple(sequence)\n\n    # If the Hyperparameter recieves as a Sequence during legality checks or\n    # conversions, we need to inform it that one of the values is a Sequence itself,\n    # i.e. we should treat it as a single value and not a list of multiple values\n    self._contains_sequence_as_value = any(\n        isinstance(item, Sequence) and not isinstance(item, str)\n        for item in self.sequence\n    )\n\n    super().__init__(\n        name=name,\n        size=size,\n        default_value=default_value,\n        meta=meta,\n        transformer=TransformerSeq(seq=seq_choices),\n        neighborhood=partial(ordinal_neighborhood, size=int(size)),\n        vector_dist=UniformIntegerDistribution(size=size),\n        neighborhood_size=self._ordinal_neighborhood_size,\n        value_cast=None,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.LEGAL_VALUE_TYPES","title":"LEGAL_VALUE_TYPES  <code>class-attribute</code>","text":"<pre><code>LEGAL_VALUE_TYPES: tuple[type, ...] | Literal[\"all\"] = \"all\"\n</code></pre> <p>The types of values that are legal for this hyperparameter. If set to <code>\"all\"</code> any type is legal. Otherwise, a tuple of types can be provided.</p>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: Any\n</code></pre> <p>Default value of the hyperparameter.</p>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None\n</code></pre> <p>Field for holding meta data provided by the user. Not used by the ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.num_elements","title":"num_elements  <code>property</code>","text":"<pre><code>num_elements: int\n</code></pre> <p>Deprecated: Number of elements in the sequence.</p>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.sequence","title":"sequence  <code>instance-attribute</code>","text":"<pre><code>sequence: tuple[Any, ...] = tuple(sequence)\n</code></pre> <p>Sequence of values the hyperparameter can take on.</p>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: int = field(init=False)\n</code></pre> <p>Size of the hyperparameter, which is the number of possible values the hyperparameter can take on within the specified sequence.</p>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.check_order","title":"check_order","text":"<pre><code>check_order(value: Any, other: Any) -&gt; bool\n</code></pre> <p>Check if the value is smaller than the other value.</p> Source code in <code>src/ConfigSpace/hyperparameters/ordinal.py</code> <pre><code>def check_order(self, value: Any, other: Any) -&gt; bool:\n    \"\"\"Check if the value is smaller than the other value.\"\"\"\n    return self.sequence.index(value) &lt; self.sequence.index(other)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.get_order","title":"get_order","text":"<pre><code>get_order(value: Any) -&gt; int\n</code></pre> <p>Get the order of the value in the sequence.</p> Source code in <code>src/ConfigSpace/hyperparameters/ordinal.py</code> <pre><code>def get_order(self, value: Any) -&gt; int:\n    \"\"\"Get the order of the value in the sequence.\"\"\"\n    return self.sequence.index(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.get_seq_order","title":"get_seq_order","text":"<pre><code>get_seq_order() -&gt; Array[i64]\n</code></pre> <p>Get the order of the sequence.</p> Source code in <code>src/ConfigSpace/hyperparameters/ordinal.py</code> <pre><code>def get_seq_order(self) -&gt; Array[i64]:\n    \"\"\"Get the order of the sequence.\"\"\"\n    return np.arange(len(self.sequence))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.get_value","title":"get_value","text":"<pre><code>get_value(i: int | integer) -&gt; Any\n</code></pre> <p>Get the value at the index in the sequence.</p> Source code in <code>src/ConfigSpace/hyperparameters/ordinal.py</code> <pre><code>def get_value(self, i: int | np.integer) -&gt; Any:\n    \"\"\"Get the value at the index in the sequence.\"\"\"\n    return self.sequence[int(i)]\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/ordinal/#ConfigSpace.hyperparameters.ordinal.OrdinalHyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/","title":"Uniform float","text":""},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float","title":"ConfigSpace.hyperparameters.uniform_float","text":""},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter","title":"UniformFloatHyperparameter  <code>dataclass</code>","text":"<pre><code>UniformFloatHyperparameter(\n    name: str,\n    lower: Number,\n    upper: Number,\n    default_value: Number | None = None,\n    log: bool = False,\n    meta: Mapping[Hashable, Any] | None = None,\n)\n</code></pre> <p>               Bases: <code>FloatHyperparameter</code></p> <p>A uniformly distributed float hyperparameter.</p> <p>The 'lower' and 'upper' parameters define the range of values from which the hyperparameter represents. The 'log' parameter defines whether the values of the hyperparameter will be sampled on a log-scale.</p> <p>Its values are sampled from a uniform distribution <code>U(lower, upper)</code>.</p> <pre><code>from ConfigSpace import UniformFloatHyperparameter\n\nu = UniformFloatHyperparameter('u', lower=11.3, upper=12.5, log=False)\nprint(u)\n</code></pre> <pre><code>u, Type: UniformFloat, Range: [11.3, 12.5], Default: 11.9\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>Name of the hyperparameter, with which it can be accessed</p> <p> TYPE: <code>str</code> </p> <code>lower</code> <p>Lower bound of a range of values from which the hyperparameter represents</p> <p> TYPE: <code>Number</code> </p> <code>upper</code> <p>Upper bound of a range of values from which the hyperparameter represents</p> <p> TYPE: <code>Number</code> </p> <code>default_value</code> <p>The default value of this hyperparameter. If not specified, the default value is the midpoint of the range</p> <p> TYPE: <code>Number | None</code> DEFAULT: <code>None</code> </p> <code>log</code> <p>If <code>True</code> the values of the hyperparameter will be sampled on a log-scale</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>meta</code> <p>Field for holding meta data provided by the user. Not used by ConfigSpace.</p> <p> TYPE: <code>Mapping[Hashable, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/ConfigSpace/hyperparameters/uniform_float.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    lower: Number,\n    upper: Number,\n    default_value: Number | None = None,\n    log: bool = False,\n    meta: Mapping[Hashable, Any] | None = None,\n) -&gt; None:\n    \"\"\"Initialize a uniformly distributed float hyperparameter.\n\n    Args:\n        name:\n            Name of the hyperparameter, with which it can be accessed\n        lower:\n            Lower bound of a range of values from which the hyperparameter\n            represents\n        upper:\n            Upper bound of a range of values from which the hyperparameter\n            represents\n        default_value:\n            The default value of this hyperparameter. If not specified, the\n            default value is the midpoint of the range\n        log:\n            If `True` the values of the hyperparameter will be sampled on a log-scale\n        meta:\n            Field for holding meta data provided by the user. Not used by\n            ConfigSpace.\n    \"\"\"\n    self.lower = float(np.round(lower, ROUND_PLACES))\n    self.upper = float(np.round(upper, ROUND_PLACES))\n    self.log = log\n\n    try:\n        scaler = UnitScaler(f64(self.lower), f64(self.upper), log=log, dtype=f64)\n    except ValueError as e:\n        raise ValueError(f\"Hyperparameter '{name}' has illegal settings\") from e\n\n    vect_dist = UnitUniformContinuousDistribution(\n        pdf_max_density=1 / float(self.upper - self.lower),\n    )\n    super().__init__(\n        name=name,\n        size=np.inf,\n        default_value=float(\n            np.round(\n                default_value\n                if default_value is not None\n                else scaler.to_value(np.array([0.5]))[0],\n                ROUND_PLACES,\n            ),\n        ),\n        meta=meta,\n        transformer=scaler,\n        neighborhood=vect_dist.neighborhood,\n        vector_dist=vect_dist,\n        neighborhood_size=np.inf,\n        value_cast=float,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: float\n</code></pre> <p>The default value of this hyperparameter.</p> <p>If not specified, the default value is the midpoint of the range.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: bool = log\n</code></pre> <p>If <code>True</code> the values of the hyperparameter will be sampled on a log-scale.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: float = float(round(lower, ROUND_PLACES))\n</code></pre> <p>Lower bound of a range of values from which the hyperparameter represents.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None\n</code></pre> <p>Field for holding meta data provided by the user. Not used by the ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: float = field(init=False)\n</code></pre> <p>Size of hyperparameter. It is set to np.inf for continuous hyperparameters.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: float = float(round(upper, ROUND_PLACES))\n</code></pre> <p>Upper bound of a range of values from which the hyperparameter represents.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.legal_value","title":"legal_value","text":"<pre><code>legal_value(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; bool | Mask\n</code></pre> <p>Check if a value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>bool | Mask</code> <p><code>True</code> if the value is legal, <code>False</code> otherwise. If <code>value</code> is an array of values, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_value(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; bool | Mask:\n    \"\"\"Check if a value is legal for this hyperparameter.\n\n    Args:\n        value:\n            The value to check.\n\n    Returns:\n        `True` if the value is legal, `False` otherwise. If `value` is an\n        array of values, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.legal_value(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.legal_value(np.asarray(value))\n\n    return self._transformer.legal_value_single(value)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.pdf_values","title":"pdf_values","text":"<pre><code>pdf_values(\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of values.</p> PARAMETER DESCRIPTION <code>values</code> <p>The values to get the probability density of.</p> <p> TYPE: <code>Sequence[ValueT | DType] | Array[DType]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the values. Where values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_values(\n    self,\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of values.\n\n    Args:\n        values:\n            The values to get the probability density of.\n\n    Returns:\n        The probability density of the values. Where values are not legal,\n        the probability density is zero.\n    \"\"\"\n    if isinstance(values, np.ndarray) and values.ndim != 1:\n        raise ValueError(\"Method pdf expects a one-dimensional numpy array\")\n\n    vector = self.to_vector(values)\n    return self.pdf_vector(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.to_integer","title":"to_integer","text":"<pre><code>to_integer() -&gt; UniformIntegerHyperparameter\n</code></pre> <p>Converts the hyperparameter to a uniformly integer hyperparameter.</p> <p>This is done by rounding the lower and upper bounds of the float hyperparameter and the default value.</p> RETURNS DESCRIPTION <code>UniformIntegerHyperparameter</code> <p>A uniformly distributed integer hyperparameter.</p> Source code in <code>src/ConfigSpace/hyperparameters/uniform_float.py</code> <pre><code>def to_integer(self) -&gt; UniformIntegerHyperparameter:\n    \"\"\"Converts the hyperparameter to a uniformly integer hyperparameter.\n\n    This is done by rounding the lower and upper bounds of the float hyperparameter\n    and the default value.\n\n    Returns:\n        A uniformly distributed integer hyperparameter.\n    \"\"\"\n    from ConfigSpace.hyperparameters.uniform_integer import (\n        UniformIntegerHyperparameter,\n    )\n\n    return UniformIntegerHyperparameter(\n        name=self.name,\n        lower=math.ceil(self.lower),\n        upper=math.floor(self.upper),\n        default_value=round(self.default_value),\n        log=self.log,\n        meta=None,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.to_uniform","title":"to_uniform","text":"<pre><code>to_uniform() -&gt; UniformFloatHyperparameter\n</code></pre> <p>Convert the hyperparameter to its uniform equivalent.</p> <p>This will remove any distribution associated with it's vectorized representation.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_uniform(self) -&gt; UniformFloatHyperparameter:\n    \"\"\"Convert the hyperparameter to its uniform equivalent.\n\n    This will remove any distribution associated with it's vectorized\n    representation.\n    \"\"\"\n    from ConfigSpace.hyperparameters.uniform_float import UniformFloatHyperparameter\n\n    return UniformFloatHyperparameter(\n        name=self.name,\n        lower=self.lower,\n        upper=self.upper,\n        default_value=self.default_value,\n        log=self.log,\n        meta=self.meta,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_float/#ConfigSpace.hyperparameters.uniform_float.UniformFloatHyperparameter.to_vector","title":"to_vector","text":"<pre><code>to_vector(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Transform a value to a vectorized value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to transform.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The vectorized value.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_vector(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; f64 | Array[f64]:\n    \"\"\"Transform a value to a vectorized value.\n\n    Args:\n        value:\n            The value to transform.\n\n    Returns:\n        The vectorized value.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.to_vector(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.to_vector(np.asarray(value))\n\n    return self._transformer.to_vector(np.array([value]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/","title":"Uniform integer","text":""},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer","title":"ConfigSpace.hyperparameters.uniform_integer","text":""},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter","title":"UniformIntegerHyperparameter  <code>dataclass</code>","text":"<pre><code>UniformIntegerHyperparameter(\n    name: str,\n    lower: Number,\n    upper: Number,\n    default_value: Number | None = None,\n    log: bool = False,\n    meta: Mapping[Hashable, Any] | None = None,\n)\n</code></pre> <p>               Bases: <code>IntegerHyperparameter</code></p> <p>A uniformly distributed integer hyperparameter.</p> <p>The 'lower' and 'upper' parameters define the range of values from which the hyperparameter represents. The 'log' parameter defines whether the values of the hyperparameter will be sampled on a log-scale.</p> <p>Its values are sampled from a uniform distribution <code>U(lower, upper)</code>.</p> <pre><code>from ConfigSpace import UniformIntegerHyperparameter\n\nu = UniformIntegerHyperparameter('u', lower=0, upper=10, log=False)\nprint(u)\n</code></pre> <pre><code>u, Type: UniformInteger, Range: [0, 10], Default: 5\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>Name of the hyperparameter, with which it can be accessed</p> <p> TYPE: <code>str</code> </p> <code>lower</code> <p>Lower bound of a range of values from which the hyperparameter represents</p> <p> TYPE: <code>Number</code> </p> <code>upper</code> <p>Upper bound of a range of values from which the hyperparameter represents</p> <p> TYPE: <code>Number</code> </p> <code>default_value</code> <p>The default value of this hyperparameter. If not specified, the default value is the midpoint of the range.</p> <p> TYPE: <code>Number | None</code> DEFAULT: <code>None</code> </p> <code>log</code> <p>If <code>True</code> the values of the hyperparameter will be sampled on a log-scale</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>meta</code> <p>Field for holding meta data provided by the user. Not used by ConfigSpace.</p> <p> TYPE: <code>Mapping[Hashable, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/ConfigSpace/hyperparameters/uniform_integer.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    lower: Number,\n    upper: Number,\n    default_value: Number | None = None,\n    log: bool = False,\n    meta: Mapping[Hashable, Any] | None = None,\n) -&gt; None:\n    \"\"\"Initialize a uniformly distributed integer hyperparameter.\n\n    Args:\n        name:\n            Name of the hyperparameter, with which it can be accessed\n        lower:\n            Lower bound of a range of values from which the hyperparameter\n            represents\n        upper:\n            Upper bound of a range of values from which the hyperparameter\n            represents\n        default_value:\n            The default value of this hyperparameter. If not specified, the\n            default value is the midpoint of the range.\n        log:\n            If `True` the values of the hyperparameter will be sampled on a\n            log-scale\n        meta:\n            Field for holding meta data provided by the user. Not used by\n            ConfigSpace.\n    \"\"\"\n    self.lower = int(np.rint(lower))\n    self.upper = int(np.rint(upper))\n    self.log = bool(log)\n\n    if default_value is not None and not is_close_to_integer(\n        f64(default_value),\n        atol=ATOL,\n    ):\n        raise TypeError(\n            f\"`default_value` for hyperparameter '{name}' must be an integer.\"\n            f\" Got '{type(default_value).__name__}' for {default_value=}.\",\n        )\n\n    try:\n        scaler = UnitScaler(i64(self.lower), i64(self.upper), log=log, dtype=i64)\n    except ValueError as e:\n        raise ValueError(f\"Hyperparameter '{name}' has illegal settings\") from e\n\n    size = self.upper - self.lower + 1\n    if not self.log:\n        vector_dist = UniformIntegerNormalizedDistribution(size=int(size))\n    else:\n        vector_dist = DiscretizedContinuousScipyDistribution(\n            rv=uniform(),  # type: ignore\n            steps=int(size),\n            _max_density=float(1 / size),\n            _pdf_norm=float(size),\n            lower_vectorized=f64(0.0),\n            upper_vectorized=f64(1.0),\n            log_scale=log,\n            transformer=scaler,\n        )\n\n    super().__init__(\n        name=name,\n        size=int(size),\n        default_value=(\n            int(\n                default_value\n                if default_value is not None\n                else np.rint(scaler.to_value(np.array([0.5]))[0]),\n            )\n        ),\n        meta=meta,\n        transformer=scaler,\n        vector_dist=vector_dist,\n        neighborhood=vector_dist.neighborhood,\n        neighborhood_size=self._integer_neighborhood_size,\n        value_cast=int,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.default_value","title":"default_value  <code>instance-attribute</code>","text":"<pre><code>default_value: int\n</code></pre> <p>The default value of this hyperparameter.</p> <p>If not specified, the default value is the midpoint of the range.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: bool = bool(log)\n</code></pre> <p>If <code>True</code> the values of the hyperparameter will be sampled on a log-scale.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: int = int(rint(lower))\n</code></pre> <p>Lower bound of a range of values from which the hyperparameter represents.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.lower_vectorized","title":"lower_vectorized  <code>property</code>","text":"<pre><code>lower_vectorized: f64\n</code></pre> <p>Lower bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: Mapping[Hashable, Any] | None\n</code></pre> <p>Field for holding meta data provided by the user. Not used by the ConfigSpace.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the hyperparameter, with which it can be accessed.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: int = field(init=False)\n</code></pre> <p>The size of the hyperparameter's domain.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: int = int(rint(upper))\n</code></pre> <p>Upper bound of a range of values from which the hyperparameter represents.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.upper_vectorized","title":"upper_vectorized  <code>property</code>","text":"<pre><code>upper_vectorized: f64\n</code></pre> <p>Upper bound of the hyperparameter in vector space.</p>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.copy","title":"copy","text":"<pre><code>copy(**kwargs: Any) -&gt; Self\n</code></pre> <p>Create a copy of the hyperparameter with updated attributes.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>The attributes to update.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the hyperparameter with the updated attributes.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def copy(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Create a copy of the hyperparameter with updated attributes.\n\n    Args:\n        **kwargs:\n            The attributes to update.\n\n    Returns:\n        A copy of the hyperparameter with the updated attributes.\n    \"\"\"\n    # HACK: Really the only thing implementing Hyperparameter should be a dataclass\n    # If a hyperparameter is somehow not a dataclass, it will likely need to\n    # overwrite this.\n    return replace(self, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.get_max_density","title":"get_max_density","text":"<pre><code>get_max_density() -&gt; float\n</code></pre> <p>Get the maximum density of the hyperparameter distribution.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_max_density(self) -&gt; float:\n    \"\"\"Get the maximum density of the hyperparameter distribution.\"\"\"\n    return self._vector_dist.max_density()\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    value: f64,\n    rs: RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `neighbors_vectorized`  instead.\")\ndef get_neighbors(\n    self,\n    value: f64,\n    rs: np.random.RandomState,\n    number: int | None = None,\n    std: float | None = None,\n    transform: bool = False,\n) -&gt; Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if transform is True:\n        raise RuntimeError(\n            \"Previous `get_neighbors` with `transform=True` had different\"\n            \" behaviour depending on the hyperparameter. Notably numerics\"\n            \" were still considered to be in vectorized form while for ordinals\"\n            \" they were considered to be in value form.\"\n            \"\\nPlease use either `neighbors_vectorized` or `neighbors_values`\"\n            \" instead, depending on your need. You can use `to_value` or\"\n            \" `to_vector` to switch between the results of the two.\",\n        )\n\n    if number is None:\n        warnings.warn(\n            \"Please provide a number of neighbors to sample. The\"\n            \" default used to be `4` but will be explicitly required\"\n            \" in the futurefuture.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        number = 4\n\n    return self.neighbors_vectorized(value, number, std=std, seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.get_num_neighbors","title":"get_num_neighbors","text":"<pre><code>get_num_neighbors(\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float\n</code></pre> <p>Get the number of neighbors to sample for a given value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to get the number of neighbors for. If <code>None</code> the default value is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>ValueT | DType | _NotSet</code> DEFAULT: <code>NotSet</code> </p> RETURNS DESCRIPTION <code>int | float</code> <p>The number of neighbors to sample.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def get_num_neighbors(\n    self,\n    value: ValueT | DType | _NotSet = NotSet,\n) -&gt; int | float:\n    \"\"\"Get the number of neighbors to sample for a given value.\n\n    Args:\n        value:\n            The value to get the number of neighbors for. If `None` the\n            default value is used. Defaults to `None`.\n\n    Returns:\n        The number of neighbors to sample.\n    \"\"\"\n    return (\n        self._neighborhood_size(value)\n        if callable(self._neighborhood_size)\n        else self._neighborhood_size\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; int | float\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `.size` attribute instead.\")\ndef get_size(self) -&gt; int | float:\n    \"\"\"Deprecated.\"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.has_neighbors","title":"has_neighbors","text":"<pre><code>has_neighbors() -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `get_num_neighbors() &gt; 0` or `hp.size &gt; 1` instead.\")\ndef has_neighbors(self) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.get_num_neighbors() &gt; 0\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.is_legal","title":"is_legal","text":"<pre><code>is_legal(value: DType) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_value(value)` instead\")\ndef is_legal(self, value: DType) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_value(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.is_legal_vector","title":"is_legal_vector","text":"<pre><code>is_legal_vector(value: f64) -&gt; bool\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `legal_vector(vector)` instead.\")\ndef is_legal_vector(self, value: f64) -&gt; bool:\n    \"\"\"Deprecated.\"\"\"\n    return self.legal_vector(value)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.legal_value","title":"legal_value","text":"<pre><code>legal_value(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; bool | Mask\n</code></pre> <p>Check if a value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to check.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>bool | Mask</code> <p><code>True</code> if the value is legal, <code>False</code> otherwise. If <code>value</code> is an array of values, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_value(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; bool | Mask:\n    \"\"\"Check if a value is legal for this hyperparameter.\n\n    Args:\n        value:\n            The value to check.\n\n    Returns:\n        `True` if the value is legal, `False` otherwise. If `value` is an\n        array of values, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.legal_value(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.legal_value(np.asarray(value))\n\n    return self._transformer.legal_value_single(value)  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.legal_vector","title":"legal_vector","text":"<pre><code>legal_vector(vector: Number | Array[f64]) -&gt; Mask | bool\n</code></pre> <p>Check if a vectorized value is legal for this hyperparameter.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to check.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>Mask | bool</code> <p><code>True</code> if the vector is legal, <code>False</code> otherwise. If <code>vector</code> is an array of vectors, a mask of legal values is returned.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def legal_vector(self, vector: Number | Array[f64]) -&gt; Mask | bool:\n    \"\"\"Check if a vectorized value is legal for this hyperparameter.\n\n    Args:\n        vector:\n            The vectorized value to check.\n\n    Returns:\n        `True` if the vector is legal, `False` otherwise. If `vector` is an\n        array of vectors, a mask of legal values is returned.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        if not np.issubdtype(vector.dtype, np.number):\n            raise ValueError(\n                \"The vector must be of a numeric dtype to check for legality.\"\n                f\"Got {vector.dtype=} for {vector=}.\",\n            )\n        return self._transformer.legal_vector(vector)\n\n    if not isinstance(vector, (int, float, np.number)):\n        return False\n\n    return self._transformer.legal_vector_single(f64(vector))\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.neighbors_values","title":"neighbors_values","text":"<pre><code>neighbors_values(\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[DType]\n</code></pre> <p>Sample neighbors of a value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sample neighbors from.</p> <p> TYPE: <code>ValueT | DType</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[DType]</code> <p>The sampled neighbors in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_values(\n    self,\n    value: ValueT | DType,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[DType]:\n    \"\"\"Sample neighbors of a value.\n\n    Args:\n        value:\n            The value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in value space.\n    \"\"\"\n    vector = self.to_vector(value)\n    return self.to_value(\n        vector=self.neighbors_vectorized(vector, n, std=std, seed=seed),\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.neighbors_vectorized","title":"neighbors_vectorized","text":"<pre><code>neighbors_vectorized(\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None\n) -&gt; Array[f64]\n</code></pre> <p>Sample neighbors of a vectorized value.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to sample neighbors from.</p> <p> TYPE: <code>Number</code> </p> <code>n</code> <p>The number of unique neighbors to sample.</p> <p>Warning</p> <p>If there are less than <code>n</code> legal neighbors, then all legal neighbors are returned, which is some number less than <code>n</code>.</p> <p> TYPE: <code>int</code> </p> <code>std</code> <p>The standard deviation of the neighborhood. If <code>None</code> the neighborhood is deterministic. Defaults to <code>None</code>.</p> <p>Warning</p> <p>Hyperparameter subclasses are under no obligation to use this if it does not make sense, i.e. for an <code>OrdinalHyperparameter</code> or a <code>CategoricalHyperparameter</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The sampled neighbors in vectorized space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def neighbors_vectorized(\n    self,\n    vector: Number,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: np.random.RandomState | None = None,\n) -&gt; Array[f64]:\n    \"\"\"Sample neighbors of a vectorized value.\n\n    Args:\n        vector:\n            The vectorized value to sample neighbors from.\n        n:\n            The number of **unique** neighbors to sample.\n\n            !!! warning\n\n                If there are less than `n` legal neighbors, then all legal\n                neighbors are returned, which is some number less than `n`.\n        std:\n            The standard deviation of the neighborhood. If `None` the\n            neighborhood is deterministic. Defaults to `None`.\n\n            !!! warning\n\n                Hyperparameter subclasses are under no obligation to use\n                this if it does not make sense, i.e. for an\n                [`OrdinalHyperparameter`][ConfigSpace.hyperparameters.OrdinalHyperparameter]\n                or a\n                [`CategoricalHyperparameter`][ConfigSpace.hyperparameters.CategoricalHyperparameter].\n\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled neighbors in vectorized space.\n    \"\"\"\n    if std is not None:\n        assert 0.0 &lt;= std &lt;= 1.0, f\"std must be in [0, 1], got {std}\"\n\n    if not self.legal_vector(vector):\n        raise ValueError(\n            f\"Vector value {vector} is not legal for hyperparameter '{self.name}'.\"\n            f\"\\n{self}\",\n        )\n\n    return self._neighborhood(f64(vector), n, std=std, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.pdf","title":"pdf","text":"<pre><code>pdf(vector: DType | Array[DType]) -&gt; f64 | Array[f64]\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `pdf_values(value)` instead.\")\ndef pdf(\n    self,\n    vector: DType | Array[DType],  # NOTE: New convention this should be value\n) -&gt; f64 | Array[f64]:\n    \"\"\"Deprecated.\"\"\"\n    if isinstance(vector, np.ndarray):\n        return self.pdf_values(vector)\n\n    return self.pdf_values(np.asarray([vector]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.pdf_values","title":"pdf_values","text":"<pre><code>pdf_values(\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of values.</p> PARAMETER DESCRIPTION <code>values</code> <p>The values to get the probability density of.</p> <p> TYPE: <code>Sequence[ValueT | DType] | Array[DType]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the values. Where values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_values(\n    self,\n    values: Sequence[ValueT | DType] | Array[DType],\n) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of values.\n\n    Args:\n        values:\n            The values to get the probability density of.\n\n    Returns:\n        The probability density of the values. Where values are not legal,\n        the probability density is zero.\n    \"\"\"\n    if isinstance(values, np.ndarray) and values.ndim != 1:\n        raise ValueError(\"Method pdf expects a one-dimensional numpy array\")\n\n    vector = self.to_vector(values)\n    return self.pdf_vector(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.pdf_vector","title":"pdf_vector","text":"<pre><code>pdf_vector(vector: Array[f64]) -&gt; Array[f64]\n</code></pre> <p>Get the probability density of an array of vectorized values.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized values to get the probability density of.</p> <p> TYPE: <code>Array[f64]</code> </p> RETURNS DESCRIPTION <code>Array[f64]</code> <p>The probability density of the vectorized values. Where vectorized values are not legal, the probability density is zero.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def pdf_vector(self, vector: Array[f64]) -&gt; Array[f64]:\n    \"\"\"Get the probability density of an array of vectorized values.\n\n    Args:\n        vector:\n            The vectorized values to get the probability density of.\n\n    Returns:\n        The probability density of the vectorized values. Where vectorized\n        values are not legal, the probability density is zero.\n    \"\"\"\n    legal_mask: Array[f64] = self.legal_vector(vector).astype(f64)\n    return self._vector_dist.pdf_vector(vector) * legal_mask\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.rvs","title":"rvs","text":"<pre><code>rvs(\n    size: int | None = None,\n    *,\n    random_state: (\n        Generator | RandomState | int | None\n    ) = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>random_state</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>Generator | RandomState | int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def rvs(\n    self,\n    size: int | None = None,\n    *,\n    random_state: np.random.Generator | np.random.RandomState | int | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter, compatbile with scipy.stats.rvs.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        random_state:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    if isinstance(random_state, int) or random_state is None:\n        random_state = np.random.RandomState(random_state)\n    elif isinstance(random_state, np.random.Generator):\n        # HACK: This is to enable backwards compatibliity with numpy&lt;=2.0,\n        # where the default integer type is np.int32.\n        MAX_INT = np.iinfo(np.int32).max\n        random_state = np.random.RandomState(int(random_state.integers(0, MAX_INT)))\n\n    vector = self.sample_vector(size=size, seed=random_state)\n    return self.to_value(vector)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.sample","title":"sample","text":"<pre><code>sample(rs: RandomState) -&gt; ValueT\n</code></pre> <p>Deprecated.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>@deprecated(\"Please use `sample_value(seed=rs)` instead.\")\ndef sample(self, rs: np.random.RandomState) -&gt; ValueT:\n    \"\"\"Deprecated.\"\"\"\n    return self.sample_value(seed=rs)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.sample_value","title":"sample_value","text":"<pre><code>sample_value(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Sample a value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The sampled value or an array of sampled values, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_value(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Sample a value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled value or an array of sampled values, depending on `size=`.\n    \"\"\"\n    samples = self.sample_vector(size=size, seed=seed)\n    return self.to_value(samples)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(\n    size: int | None = None,\n    *,\n    seed: RandomState | None = None\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Sample a vectorized value from this hyperparameter.</p> PARAMETER DESCRIPTION <code>size</code> <p>The number of values to sample. If <code>None</code> a single value is sampled. Defaults to <code>None</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>The random state to use for sampling. If <code>None</code> the global random state is used. Defaults to <code>None</code>.</p> <p> TYPE: <code>RandomState | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The sampled vector or an array of sampled vectors, depending on <code>size=</code>.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def sample_vector(\n    self,\n    size: int | None = None,\n    *,\n    seed: np.random.RandomState | None = None,\n) -&gt; f64 | Array[f64]:\n    \"\"\"Sample a vectorized value from this hyperparameter.\n\n    Args:\n        size:\n            The number of values to sample. If `None` a single value is\n            sampled. Defaults to `None`.\n        seed:\n            The random state to use for sampling. If `None` the global\n            random state is used. Defaults to `None`.\n\n    Returns:\n        The sampled vector or an array of sampled vectors, depending on `size=`.\n    \"\"\"\n    if size is None:\n        return self._vector_dist.sample_vector(n=1, seed=seed)[0]  # type: ignore\n    return self._vector_dist.sample_vector(n=size, seed=seed)\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.to_float","title":"to_float","text":"<pre><code>to_float() -&gt; UniformFloatHyperparameter\n</code></pre> <p>Convert this hyperparameter to a uniform float hyperparameter.</p> RETURNS DESCRIPTION <code>UniformFloatHyperparameter</code> <p>A uniform float hyperparameter with the same range as this.</p> Source code in <code>src/ConfigSpace/hyperparameters/uniform_integer.py</code> <pre><code>def to_float(self) -&gt; UniformFloatHyperparameter:\n    \"\"\"Convert this hyperparameter to a uniform float hyperparameter.\n\n    Returns:\n        A uniform float hyperparameter with the same range as this.\n    \"\"\"\n    from ConfigSpace.hyperparameters.uniform_float import UniformFloatHyperparameter\n\n    return UniformFloatHyperparameter(\n        name=self.name,\n        lower=self.lower,\n        upper=self.upper,\n        default_value=self.default_value,\n        log=self.log,\n        meta=self.meta,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.to_uniform","title":"to_uniform","text":"<pre><code>to_uniform() -&gt; UniformIntegerHyperparameter\n</code></pre> <p>Convert the hyperparameter to its uniform equivalent.</p> <p>This will remove any distribution associated with it's vectorized representation.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_uniform(self) -&gt; UniformIntegerHyperparameter:\n    \"\"\"Convert the hyperparameter to its uniform equivalent.\n\n    This will remove any distribution associated with it's vectorized\n    representation.\n    \"\"\"\n    from ConfigSpace.hyperparameters.uniform_integer import (\n        UniformIntegerHyperparameter,\n    )\n\n    return UniformIntegerHyperparameter(\n        name=self.name,\n        lower=self.lower,\n        upper=self.upper,\n        default_value=self.default_value,\n        log=self.log,\n        meta=self.meta,\n    )\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.to_value","title":"to_value","text":"<pre><code>to_value(\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]\n</code></pre> <p>Transform a vectorized value to a value in value space.</p> PARAMETER DESCRIPTION <code>vector</code> <p>The vectorized value to transform.</p> <p> TYPE: <code>Number | Array[f64]</code> </p> RETURNS DESCRIPTION <code>ValueT | Array[DType]</code> <p>The value in value space.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_value(\n    self,\n    vector: Number | Array[f64],\n) -&gt; ValueT | Array[DType]:\n    \"\"\"Transform a vectorized value to a value in value space.\n\n    Args:\n        vector:\n            The vectorized value to transform.\n\n    Returns:\n        The value in value space.\n    \"\"\"\n    if isinstance(vector, np.ndarray):\n        return self._transformer.to_value(vector)\n\n    value: DType = self._transformer.to_value(np.array([vector]))[0]\n    if self._value_cast is not None:\n        return self._value_cast(value)\n\n    return value  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/hyperparameters/uniform_integer/#ConfigSpace.hyperparameters.uniform_integer.UniformIntegerHyperparameter.to_vector","title":"to_vector","text":"<pre><code>to_vector(\n    value: (\n        ValueT\n        | DType\n        | Sequence[ValueT | DType]\n        | Array[Any]\n    ),\n) -&gt; f64 | Array[f64]\n</code></pre> <p>Transform a value to a vectorized value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to transform.</p> <p> TYPE: <code>ValueT | DType | Sequence[ValueT | DType] | Array[Any]</code> </p> RETURNS DESCRIPTION <code>f64 | Array[f64]</code> <p>The vectorized value.</p> Source code in <code>src/ConfigSpace/hyperparameters/hyperparameter.py</code> <pre><code>def to_vector(\n    self,\n    value: ValueT | DType | Sequence[ValueT | DType] | Array[Any],\n) -&gt; f64 | Array[f64]:\n    \"\"\"Transform a value to a vectorized value.\n\n    Args:\n        value:\n            The value to transform.\n\n    Returns:\n        The vectorized value.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return self._transformer.to_vector(value)\n\n    if isinstance(value, Sequence) and not isinstance(value, str):\n        return self._transformer.to_vector(np.asarray(value))\n\n    return self._transformer.to_vector(np.array([value]))[0]  # type: ignore\n</code></pre>"},{"location":"api/ConfigSpace/read_and_write/dictionary/","title":"Dictionary","text":""},{"location":"api/ConfigSpace/read_and_write/dictionary/#ConfigSpace.read_and_write.dictionary","title":"ConfigSpace.read_and_write.dictionary","text":""},{"location":"api/ConfigSpace/read_and_write/json/","title":"Json","text":""},{"location":"api/ConfigSpace/read_and_write/json/#ConfigSpace.read_and_write.json","title":"ConfigSpace.read_and_write.json","text":""},{"location":"api/ConfigSpace/read_and_write/json/#ConfigSpace.read_and_write.json.read","title":"read","text":"<pre><code>read(\n    jason_string: str,\n    decoders: (\n        Mapping[\n            Literal[\n                \"hyperparameters\",\n                \"conditions\",\n                \"forbiddens\",\n            ],\n            Mapping[str, _Decoder],\n        ]\n        | None\n    ) = None,\n) -&gt; ConfigurationSpace\n</code></pre> <p>Create a configuration space definition from a json string.</p> <pre><code>from ConfigSpace import ConfigurationSpace\nfrom ConfigSpace.read_and_write import json as cs_json\n\ncs = ConfigurationSpace({\"a\": [1, 2, 3]})\n\ncs_string = cs_json.write(cs)\nwith open('configspace.json', 'w') as f:\n     f.write(cs_string)\n\nwith open('configspace.json', 'r') as f:\n    json_string = f.read()\n    config = cs_json.read(json_string)\n</code></pre> PARAMETER DESCRIPTION <code>jason_string</code> <p>A json string representing a configuration space definition</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ConfigurationSpace</code> <p>The deserialized ConfigurationSpace object</p> Source code in <code>src/ConfigSpace/read_and_write/json.py</code> <pre><code>@deprecated(\n    \"Please use `space.from_json(path)` instead. If you already have the\"\n    \" json string, pass it as `space.from_json(StringIO(jsn))`.\",\n)\ndef read(\n    jason_string: str,\n    decoders: Mapping[\n        Literal[\"hyperparameters\", \"conditions\", \"forbiddens\"],\n        Mapping[str, _Decoder],\n    ]\n    | None = None,\n) -&gt; ConfigurationSpace:\n    \"\"\"Create a configuration space definition from a json string.\n\n    ```python\n    from ConfigSpace import ConfigurationSpace\n    from ConfigSpace.read_and_write import json as cs_json\n\n    cs = ConfigurationSpace({\"a\": [1, 2, 3]})\n\n    cs_string = cs_json.write(cs)\n    with open('configspace.json', 'w') as f:\n         f.write(cs_string)\n\n    with open('configspace.json', 'r') as f:\n        json_string = f.read()\n        config = cs_json.read(json_string)\n    ```\n\n\n    Args:\n        jason_string: A json string representing a configuration space definition\n\n    Returns:\n        The deserialized ConfigurationSpace object\n    \"\"\"\n    return ConfigurationSpace.from_json(StringIO(jason_string), decoders=decoders)\n</code></pre>"},{"location":"api/ConfigSpace/read_and_write/json/#ConfigSpace.read_and_write.json.write","title":"write","text":"<pre><code>write(\n    space: ConfigurationSpace,\n    indent: int = 2,\n    encoders: (\n        Mapping[type, tuple[str, _Encoder]] | None\n    ) = None,\n) -&gt; str\n</code></pre> <p>Create a string representation of a ConfigurationSpace in json format. This string can be written to file.</p> <pre><code>from ConfigSpace import ConfigurationSpace\nfrom ConfigSpace.read_and_write import json as cs_json\n\ncs = ConfigurationSpace({\"a\": [1, 2, 3]})\n\nwith open('configspace.json', 'w') as f:\n    f.write(cs_json.write(cs))\n</code></pre> PARAMETER DESCRIPTION <code>space</code> <p>A configuration space, which should be written to file.</p> <p> TYPE: <code>ConfigurationSpace</code> </p> <code>indent</code> <p>number of whitespaces to use as indent</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>encoders</code> <p>Additional encoders to include where they key is a type to which the encoder applies to and the value is a tuple, where the first element is the type name to include in the dictionary and the second element is the encoder function which gives back a serializable dictionary.</p> <p> TYPE: <code>Mapping[type, tuple[str, _Encoder]] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>String representation of the configuration space, which can be written to file</p> Source code in <code>src/ConfigSpace/read_and_write/json.py</code> <pre><code>@deprecated(\n    \"Please use `space.to_json(path)` directly instead. If you require the json string \"\n    \" directly, pass a `StringIO` object to `space.to_json(buffer)`.\",\n)\ndef write(\n    space: ConfigurationSpace,\n    indent: int = 2,\n    encoders: Mapping[type, tuple[str, _Encoder]] | None = None,\n) -&gt; str:\n    \"\"\"Create a string representation of a\n    [ConfigurationSpace][ConfigSpace.configuration_space.ConfigurationSpace] in json format.\n    This string can be written to file.\n\n    ```python\n    from ConfigSpace import ConfigurationSpace\n    from ConfigSpace.read_and_write import json as cs_json\n\n    cs = ConfigurationSpace({\"a\": [1, 2, 3]})\n\n    with open('configspace.json', 'w') as f:\n        f.write(cs_json.write(cs))\n    ```\n\n    Args:\n        space: A configuration space, which should be written to file.\n        indent: number of whitespaces to use as indent\n        encoders:\n            Additional encoders to include where they key is a type to which the encoder\n            applies to and the value is a tuple, where the first element is the type name\n            to include in the dictionary and the second element is the encoder function\n            which gives back a serializable dictionary.\n\n    Returns:\n        String representation of the configuration space, which can be written to file\n    \"\"\"\n    buffer = StringIO()\n    with buffer as f:\n        space.to_json(f, indent=indent, encoders=encoders)\n        return f.getvalue()\n</code></pre>"},{"location":"api/ConfigSpace/read_and_write/pcs/","title":"Pcs","text":""},{"location":"api/ConfigSpace/read_and_write/pcs/#ConfigSpace.read_and_write.pcs","title":"ConfigSpace.read_and_write.pcs","text":"<p>The old PCS format is part of the <code>Algorithm Configuration Library &lt;http://aclib.net/#&gt;</code>_.</p> <p>A detailed explanation of the old PCS format can be found <code>here. &lt;http://aclib.net/cssc2014/pcs-format.pdf&gt;</code>_</p>"},{"location":"api/ConfigSpace/read_and_write/pcs/#ConfigSpace.read_and_write.pcs.read","title":"read","text":"<pre><code>read(pcs_string: Iterable[str]) -&gt; ConfigurationSpace\n</code></pre> <p>Read in a ConfigurationSpace definition from a pcs file.</p> <pre><code>from ConfigSpace import ConfigurationSpace\nfrom ConfigSpace.read_and_write import pcs\n\ncs = ConfigurationSpace({\"a\": [1, 2, 3]})\nwith open('configspace.pcs', 'w') as f:\n     f.write(pcs.write(cs))\n\nwith open('configspace.pcs', 'r') as f:\n    deserialized_conf = pcs.read(f)\n</code></pre> PARAMETER DESCRIPTION <code>pcs_string</code> <p>ConfigSpace definition in pcs format as an iterable of strings</p> <p> TYPE: <code>Iterable[str]</code> </p> RETURNS DESCRIPTION <code>ConfigurationSpace</code> <p>The deserialized ConfigurationSpace object</p> Source code in <code>src/ConfigSpace/read_and_write/pcs.py</code> <pre><code>@deprecated(\n    \"pcs.read is has stopped being maintained, please use `space.to_json`\"\n    \" or `space.to_yaml` instead\",\n)\ndef read(pcs_string: Iterable[str]) -&gt; ConfigurationSpace:\n    \"\"\"Read in a [ConfigurationSpace][ConfigSpace.configuration_space.ConfigurationSpace]\n    definition from a pcs file.\n\n\n    ```python\n    from ConfigSpace import ConfigurationSpace\n    from ConfigSpace.read_and_write import pcs\n\n    cs = ConfigurationSpace({\"a\": [1, 2, 3]})\n    with open('configspace.pcs', 'w') as f:\n         f.write(pcs.write(cs))\n\n    with open('configspace.pcs', 'r') as f:\n        deserialized_conf = pcs.read(f)\n    ```\n\n    Args:\n        pcs_string: ConfigSpace definition in pcs format as an iterable of strings\n\n    Returns:\n        The deserialized ConfigurationSpace object\n    \"\"\"\n    if isinstance(pcs_string, str):\n        pcs_string = pcs_string.split(\"\\n\")\n\n    configuration_space = ConfigurationSpace()\n    hp_params_to_add = []\n    conditions_to_add = []\n    forbiddens_to_add = []\n\n    conditions = []\n    forbidden = []\n\n    # some statistics\n    ct = 0\n    cont_ct = 0\n    cat_ct = 0\n    line_ct = 0\n\n    for line in pcs_string:\n        line_ct += 1\n\n        if \"#\" in line:\n            # It contains a comment\n            pos = line.find(\"#\")\n            line = line[:pos]\n\n        # Remove quotes and whitespaces at beginning and end\n        line = line.replace('\"', \"\").replace(\"'\", \"\")\n        line = line.strip()\n\n        if \"|\" in line:\n            # It's a condition\n            try:\n                c = pp_condition.parseString(line)\n                conditions.append(c)\n            except pyparsing.ParseException as e:\n                raise NotImplementedError(f\"Could not parse condition: {line}\") from e\n\n            continue\n        if \"}\" not in line and \"]\" not in line:\n            continue\n        if line.startswith(\"{\") and line.endswith(\"}\"):\n            forbidden.append(line)\n            continue\n        if len(line.strip()) == 0:\n            continue\n\n        ct += 1\n        param = None\n\n        create = {\n            \"int\": UniformIntegerHyperparameter,\n            \"float\": UniformFloatHyperparameter,\n            \"categorical\": CategoricalHyperparameter,\n        }\n\n        try:\n            param_list = pp_cont_param.parseString(line)\n            il = param_list[9:]\n            if len(il) &gt; 0:\n                il = il[0]\n            param_list = param_list[:9]\n            name = param_list[0]\n            lower = float(param_list[2])  # type: ignore\n            upper = float(param_list[4])  # type: ignore\n            paramtype = \"int\" if \"i\" in il else \"float\"\n            log = \"l\" in il\n            default_value = float(param_list[7])  # type: ignore\n            param = create[paramtype](\n                name=name,\n                lower=lower,\n                upper=upper,\n                log=log,\n                default_value=default_value,\n            )\n            cont_ct += 1\n        except pyparsing.ParseException:\n            pass\n\n        try:\n            param_list = pp_cat_param.parseString(line)\n            name = param_list[0]\n            choices = list(param_list[2:-4:2])\n            default_value = param_list[-2]\n            param = create[\"categorical\"](\n                name=name,\n                choices=choices,\n                default_value=default_value,\n            )\n            cat_ct += 1\n        except pyparsing.ParseException:\n            pass\n\n        if param is None:\n            raise NotImplementedError(f\"Could not parse: {line}\")\n\n        hp_params_to_add.append(param)\n\n    configuration_space.add(hp_params_to_add)\n\n    for clause in forbidden:\n        # TODO test this properly!\n        # TODO Add a try/catch here!\n        # noinspection PyUnusedLocal\n        param_list = pp_forbidden_clause.parseString(clause)\n        tmp_list: list = []\n        clause_list = []\n        for value in param_list[1:]:\n            if len(tmp_list) &lt; 3:\n                tmp_list.append(value)\n            else:\n                # So far, only equals is supported by SMAC\n                if tmp_list[1] == \"=\":\n                    # TODO maybe add a check if the hyperparameter is\n                    # actually in the configuration space\n                    clause_list.append(\n                        ForbiddenEqualsClause(\n                            configuration_space[tmp_list[0]],\n                            tmp_list[2],\n                        ),\n                    )\n                else:\n                    raise NotImplementedError()\n                tmp_list = []\n\n        forbiddens_to_add.append(ForbiddenAndConjunction(*clause_list))\n\n    # Now handle conditions\n    # If there are two conditions for one child, these two conditions are an\n    # AND-conjunction of conditions, thus we have to connect them\n    conditions_per_child: dict = OrderedDict()\n    for condition in conditions:\n        child_name = condition[0]\n        if child_name not in conditions_per_child:\n            conditions_per_child[child_name] = []\n        conditions_per_child[child_name].append(condition)\n\n    for child_name in conditions_per_child:\n        condition_objects = []\n        for condition in conditions_per_child[child_name]:\n            child = configuration_space[child_name]\n            parent_name = condition[2]\n            parent = configuration_space[parent_name]\n            restrictions = condition[5:-1:2]\n\n            # TODO: cast the type of the restriction!\n            if len(restrictions) == 1:\n                condition = EqualsCondition(child, parent, restrictions[0])\n            else:\n                condition = InCondition(child, parent, values=restrictions)\n            condition_objects.append(condition)\n\n        # Now we have all condition objects for this child, so we can build a\n        #  giant AND-conjunction of them (if number of conditions &gt;= 2)!\n\n        if len(condition_objects) &gt; 1:\n            and_conjunction = AndConjunction(*condition_objects)\n            conditions_to_add.append(and_conjunction)\n        else:\n            conditions_to_add.append(condition_objects[0])\n\n    configuration_space.add(conditions_to_add, forbiddens_to_add)\n\n    return configuration_space\n</code></pre>"},{"location":"api/ConfigSpace/read_and_write/pcs/#ConfigSpace.read_and_write.pcs.write","title":"write","text":"<pre><code>write(configuration_space: ConfigurationSpace) -&gt; str\n</code></pre> <p>Create a string representation of a ConfigurationSpace in pcs format. This string can be written to file.</p> <pre><code>from ConfigSpace import ConfigurationSpace\nfrom ConfigSpace.read_and_write import pcs\n\ncs = ConfigurationSpace({\"a\": [1, 2, 3]})\n\nwith open('configspace.pcs', 'w') as fh:\n    fh.write(pcs.write(cs))\n</code></pre> PARAMETER DESCRIPTION <code>configuration_space</code> <p>a configuration space</p> <p> TYPE: <code>ConfigurationSpace</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The string representation of the configuration space</p> Source code in <code>src/ConfigSpace/read_and_write/pcs.py</code> <pre><code>@deprecated(\n    \"pcs.write is has stopped being maintained, please use `space.to_json`\"\n    \" or `space.to_yaml` instead\",\n)\ndef write(configuration_space: ConfigurationSpace) -&gt; str:\n    \"\"\"Create a string representation of a\n    [ConfigurationSpace][ConfigSpace.configuration_space.ConfigurationSpace] in pcs format.\n    This string can be written to file.\n\n    ```python\n    from ConfigSpace import ConfigurationSpace\n    from ConfigSpace.read_and_write import pcs\n\n    cs = ConfigurationSpace({\"a\": [1, 2, 3]})\n\n    with open('configspace.pcs', 'w') as fh:\n        fh.write(pcs.write(cs))\n    ```\n\n    Args:\n        configuration_space: a configuration space\n\n    Returns:\n        The string representation of the configuration space\n\n    \"\"\"\n    if not isinstance(configuration_space, ConfigurationSpace):\n        raise TypeError(\n            f\"pcs_parser.write expects an instance of {ConfigurationSpace}, \"\n            f\"you provided '{type(configuration_space)}'\",\n        )\n\n    param_lines = StringIO()\n    condition_lines = StringIO()\n    forbidden_lines = []\n    for hyperparameter in configuration_space.values():\n        # Check if the hyperparameter names are valid ConfigSpace names!\n        try:\n            pp_param_name.parseString(hyperparameter.name)\n        except pyparsing.ParseException as e:\n            raise ValueError(\n                f\"Illegal hyperparameter name for ConfigSpace: {hyperparameter.name}\",\n            ) from e\n\n        # First build params\n        if param_lines.tell() &gt; 0:\n            param_lines.write(\"\\n\")\n        if isinstance(hyperparameter, NumericalHyperparameter):\n            param_lines.write(build_continuous(hyperparameter))  # type: ignore\n        elif isinstance(hyperparameter, CategoricalHyperparameter):\n            param_lines.write(build_categorical(hyperparameter))\n        elif isinstance(hyperparameter, Constant):\n            param_lines.write(build_constant(hyperparameter))\n        else:\n            raise TypeError(f\"Unknown type: {type(hyperparameter)} ({hyperparameter})\")\n\n    for condition in configuration_space.conditions:\n        if condition_lines.tell() &gt; 0:\n            condition_lines.write(\"\\n\")\n        condition_lines.write(build_condition(condition))\n\n    for forbidden_clause in configuration_space.forbidden_clauses:\n        # Convert in-statement into two or more equals statements\n        dlcs = (\n            [forbidden_clause]\n            if not isinstance(forbidden_clause, ForbiddenConjunction)\n            else forbidden_clause.dlcs\n        )\n        # First, get all in statements and convert them to equal statements\n        in_statements = []\n        other_statements = []\n        for dlc in dlcs:\n            if isinstance(dlc, ForbiddenInClause):\n                in_statements.append(\n                    [\n                        ForbiddenEqualsClause(dlc.hyperparameter, value)\n                        for value in dlc.values\n                    ],\n                )\n            else:\n                other_statements.append(dlc)\n\n        # Second, create the product of all elements in the IN statements,\n        # create a ForbiddenAnd and add all ForbiddenEquals\n        if len(in_statements) &gt; 0:\n            for p in product(*in_statements):\n                all_forbidden_clauses = list(p) + other_statements\n                f = ForbiddenAndConjunction(*all_forbidden_clauses)\n                forbidden_lines.append(build_forbidden(f))\n        else:\n            forbidden_lines.append(build_forbidden(forbidden_clause))\n\n    if condition_lines.tell() &gt; 0:\n        condition_lines.seek(0)\n        param_lines.write(\"\\n\\n\")\n        for line in condition_lines:\n            param_lines.write(line)\n\n    if len(forbidden_lines) &gt; 0:\n        forbidden_lines.sort()\n        param_lines.write(\"\\n\\n\")\n        for line in forbidden_lines:\n            param_lines.write(line)\n            param_lines.write(\"\\n\")\n\n    # Check if the default configuration is a valid configuration!\n\n    param_lines.seek(0)\n    return param_lines.getvalue()\n</code></pre>"},{"location":"api/ConfigSpace/read_and_write/pcs_new/","title":"Pcs new","text":""},{"location":"api/ConfigSpace/read_and_write/pcs_new/#ConfigSpace.read_and_write.pcs_new","title":"ConfigSpace.read_and_write.pcs_new","text":"<p>PCS (parameter configuration space) is a simple, human-readable file format for the description of an algorithm's configurable parameters, their possible values, as well as any parameter dependencies. There exist an old and a new version.</p> <p>The new PCS format is part of the Algorithm Configuration Library 2.0. A detailed description of the new format can be found in the ACLIB 2.0 docs, in the SMACv2 docs and further examples are provided in the pysmac docs</p> <p>Warning</p> <p>The PCS format definition has changed in the year 2016 and is supported by AClib 2.0, as well as SMAC (v2 and v3). Please check the serialization guide for more information.</p>"},{"location":"api/ConfigSpace/read_and_write/pcs_new/#ConfigSpace.read_and_write.pcs_new.read","title":"read","text":"<pre><code>read(pcs_string: Iterable[str]) -&gt; ConfigurationSpace\n</code></pre> <p>Read a ConfigurationSpace definition from a pcs file.</p> <pre><code>from ConfigSpace import ConfigurationSpace\n\nfrom ConfigSpace.read_and_write import pcs_new\ncs = ConfigurationSpace({\"a\": [1,2,3]})\n\nwith open('configspace.pcs_new', 'w') as f:\n     f.write(pcs_new.write(cs))\n\nwith open('configspace.pcs_new', 'r') as fh:\n    deserialized_conf = pcs_new.read(fh)\n\nprint(deserialized_conf)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: Categorical, Choices: {1, 2, 3}, Default: 1\n</code></pre> PARAMETER DESCRIPTION <code>pcs_string</code> <p>ConfigSpace definition in pcs format</p> <p> TYPE: <code>Iterable[str]</code> </p> RETURNS DESCRIPTION <code>ConfigurationSpace</code> <p>The deserialized ConfigurationSpace object</p> Source code in <code>src/ConfigSpace/read_and_write/pcs_new.py</code> <pre><code>@deprecated(\n    \"pcs_new.read is has stopped being maintained, please use `space.to_json`\"\n    \" or `space.to_yaml` instead\",\n)\ndef read(pcs_string: Iterable[str]) -&gt; ConfigurationSpace:\n    \"\"\"Read a [ConfigurationSpace][ConfigSpace.configuration_space.ConfigurationSpace]\n    definition from a pcs file.\n\n\n    ```python exec=\"true\", source=\"material-block\" result=\"python\"\n    from ConfigSpace import ConfigurationSpace\n\n    from ConfigSpace.read_and_write import pcs_new\n    cs = ConfigurationSpace({\"a\": [1,2,3]})\n\n    with open('configspace.pcs_new', 'w') as f:\n         f.write(pcs_new.write(cs))\n\n    with open('configspace.pcs_new', 'r') as fh:\n        deserialized_conf = pcs_new.read(fh)\n\n    print(deserialized_conf)\n    ```\n\n    Args:\n        pcs_string: ConfigSpace definition in pcs format\n\n    Returns:\n        The deserialized ConfigurationSpace object\n    \"\"\"\n    configuration_space = ConfigurationSpace()\n    forbidden_to_add = []\n    conditions_to_add = []\n\n    conditions = []\n    forbidden = []\n\n    # some statistics\n    ct = 0\n    cont_ct = 0\n    cat_ct = 0\n    ord_ct = 0\n    line_ct = 0\n\n    for line in pcs_string:\n        line_ct += 1\n\n        if \"#\" in line:\n            # It contains a comment\n            pos = line.find(\"#\")\n            line = line[:pos]\n\n        # Remove quotes and whitespaces at beginning and end\n        line = line.replace('\"', \"\").replace(\"'\", \"\")\n        line = line.strip()\n        if \"|\" in line:\n            # It's a condition\n            try:\n                c = pp_condition.parseString(line)\n                conditions.append(c)\n            except pyparsing.ParseException as e:\n                raise NotImplementedError(f\"Could not parse condition: {line}\") from e\n\n            continue\n        if \"}\" not in line and \"]\" not in line:\n            continue\n        if line.startswith(\"{\") and line.endswith(\"}\"):\n            forbidden.append(line)\n            continue\n        if len(line.strip()) == 0:\n            continue\n\n        ct += 1\n        param = None\n\n        create = {\n            \"int\": UniformIntegerHyperparameter,\n            \"float\": UniformFloatHyperparameter,\n            \"categorical\": CategoricalHyperparameter,\n            \"ordinal\": OrdinalHyperparameter,\n        }\n\n        try:\n            param_list = pp_cont_param.parseString(line)\n            name = param_list[0]\n            if param_list[1] == \"integer\":\n                paramtype = \"int\"\n                value_cast = int\n            elif param_list[1] == \"real\":\n                paramtype = \"float\"\n                value_cast = float\n            else:\n                paramtype = None\n                value_cast = lambda x: x\n\n            if paramtype in [\"int\", \"float\"]:\n                log = param_list[10:]\n                param_list = param_list[:10]\n                if len(log) &gt; 0:\n                    log = log[0]\n                lower = value_cast(param_list[3])  # type: ignore\n                upper = value_cast(param_list[5])  # type: ignore\n                log_on = \"log\" in log\n                default_value = value_cast(param_list[8])  # type: ignore\n                param = create[paramtype](\n                    name=name,\n                    lower=lower,\n                    upper=upper,\n                    log=log_on,\n                    default_value=default_value,\n                )\n                cont_ct += 1\n\n        except pyparsing.ParseException:\n            pass\n\n        try:\n            if \"categorical\" in line:\n                param_list = pp_cat_param.parseString(line)\n                name = param_list[0]\n                choices = list(param_list[3:-4:2])\n                default_value = param_list[-2]\n                param = create[\"categorical\"](\n                    name=name,\n                    choices=choices,\n                    default_value=default_value,\n                )\n                cat_ct += 1\n\n            elif \"ordinal\" in line:\n                param_list = pp_ord_param.parseString(line)\n                name = param_list[0]\n                sequence = list(param_list[3:-4:2])\n                default_value = param_list[-2]\n                param = create[\"ordinal\"](\n                    name=name,\n                    sequence=sequence,\n                    default_value=default_value,\n                )\n                ord_ct += 1\n\n        except pyparsing.ParseException:\n            pass\n\n        if param is None:\n            raise NotImplementedError(f\"Could not parse: {line}\")\n\n        configuration_space.add(param)\n\n    for clause in forbidden:\n        param_list = pp_forbidden_clause.parseString(clause)\n        tmp_list: list = []\n        clause_list = []\n        for value in param_list[1:]:\n            if len(tmp_list) &lt; 3:\n                tmp_list.append(value)\n            else:\n                # So far, only equals is supported by SMAC\n                if tmp_list[1] == \"=\":\n                    hp = configuration_space[tmp_list[0]]\n                    if isinstance(hp, NumericalHyperparameter):\n                        forbidden_value: float | int\n                        if isinstance(hp, IntegerHyperparameter):\n                            forbidden_value = int(tmp_list[2])\n                        elif isinstance(hp, FloatHyperparameter):\n                            forbidden_value = float(tmp_list[2])\n                        else:\n                            raise NotImplementedError\n\n                        if forbidden_value &lt; hp.lower or forbidden_value &gt; hp.upper:\n                            raise ValueError(\n                                f\"forbidden_value is set out of the bound, it needs to\"\n                                f\" be set between [{hp.lower}, {hp.upper}]\"\n                                f\" but its value is {forbidden_value}\",\n                            )\n\n                    elif isinstance(\n                        hp,\n                        (CategoricalHyperparameter, OrdinalHyperparameter),\n                    ):\n                        hp_values = (\n                            hp.choices\n                            if isinstance(hp, CategoricalHyperparameter)\n                            else hp.sequence\n                        )\n                        forbidden_value_in_hp_values = tmp_list[2] in hp_values\n\n                        if forbidden_value_in_hp_values:\n                            forbidden_value = tmp_list[2]\n                        else:\n                            raise ValueError(\n                                f\"forbidden_value is set out of the allowed value \"\n                                f\"sets, it needs to be one member from {hp_values} \"\n                                f\"but its value is {tmp_list[2]}\",\n                            )\n                    else:\n                        raise ValueError(\"Unsupported Hyperparamter sorts\")\n\n                    clause_list.append(\n                        ForbiddenEqualsClause(\n                            configuration_space[tmp_list[0]],\n                            forbidden_value,\n                        ),\n                    )\n                else:\n                    raise NotImplementedError()\n                tmp_list = []\n        forbidden_to_add.append(ForbiddenAndConjunction(*clause_list))\n\n    configuration_space.add(forbidden_to_add)\n\n    conditions_per_child: dict = OrderedDict()\n\n    for condition in conditions:\n        child_name = condition[0]\n        if child_name not in conditions_per_child:\n            conditions_per_child[child_name] = []\n        conditions_per_child[child_name].append(condition)\n\n    for child_name in conditions_per_child:\n        for condition in conditions_per_child[child_name]:\n            condition = condition[2:]\n            condition = \" \".join(condition)  # type: ignore\n            if \"||\" in str(condition):\n                ors = []\n                # 1st case we have a mixture of || and &amp;&amp;\n                if \"&amp;&amp;\" in str(condition):\n                    ors_combis = []\n                    for cond_parts in str(condition).split(\"||\"):\n                        condition = str(cond_parts).split(\"&amp;&amp;\")  # type: ignore\n                        # if length is 1 it must be or\n                        if len(condition) == 1:\n                            element_list = condition[0].split()\n                            ors_combis.append(\n                                condition_specification(\n                                    child_name,\n                                    element_list,\n                                    configuration_space,\n                                ),\n                            )\n                        else:\n                            # now taking care of ands\n                            ands = []\n                            for and_part in condition:\n                                element_list = [\n                                    element\n                                    for _ in condition\n                                    for element in and_part.split()\n                                ]\n                                ands.append(\n                                    condition_specification(\n                                        child_name,\n                                        element_list,\n                                        configuration_space,\n                                    ),\n                                )\n                            ors_combis.append(AndConjunction(*ands))\n                    mixed_conjunction = OrConjunction(*ors_combis)\n                    conditions_to_add.append(mixed_conjunction)\n                else:\n                    # 2nd case: we only have ors\n                    for cond_parts in str(condition).split(\"||\"):\n                        element_list = list(cond_parts.split())\n                        ors.append(\n                            condition_specification(\n                                child_name,\n                                element_list,\n                                configuration_space,\n                            ),\n                        )\n                    or_conjunction = OrConjunction(*ors)\n                    conditions_to_add.append(or_conjunction)\n\n            # 3rd case: we only have ands\n            elif \"&amp;&amp;\" in str(condition):\n                ands = []\n                for cond_parts in str(condition).split(\"&amp;&amp;\"):\n                    element_list = list(cond_parts.split())\n                    ands.append(\n                        condition_specification(\n                            child_name,\n                            element_list,\n                            configuration_space,\n                        ),\n                    )\n                and_conjunction = AndConjunction(*ands)\n                conditions_to_add.append(and_conjunction)\n\n            # 4th case: we have a normal condition\n            else:\n                element_list = list(condition.split())\n                normal_condition = condition_specification(\n                    child_name,\n                    element_list,\n                    configuration_space,\n                )\n                conditions_to_add.append(normal_condition)\n\n    configuration_space.add(conditions_to_add)\n\n    return configuration_space\n</code></pre>"},{"location":"api/ConfigSpace/read_and_write/pcs_new/#ConfigSpace.read_and_write.pcs_new.write","title":"write","text":"<pre><code>write(configuration_space: ConfigurationSpace) -&gt; str\n</code></pre> <p>Create a string representation of a ConfigurationSpace in pcs_new format. This string can be written to file.</p> <pre><code>from ConfigSpace import ConfigurationSpace\nfrom ConfigSpace.read_and_write import pcs_new\ncs = ConfigurationSpace({\"a\": [1,2,3]})\n\nwith open('configspace.pcs_new', 'w') as fh:\n    fh.write(pcs_new.write(cs))\n</code></pre> <pre><code>\n</code></pre> PARAMETER DESCRIPTION <code>configuration_space</code> <p>A configuration space</p> <p> TYPE: <code>ConfigurationSpace</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The string representation of the configuration space</p> Source code in <code>src/ConfigSpace/read_and_write/pcs_new.py</code> <pre><code>@deprecated(\n    \"pcs_new.write is has stopped being maintained, please use `space.to_json`\"\n    \" or `space.to_yaml` instead\",\n)\ndef write(configuration_space: ConfigurationSpace) -&gt; str:\n    \"\"\"Create a string representation of a\n    [ConfigurationSpace][ConfigSpace.configuration_space.ConfigurationSpace]\n    in pcs_new format. This string can be written to file.\n\n    ```python exec=\"true\", source=\"material-block\" result=\"python\"\n    from ConfigSpace import ConfigurationSpace\n    from ConfigSpace.read_and_write import pcs_new\n    cs = ConfigurationSpace({\"a\": [1,2,3]})\n\n    with open('configspace.pcs_new', 'w') as fh:\n        fh.write(pcs_new.write(cs))\n    ```\n\n    Args:\n        configuration_space: A configuration space\n\n    Returns:\n        The string representation of the configuration space\n    \"\"\"\n    if not isinstance(configuration_space, ConfigurationSpace):\n        raise TypeError(\n            f\"pcs_parser.write expects an instance of {ConfigurationSpace}, \"\n            f\"you provided '{type(configuration_space)}'\",\n        )\n\n    param_lines = StringIO()\n    condition_lines = StringIO()\n    forbidden_lines = []\n    for hyperparameter in configuration_space.values():\n        # Check if the hyperparameter names are valid ConfigSpace names!\n        try:\n            pp_param_name.parseString(hyperparameter.name)\n        except pyparsing.ParseException as e:\n            raise ValueError(\n                f\"Illegal hyperparameter name for ConfigSpace: {hyperparameter.name}\",\n            ) from e\n\n        # First build params\n        if param_lines.tell() &gt; 0:\n            param_lines.write(\"\\n\")\n        if isinstance(hyperparameter, NumericalHyperparameter):\n            param_lines.write(build_continuous(hyperparameter))\n        elif isinstance(hyperparameter, CategoricalHyperparameter):\n            param_lines.write(build_categorical(hyperparameter))\n        elif isinstance(hyperparameter, OrdinalHyperparameter):\n            param_lines.write(build_ordinal(hyperparameter))\n        elif isinstance(hyperparameter, Constant):\n            param_lines.write(build_constant(hyperparameter))\n        else:\n            raise TypeError(f\"Unknown type: {type(hyperparameter)} ({hyperparameter})\")\n\n    for condition in configuration_space.conditions:\n        if condition_lines.tell() &gt; 0:\n            condition_lines.write(\"\\n\")\n        if isinstance(condition, (AndConjunction, OrConjunction)):\n            condition_lines.write(build_conjunction(condition))\n        elif isinstance(condition, Condition):\n            condition_lines.write(build_condition(condition))\n        else:\n            raise TypeError(f\"Unknown type: {type(condition)} ({condition})\")\n\n    for forbidden_clause in configuration_space.forbidden_clauses:\n        # Convert in-statement into two or more equals statements\n        dlcs = (\n            forbidden_clause.get_descendant_literal_clauses()\n            if isinstance(forbidden_clause, ForbiddenConjunction)\n            else [forbidden_clause]\n        )\n        # First, get all in statements and convert them to equal statements\n        in_statements = []\n        other_statements = []\n        for dlc in dlcs:\n            if isinstance(dlc, ForbiddenInClause):\n                in_statements.append(\n                    [\n                        ForbiddenEqualsClause(dlc.hyperparameter, value)\n                        for value in dlc.values\n                    ],\n                )\n            else:\n                other_statements.append(dlc)\n\n        # Second, create the product of all elements in the IN statements,\n        # create a ForbiddenAnd and add all ForbiddenEquals\n        if len(in_statements) &gt; 0:\n            for p in product(*in_statements):\n                all_forbidden_clauses = list(p) + other_statements\n                f = ForbiddenAndConjunction(*all_forbidden_clauses)\n                forbidden_lines.append(build_forbidden(f))\n        else:\n            if isinstance(forbidden_clause, ForbiddenRelation):\n                raise TypeError(\"ForbiddenRelation is not supported\")\n\n            forbidden_lines.append(build_forbidden(forbidden_clause))\n\n    if condition_lines.tell() &gt; 0:\n        condition_lines.seek(0)\n        param_lines.write(\"\\n\\n\")\n        for line in condition_lines:\n            param_lines.write(line)\n\n    if len(forbidden_lines) &gt; 0:\n        forbidden_lines.sort()\n        param_lines.write(\"\\n\\n\")\n        for line in forbidden_lines:\n            param_lines.write(line)\n            param_lines.write(\"\\n\")\n\n    # Check if the default configuration is a valid configuration!\n\n    param_lines.seek(0)\n    return param_lines.getvalue()\n</code></pre>"},{"location":"reference/conditions/","title":"Conditions","text":""},{"location":"reference/conditions/#conditions","title":"Conditions","text":"<p>ConfigSpace can realize equal, not equal, less than, greater than and in conditions.</p> <p>Conditions can be combined by using the conjunctions and and or. To see how to use conditions, please take a look at the user guide.</p> <p>For now, please refer to the individual API docs for these classes:</p> <ul> <li>EqualsCondition</li> <li>NotEqualsCondition</li> <li>LessThanCondition</li> <li>GreaterThanCondition</li> <li>InCondition</li> </ul> <p>To combine conditions, you can use the following classes:</p> <ul> <li>AndConjunction</li> <li>OrConjunction</li> </ul> <p>Warning</p> <p>We advise not  using the <code>EqualsCondition</code> or the <code>InCondition</code> on float hyperparameters. Due to numerical rounding that can occur, it can be the case that these conditions evaluate to <code>False</code> even if they should evaluate to <code>True</code>.</p>"},{"location":"reference/configuration/","title":"Configuration","text":""},{"location":"reference/configuration/#configuration","title":"Configuration","text":"<p>A <code>Configuration</code> is an dict-like object, going from the name of selected hyperparameters to the values.</p> <pre><code>a: 1\nb: cat\n1\n</code></pre> <p>Underneath the hood, there is some vectorized representation of the configuration, which in this case may look like <code>np.array([0.32, 1])</code> which stands for <code>{\"a\": 3.2, \"b\": \"dog\"}</code>. This vectorized representation can be useful for optimizer numerical optimization algorithms. You can access it with <code>configuration.get_array()</code>.</p> <p>Tip</p> <p>All <code>Configuration</code> have a reference to the underlying <code>ConfigurationSpace</code> which can be access with <code>Configuration.config_space</code>.</p> <p>For more, please check out the API documentation for <code>Configuration</code>.</p>"},{"location":"reference/configuration_space/","title":"Configuration Space","text":""},{"location":"reference/configuration_space/#configuration-space","title":"Configuration Space","text":"<p>Please refer to the user guide for a walkthrough or refer to the API documentation for <code>ConfigurationSpace</code>.</p>"},{"location":"reference/forbiddens/","title":"Forbidden Clauses","text":""},{"location":"reference/forbiddens/#forbidden-clauses","title":"Forbidden Clauses","text":"<p>ConfigSpace contains forbidden equal and forbidden in clauses. The ForbiddenEqualsClause and the ForbiddenInClause can forbid values to be sampled from a configuration space if a certain condition is met. The ForbiddenAndConjunction can be used to combine ForbiddenEqualsClauses and the ForbiddenInClauses.</p> <p>For a further example, please take a look in the user guide or the API docs below:</p>"},{"location":"reference/forbiddens/#static-clauses","title":"Static clauses","text":"<ul> <li>ForbiddenEqualsClause</li> <li>ForbiddenInClause</li> </ul>"},{"location":"reference/forbiddens/#conjunctions","title":"Conjunctions","text":"<ul> <li>ForbiddenAndConjunction</li> </ul>"},{"location":"reference/forbiddens/#relational-clauses","title":"Relational Clauses","text":"<ul> <li>ForbiddenLessThenRelation</li> <li>ForbiddenGreaterThanRelation</li> <li>ForbiddenEqualsRelation</li> </ul>"},{"location":"reference/hyperparameters/","title":"Hyperparameters","text":""},{"location":"reference/hyperparameters/#hyperparameters","title":"Hyperparameters","text":"<p>ConfigSpace contains three ways to define hyperparameters, each offering more customizabilty than the last. We first demonstrate the three different ways to define hyperparameters, inferred, simple, and direct.</p> <p>Later, we will show how to directly use the hyperparameters if required, however this is mostly for library developers using ConfigSpace as a dependency.</p> <ul> <li>Directly when constructing the <code>ConfigurationSpace</code> object, we call these inferred hyperparameters. Use these if you have a simple search space or are doing rapid prototyping. SourceResult <pre><code>from ConfigSpace import ConfigurationSpace\n\ncs = ConfigurationSpace(\n    {\n        \"a\": (0, 10),    # Integer from 0 to 10\n        \"b\": [\"cat\", \"dog\"],  # Categorical with choices \"cat\" and \"dog\"\n        \"c\": (0.0, 1.0),  # Float from 0.0 to 1.0\n    }\n)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: UniformInteger, Range: [0, 10], Default: 5\n    b, Type: Categorical, Choices: {cat, dog}, Default: cat\n    c, Type: UniformFloat, Range: [0.0, 1.0], Default: 0.5\n</code></pre> </li> <li>Using functions to create them for you. We call these simple hyperparameters and they should satisfy most use cases. Use these if you just want to create a searchspace required by another library. SourceResult <pre><code>from ConfigSpace import ConfigurationSpace, Integer, Categorical, Float, Normal\n\ncs = ConfigurationSpace(\n    {\n        \"a\": Integer(\"a\", (0, 10), log=False),    # Integer from 0 to 10\n        \"b\": Categorical(\"b\", [\"cat\", \"dog\"], ordered=True),  # Ordered categorical with choices \"cat\" and \"dog\"\n        \"c\": Float(\"c\", (1e-5, 1e2), log=True),  # Float from 0.0 to 1.0, log scaled\n        \"d\": Float(\"d\", (10, 20), distribution=Normal(15, 2)),  # Float from 10 to 20, normal distribution\n    }\n)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: UniformInteger, Range: [0, 10], Default: 5\n    b, Type: Ordinal, Sequence: {cat, dog}, Default: cat\n    c, Type: UniformFloat, Range: [1e-05, 100.0], Default: 0.0316227766017, on log-scale\n    d, Type: NormalFloat, Mu: 15.0, Sigma: 2.0, Range: [10.0, 20.0], Default: 15.0\n</code></pre> </li> <li>Using the types directly. We call these direct hyperparameters. These are the real types used throughout ConfigSpace and offer the most customizability. Use these if you are building a library the utilizes ConfigSpace. SourceResult <pre><code>from ConfigSpace import (\n    ConfigurationSpace,\n    UniformIntegerHyperparameter,\n    CategoricalHyperparameter,\n    UniformFloatHyperparameter,\n    NormalFloatHyperparameter,\n    OrdinalHyperparameter\n)\n\ncs = ConfigurationSpace(\n    {\n        \"a\": UniformIntegerHyperparameter(\"a\", lower=0, upper=10, log=False),    # Integer from 0 to 10\n        \"b\": CategoricalHyperparameter(\"b\", choices=[\"cat\", \"dog\"], default_value=\"dog\"),  # Ordered categorical with choices \"cat\" and \"dog\"\n        \"c\": UniformFloatHyperparameter(\"c\", lower=1e-5, upper=1e2, log=True),  # Float from 0.0 to 1.0, log scaled\n        \"d\": NormalFloatHyperparameter(\"d\", lower=10, upper=20, mu=15, sigma=2),  # Float from 10 to 20, normal distribution\n        \"e\": OrdinalHyperparameter(\"e\", sequence=[\"s\", \"m\", \"l\"], default_value=\"s\"),  # Ordered categorical\n    }\n)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: UniformInteger, Range: [0, 10], Default: 5\n    b, Type: Categorical, Choices: {cat, dog}, Default: dog\n    c, Type: UniformFloat, Range: [1e-05, 100.0], Default: 0.0316227766017, on log-scale\n    d, Type: NormalFloat, Mu: 15.0, Sigma: 2.0, Range: [10.0, 20.0], Default: 15.0\n    e, Type: Ordinal, Sequence: {s, m, l}, Default: s\n</code></pre> </li> </ul>"},{"location":"reference/hyperparameters/#inferred-hyperparameters","title":"Inferred Hyperparameters","text":"<p>When creating hyperparameters directly in the <code>ConfigurationSpace</code> object, you can create three different kinds of hyperparameters. This can be useful for simple testing or quick prototyping.</p> <pre><code>from ConfigSpace import ConfigurationSpace\n\ncs = ConfigurationSpace(\n    {\n        \"a\": (0, 10),    # Integer from 0 to 10\n        \"b\": [\"cat\", \"dog\"],  # Categorical with choices \"cat\" and \"dog\"\n        \"c\": (0.0, 1.0)  # Float from 0.0 to 1.0\n    }\n)\nprint(cs)\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: UniformInteger, Range: [0, 10], Default: 5\n    b, Type: Categorical, Choices: {cat, dog}, Default: cat\n    c, Type: UniformFloat, Range: [0.0, 1.0], Default: 0.5\n</code></pre> <p>The rules are as follows:</p> <ul> <li>If the value is a tuple, with <code>int</code>s, then it is considered an integer hyperparameter with a uniform distribution.</li> <li>If the value is a tuple, with <code>float</code>s, then it is considered a float hyperparameter with a uniform distribution.</li> <li>If the value is a list, then each element is considered a choice for a categorical hyperparameter, with no inherit order.</li> </ul> <p>Mixed types in a tuple</p> <p>If you use an <code>int</code> and a <code>float</code> in the same tuple, it will infer the type using the first element. For example, <code>(0, 1.0)</code> will be inferred as an integer hyperparameter, while <code>(1.0, 10)</code> will be inferred as a float hyperparameter.</p>"},{"location":"reference/hyperparameters/#simple-hyperparameters","title":"Simple Hyperparameters","text":"<p>Most of the time, you just require the ability to create hyperparameters and pass them to some other library. To make this is as possible, we parametrize building the various direct hyperparameters that exist.</p>"},{"location":"reference/hyperparameters/#integer","title":"Integer","text":"<p>The <code>Integer()</code> function samples an <code>int</code> uniformly from the range <code>(lower, upper)</code>, with options to define them as being on a <code>log=</code> scale or that you prefer the sampling to be done under a different <code>distribution=</code>. <pre><code>from ConfigSpace import Integer, ConfigurationSpace, Uniform, Normal\n\ncs = ConfigurationSpace()\n\ncs.add(\n    Integer(\"a\", (0, 10), log=False),\n    Integer(\"b\", (0, 10), log=False, distribution=Uniform(), default=5),\n    Integer(\"c\", (1, 1000), log=True, distribution=Normal(mu=200, sigma=200)),\n)\nprint(cs)\nprint(cs[\"a\"].sample_value(size=5))\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: UniformInteger, Range: [0, 10], Default: 5\n    b, Type: UniformInteger, Range: [0, 10], Default: 5\n    c, Type: NormalInteger, Mu: 200.0, Sigma: 200.0, Range: [1, 1000], Default: 200, on log-scale\n\n[ 5  1 10  7  4]\n</code></pre> </p> <p>Please check out the distributions API for more information on the available distributions.</p> <p>Not a type</p> <p>Please be aware that <code>Integer</code> is a convenience function that returns one of the direct hyperparameter classes. Please see the direct hyperparameters if you need to access the underlying classes.</p>"},{"location":"reference/hyperparameters/#float","title":"Float","text":"<p>The <code>Float()</code> function samples a <code>float</code> uniformly from the range <code>(lower, upper)</code>, with options to define them as being on a <code>log=</code> scale or that you prefer the sampling to be done under a different <code>distribution=</code>. <pre><code>from ConfigSpace import Float, ConfigurationSpace, Uniform, Normal\n\ncs = ConfigurationSpace()\n\ncs.add(\n    Float(\"a\", (0, 10), log=False),\n    Float(\"b\", (0, 10), log=False, distribution=Uniform(), default=5),\n    Float(\"c\", (1, 1000), log=True, distribution=Normal(mu=200, sigma=200)),\n)\nprint(cs)\nprint(cs[\"a\"].sample_value(size=5))\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: UniformFloat, Range: [0.0, 10.0], Default: 5.0\n    b, Type: UniformFloat, Range: [0.0, 10.0], Default: 5.0\n    c, Type: NormalFloat, Mu: 200.0, Sigma: 200.0, Range: [1.0, 1000.0], Default: 200.0, on log-scale\n\n[6.03405595 9.75563404 3.52955942 6.52923557 6.61681522]\n</code></pre> </p> <p>Please check out the distributions API for more information on the available distributions.</p> <p>Not a type</p> <p>Please be aware that <code>Float</code> is a convenience function that returns one of the direct hyperparameter classes. Please see the direct hyperparameters if you need to access the underlying classes.</p>"},{"location":"reference/hyperparameters/#categorical","title":"Categorical","text":"<p>The <code>Categorical()</code> function samples a value from the <code>choices=</code> provided. optionally giving them <code>weights=</code>, influencing the distribution of the sampling. You may also define them as <code>ordered=</code> if there is an inherent order to the choices. <pre><code>from ConfigSpace import Categorical, ConfigurationSpace\n\ncs = ConfigurationSpace()\n\ncs.add(\n    Categorical(\"a\", [\"cat\", \"dog\", \"mouse\"], default=\"dog\"),\n    Categorical(\"b\", [\"small\", \"medium\", \"large\"], ordered=True, default=\"medium\"),\n    Categorical(\"c\", [True, False], weights=[0.2, 0.8]),\n)\nprint(cs)\nprint(cs[\"c\"].sample_value(size=5))\n</code></pre> <pre><code>Configuration space object:\n  Hyperparameters:\n    a, Type: Categorical, Choices: {cat, dog, mouse}, Default: dog\n    b, Type: Ordinal, Sequence: {small, medium, large}, Default: medium\n    c, Type: Categorical, Choices: {True, False}, Default: False, Probabilities: [0.2 0.8]\n\n[ True False False  True False]\n</code></pre> </p> <p>Not a type</p> <p>Please be aware that <code>Categorical</code> is a convenience function that returns one of the direct hyperparameter classes. Please see the direct hyperparameters if you need to access the underlying classes.</p>"},{"location":"reference/hyperparameters/#direct-hyperparameters","title":"Direct Hyperparameters","text":"<p>All of the methods for constructing hyperparameters above will result in one of the following types.</p> <p>Integer Hyperparameter</p> <ul> <li><code>UniformIntegerHyperparameter</code></li> <li><code>NormalIntegerHyperparameter</code></li> <li><code>BetaIntegerHyperparameter</code></li> </ul> <p>Float Hyperparameter</p> <ul> <li><code>UniformFloatHyperparameter</code></li> <li><code>NormalFloatHyperparameter</code></li> <li><code>BetaFloatHyperparameter</code></li> </ul> <p>Categorical Hyperparameter</p> <ul> <li><code>CategoricalHyperparameter</code></li> <li><code>OrdinalHyperparameter</code></li> </ul> <p>You can utilize these types in your code as required for <code>isinstance</code> checks or allow your own code to create them as required. If developing a library, please see below to understand a bit more about the structure of a Hyperparameter.</p>"},{"location":"reference/hyperparameters/#structure-of-a-hyperparameter","title":"Structure of a Hyperparameter","text":"<p>All hyperparameters inherit from the <code>Hyperparameter</code> base class, with two important components to consider:</p> <ol> <li>vectorized space: This defines some underlying numeric range along with a procedure to sample from it.</li> <li>value space: These are the values that are given back to the user, e.g. <code>[\"cat\", \"dog\"]</code>.</li> </ol> <p>What makes a hyperparameter the hyperparameter it is then:</p> <ol> <li>How we sample from the vectorized space, defined by a <code>Distribution</code>.</li> <li>How we map to and from the vectorized space to the value space, defined by a <code>Transformer</code>.</li> </ol> Why a vectorized space? <p>Most optimizers requires some kind of bounds and a pure numeric space from which to optimize over, i.e. it would be hard to optimize over a hyperparameter space of <code>[\"cat\", \"dog\"]</code> directly.</p> <p>This also lets use share implementation details and optimization across various kinds of hyperparameters if they share the same underlying vectorized space.</p> <p>CategoricalHyperparameter</p> <p>Inside of the <code>__init__</code> method of a <code>CategoricalHyperparameter</code>, you will find something along the lines of the following:</p> <pre><code>class CategoricalHyperparameter(Hyperparameter):\n    def __init__(...):\n\n        # ...\n        super().__init__(\n            vector_dist=UniformIntegerDistribution(size=len(choices)),\n            transformer=TransformerSeq(seq=choices),\n            ...\n        )\n</code></pre> <p>What this is showing is that we will use <code>UniformIntegerDistribution</code>, which samples integers uniformly from <code>0</code> to <code>len(choices) - 1</code>, and then we use a <code>TransformerSeq</code> to map these integers to the corresponding choices provided by the users.</p> <p>Internally in <code>ConfigSpace</code>, we will primarily work with the vectorized space for efficiency purposes, but when providing values back to the user, either from the <code>Configuration</code> or other means, we will use the <code>transformer=</code> to map the vectorized space back to the value space.</p> <p>Using just these two components alone, we can provide the following functionality from the <code>Hyperparameter</code> base class:</p> <ul> <li><code>sample_vector()</code>: Samples a vectorized value</li> <li><code>sample_value()</code>: Samples a vectorized value and transforms it back to the value space.</li> <li><code>to_value()</code>: Transforms a vectorized value to the value space.</li> <li><code>to_vector()</code>: Transforms a value space value to the vectorized space.</li> <li><code>pdf_vector()</code>: The probability density function of a vectorized value.</li> <li><code>pdf_values()</code>: The probability density function of a value,   by transforming it to the vectorized space and then calculating the pdf.</li> <li><code>legal_value()</code>: Check if a value is legal.</li> <li><code>legal_vector()</code>: Check if a vectorized value is legal.</li> <li><code>.lower_vectorized</code>: The lower bound in vectorized space.</li> <li><code>.upper_vectorized</code>: The upper bound in vectorized space.</li> </ul> <p>Please note that most of these methods support individual values or numpy arrays of values, either as input or output. Refer to the API documentation for more information on the available methods.</p>"},{"location":"reference/hyperparameters/#neighborhoods","title":"Neighborhoods","text":"<p>One utility <code>ConfigSpace</code> provides to library developers is the ability to define a neighbourhood around a value. This is often important for optimizers who require a neighbourhood to explore around a particular configuration or value.</p> <p>A class inheriting from <code>Hyperparameter</code> must also provide a <code>Neighborhood</code>, which is something that can be called with a vectorized value and provide values around that point.</p> <p>The expected signature is rather straight forward, given a <code>vector</code> value and a <code>n</code> number of samples to return, it should return a numpy array of up to <code>n</code> unique samples.</p> <pre><code>def __call__(\n    self,\n    vector: np.float64,\n    n: int,\n    *,\n    std: float | None = None,\n    seed: RandomState | None = None,\n) -&gt; npt.NDArray[np.float64]: ...\n</code></pre> <p>They must also provide a <code>_neighbourhood_size</code>, either <code>np.inf</code> if unbounded or a method that returns the maximum possible neighbors that are possible around a given value.</p> <p>By subclasses providing this through the <code>__init__</code> method, we can then provide the following functionality:</p> <ul> <li><code>get_num_neighbors()</code>: Get the number of neighbours around a value.</li> <li><code>neighbors_vectorized()</code>: Get neighbors around a point in vectorized space.</li> <li><code>neighbors_values()</code>: Get neighbors around a point in value space.</li> </ul> <p>Please refer to the source code definition of existing hyperparameters for more information on how to implement this. Most of this is defined in the <code>__init__</code> method of the hyperparameter.</p>"},{"location":"reference/hyperparameters/#example-implementing-the-betaintegerhyperparameter","title":"Example: Implementing the BetaIntegerHyperparameter","text":"<p>For implementing your own hyperparameter type, it's useful to look at a case study of implementing an existing hyperparameter and to see what functionality can be re-used in the library. Please refer to this article on Wikipedia for more information on the Beta distribution for more on the distribution.</p> <p>Tip</p> <p>Be aware the <code>ConfigSpace</code> is heavily optimized towards performance using profiling, and where possible, it would be good to use pre-existing components to build your hyperparameter. You'd be surprised how much milliseconds add up when sampling thousands of configurations both globally and using neighborhoods.</p>"},{"location":"reference/hyperparameters/#defining-the-betaintegerhyperparameter","title":"Defining the BetaintegerHyperparameter","text":"<p>First, we need to define the <code>__init__</code> method of the <code>BetaIntegerHyperparameter</code>, where we're going to need the following for a <code>BetaIntegerHyperparameter</code>:</p> <ul> <li><code>name=</code>: The name of the hyperparameter, required for all kinds of hyperparameters</li> <li><code>lower=</code>, <code>upper=</code>: The bounds the user would like in value space, i.e. <code>(1, 5)</code></li> <li><code>default_value=</code>: The default value of the hyperparameter.</li> <li><code>alpha=</code>, <code>beta=</code>: The parameters of the beta distribution itself.</li> </ul>"},{"location":"reference/hyperparameters/#vectorized-space","title":"Vectorized Space","text":"<p>For our purposes, we will mostly rely on scipys <code>beta</code> distribution to sample from a vectorized space. Here is how you would sample from it in <code>scipy:</code></p> <pre><code>from scipy.stats import beta as spbeta\n\nalpha, beta = 3, 2\nbeta_rv = spbeta(alpha, beta)\nsamples = beta_rv.rvs(size=5)\nprint(samples)\n</code></pre> <pre><code>[0.43144202 0.90580642 0.25557401 0.57793044 0.67097949]\n</code></pre> <p>The problem however is that scipy only offers a contiuous version of this distribution, however we need to sample integers. To solve this, we will use the <code>DiscretizedContinuousScipyDistribution</code></p> <pre><code>import numpy as np\nfrom scipy.stats import beta as spbeta\nfrom ConfigSpace.hyperparameters.distributions import DiscretizedContinuousScipyDistribution\n\n# As before\nalpha, beta = 3, 2\nbeta_rv = spbeta(alpha, beta)\n\n\n# Declare our value space bounds and how many discrete steps there\n# are between them.\nvalue_bounds = (1, 5)\ndiscrete_steps = value_bounds[1] - value_bounds[0] + 1\n\n# Creates a distribution which can discretize the continuous range\n# into `size` number of steps, such that we can map the discretized\n# vector values into integers in the range that was requested.\n\n# Where possible, it is usually preferable to have vectorized bounds from (0, 1)\n# We also require all vectorized values to be np.float64, even if they represent integers\nvector_distribution = DiscretizedContinuousScipyDistribution(\n    rv=beta_rv,\n    steps=discrete_steps,\n    lower_vectorized=np.float64(0),\n    upper_vectorized=np.float64(1),\n)\nprint(vector_distribution.sample_vector(n=5))\n</code></pre> <pre><code>[1.   0.25 0.75 0.25 0.25]\n</code></pre> <p>Tip</p> <p>To support <code>scipy</code> distributions we implement various optimized <code>Distribution</code>s</p> <ul> <li><code>ScipyContinuousDistribution</code>: Samples from a continuous scipy distribution.</li> <li><code>ScipyDiscreteDistribution</code>: Samples from a discrete scipy distribution.</li> <li><code>DiscretizedContinuousScipyDistribution</code>: Samples from a continuous scipy distribution, but discretizes the output efficiently.</li> </ul> <p>The also often provide a <code>neighborhood</code> method to sample around a point that can be used, as well as a <code>pdf</code> method, which can do so efficiently in both memory and time. Please refer to their individual API documentation for more information on how to create and use them.</p>"},{"location":"reference/hyperparameters/#transforming-from-vectorized-space-to-value-space","title":"Transforming from Vectorized Space to Value Space","text":"<p>To convert from the vectorized space to the value space, we will need to implement a <code>Transformer</code> that can map the vectorized space to the value space, e.g. <code>(0.0, 1.0)</code> to <code>(1, 5)</code>.</p> <p>To do this, we provide a convenience class called <code>UnitScaler</code>, which also allows for a <code>log=</code> scale transformation.</p> <pre><code>import numpy as np\nfrom scipy.stats import beta as spbeta\nfrom ConfigSpace.hyperparameters.distributions import DiscretizedContinuousScipyDistribution\nfrom ConfigSpace.hyperparameters.hp_components import UnitScaler\n\n# Define the distribution sampler\nalpha, beta = 3, 2\nvector_distribution = DiscretizedContinuousScipyDistribution(\n    rv=spbeta(alpha, beta),\n    steps=5,\n    lower_vectorized=np.float64(0),\n    upper_vectorized=np.float64(1),\n)\nvector_samples = vector_distribution.sample_vector(n=5)\nprint(vector_samples)\n\n# Define the transformer from the samplers range to the range we care about\ntransformer = UnitScaler(\n    lower_value=np.int64(1),\n    upper_value=np.int64(5),\n    dtype=np.int64,  # We want integers in value space\n    log=False,\n)\ninteger_values = transformer.to_value(vector_samples)\nprint(integer_values)\n\nback_to_vector = transformer.to_vector(integer_values)\nprint(back_to_vector)\n</code></pre> <pre><code>[1.   0.5  0.75 0.5  0.5 ]\n[5 3 4 3 3]\n[1.   0.5  0.75 0.5  0.5 ]\n</code></pre> <p>You are of course free to implement your own <code>Transformer</code> if you require a more complex transformation, however where possible, the <code>UnitScaler</code> is preffered as it handles some edge cases and performs some optimized routines while remaining fully within the expected API.</p>"},{"location":"reference/hyperparameters/#creating-the-betaintegerhyperparameter-class","title":"Creating the BetaIntegerHyperparameter class","text":"<p>Below we provide what is essentially the entire <code>BetaIntegerHyperparameter</code> in <code>ConfigSpace</code>. Nothing else is required and you can hotswap this out with other kinds of distributions if you require new kinds of <code>Hyperparameters</code>. Most libraries using <code>ConfigSpace</code> who do not require explicit kinds of hyperparameters should be able to utilize these.</p> <p>Note</p> <p>We use dataclasses in ConfigSpace, which means that inherting classes should also be a dataclass. This is not a strict requirement, but it is recommended to keep the API consistent.</p> <pre><code>from typing import TypeAlias, Union, Mapping, Hashable, Any\nimport numpy as np\nfrom scipy.stats import beta as spbeta\n\nfrom ConfigSpace.hyperparameters import IntegerHyperparameter\nfrom ConfigSpace.hyperparameters.distributions import DiscretizedContinuousScipyDistribution\nfrom ConfigSpace.hyperparameters.hp_components import UnitScaler\nfrom ConfigSpace.functional import is_close_to_integer_single\n\ni64 = np.int64\nf64 = np.float64\n\n# We allow any kind of number to be used, we will cast as required\nNumber: TypeAlias = Union[int, float, np.number]\n\n@dataclass(init=False)  # We provide our own init\nclass BetaIntegerHyperparamter(IntegerHyperparameter):\n    ORDERABLE: ClassVar[bool] = True  # Let ConfigSpace know there is an order to the values\n\n    alpha: float\n    \"\"\"Some docstring decsription of this attribute.\"\"\"\n\n    beta: float\n    lower: float\n    upper: float\n    log: bool\n    name: str\n    default_value: float\n    meta: Mapping[Hashable, Any] | None\n\n    size: float = field(init=False)  # This will be calculated\n\n    def __init__(\n        self,\n        name: str,\n        alpha: Number,\n        beta: Number,\n        lower: Number,\n        upper: Number,\n        default_value: Number | None = None,\n        log: bool = False,\n        meta: Mapping[Hashable, Any] | None = None,\n    ) -&gt; None:\n        if (alpha &lt; 1) or (beta &lt; 1):\n            raise ValueError(\n                \"Please provide values of alpha and beta larger than or equal to\"\n                \"1 so that the probability density is finite.\",\n            )\n        self.alpha = float(alpha)\n        self.beta = float(beta)\n        self.lower = int(np.rint(lower))\n        self.upper = int(np.rint(upper))\n        self.log = bool(log)\n\n        # Create the transformer\n        try:\n            scaler = UnitScaler(i64(self.lower), i64(self.upper), log=log, dtype=i64)\n        except ValueError as e:\n            raise ValueError(f\"Hyperparameter '{name}' has illegal settings\") from e\n\n\n        if default_value is None:\n            # Get the mode of the distribution for setting a default\n            if (self.alpha &gt; 1) or (self.beta &gt; 1):\n                vectorized_mode = (self.alpha - 1) / (self.alpha + self.beta - 2)\n            else:\n                # If both alpha and beta are 1, we have a uniform distribution.\n                vectorized_mode = 0.5\n\n            _default_value = np.rint(\n                scaler.to_value(np.array([vectorized_mode]))[0],\n            ).astype(i64)\n        else:\n            if not is_close_to_integer_single(default_value):\n                raise TypeError(\n                    f\"`default_value` for hyperparameter '{name}' must be an integer.\"\n                    f\" Got '{type(default_value).__name__}' for {default_value=}.\",\n                )\n\n            _default_value = np.rint(default_value).astype(i64)\n\n        size = int(self.upper - self.lower + 1)\n        vector_dist = DiscretizedContinuousScipyDistribution(\n            rv=spbeta(self.alpha, self.beta),  # type: ignore\n            steps=size,\n            lower_vectorized=f64(0.0),\n            upper_vectorized=f64(1.0),\n        )\n\n        super().__init__(\n            name=name,\n            size=size,\n            default_value=_default_value,\n            meta=meta,\n            transformer=scaler,\n            vector_dist=vector_dist,\n            neighborhood=vector_dist.neighborhood,\n            # Tell ConfigSpace we expect an `int` when giving back a single value\n            # For a np.ndarray of values, this will be `np.int64`\n            value_cast=int,\n            # This method comes from the IntegerHyperparameter\n            # you can implement this you self if you'd like\n            neighborhood_size=self._integer_neighborhood_size,\n        )\n</code></pre>"},{"location":"reference/serialization/","title":"Serialization","text":""},{"location":"reference/serialization/#serialization","title":"Serialization","text":"<p>ConfigSpaces overs two primary methods of serialization, namely <code>json</code> and <code>yaml</code>. Serializing is straight forward and can be done using the methods <code>configspace.to_json()</code> and <code>configspace.to_yaml()</code>. To deserialize, you can call the corresponding classmethods <code>ConfigurationSpace.from_json()</code> and <code>ConfigurationSpace.from_yaml()</code>.</p> <pre><code>from ConfigSpace import ConfigurationSpace\ncs = ConfigurationSpace({\"a\": (0, 10), \"b\": [\"cat\", \"dog\"]})\ncs.to_json(\"configspace.json\")\ncs = ConfigurationSpace.from_json(\"configspace.json\")\n\ncs.to_yaml(\"configspace.yaml\")\ncs = ConfigurationSpace.from_yaml(\"configspace.yaml\")\n</code></pre>"},{"location":"reference/serialization/#plain-type-dict","title":"Plain type dict","text":"<p>We also support exporting the configuration space as a dictionary with plain simple python types. This allows for easy serialization to other formats the support dictionary formats, for example, <code>toml</code>.</p> <p>This is provided through <code>to_serialized_dict()</code> and <code>from_serialized_dict()</code>.</p>"},{"location":"reference/serialization/#custom-encoding-and-decoding","title":"Custom Encoding and Decoding","text":"<p>To support custom hyperparameters or various other purposes, we allow you to include custom methods for encoding and decoding, based on the type encountered.</p>"},{"location":"reference/serialization/#encoding","title":"Encoding","text":"<p>For example, all serializing methods accept an <code>encoders=</code> parameter, which is a dictionary of <code>type: (type_name_as_str, encoder)</code> pairs.</p> <p>For example: <pre><code>from typing import Any, Callable\nfrom ConfigSpace import ConfigurationSpace, CategoricalHyperparameter\n\ncs = ConfigurationSpace({\"a\": [\"cat\", \"dog\"]})\n\ndef my_custom_encoder(\n    hp: CategoricalHyperparameter,\n    encoder: Callable[[Any], dict],\n) -&gt; dict:\n    return {\n        \"name\": hp.name,\n        \"choices\": [f\"!{c}!\" for c in hp.choices],\n    }\n\nwithout_custom_encoder = cs.to_serialized_dict()\nwith_custom_encoder = cs.to_serialized_dict(\n    # Overrides the default encoder for CategoricalHyperparameters\n    encoders={\n        CategoricalHyperparameter: (\"my_category\", my_custom_encoder),\n    }\n)\nprint(without_custom_encoder)\nprint(\"--------\")\nprint(with_custom_encoder)\n</code></pre> <pre><code>{'name': None, 'hyperparameters': [{'type': 'categorical', 'name': 'a', 'choices': ['cat', 'dog'], 'weights': None, 'default_value': 'cat', 'meta': None}], 'conditions': [], 'forbiddens': [], 'python_module_version': '1.1.3', 'format_version': 0.4}\n--------\n{'name': None, 'hyperparameters': [{'type': 'my_category', 'name': 'a', 'choices': ['!cat!', '!dog!']}], 'conditions': [], 'forbiddens': [], 'python_module_version': '1.1.3', 'format_version': 0.4}\n</code></pre> </p> <p>The second argument to the encoder is a callable that can be used to encode any nested types, deferring to the encoder for that type. This is useful for types such as conditionals or forbidden clauses, which often contain hyperparameters within them.</p>"},{"location":"reference/serialization/#decoding","title":"Decoding","text":"<p>Decoding is quite similar with a few minor differences to specification.</p> <pre><code>def my_decoder(\n    # The dictionary that needs to be decoded into a type\n    d: dict[str, Any],\n    # The current state of the ConfigurationSpace being decoded\n    space: ConfigurationSpace,\n    # A callable to offload decoding of nested types\n    decoder: Callable\n) -&gt; Any:\n    ...\n</code></pre> <p>As things such as conditions and forbidden clauses rely on hyperparmeters to be decoded first, you need to specify what kind of thing your decoder will operate on, namely <code>\"hyperparameters\"</code>, <code>\"conditions\"</code> or <code>\"forbiddens\"</code>.</p> <pre><code>my_configspace = ConfigurationSpace.from_serialized_dict(\n    my_serialized_dict,\n    # Overrides the default decoder for CategoricalHyperparameters\n    decoders={\n        \"hyperparameters\": {\n            \"my_category\": my_decoder,\n        },\n        \"conditions\": {},  # No need to specify, just here for completeness\n        \"forbiddens\": {},  # No need to specify, just here for completeness\n    }\n)\n</code></pre>"},{"location":"reference/serialization/#pcs","title":"PCS","text":"<p>A common format for serialization of configuration spaces used to be the <code>PCS</code> format. For those familiar with this, we still provide this using <code>ConfigSpace.read_and_write.pcs_new.read()</code> and <code>ConfigSpace.read_and_write.pcs_new.write()</code>.</p> <p>However this format is no longer directly supported and will issue deprecation warnings. Going forward, we recommend using <code>json</code> or <code>yaml</code> where possible, as newer version of ConfigSpace may include features not supported by the <code>PCS</code> format.</p>"}]}